<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1d4ed8">
    <title>WMAP10151704</title>
    
    <!-- KML/KMZ 파일 처리 라이브러리 -->
    <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            -webkit-overflow-scrolling: touch;
        }
        #map {
            width: 100vw;
            height: 100vh;
            min-height: 100%;
            touch-action: manipulation;
        }
        h1 {
            display: none;
        }

        /* 사이드바 스타일 - 모바일 최적화 */
        #customMapMenu {
            position: absolute;
            top: 20px;
            left: 15px;
            z-index: 10;
            width: 200px;
            max-width: 85vw;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            padding: 15px 12px 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            transition: all 0.3s ease;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            scroll-behavior: smooth;
            /* 스크롤 민감도 향상 */
            touch-action: pan-y;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
        }
        #customMapMenu.hide {
            left: -220px;
            opacity: 0;
            pointer-events: none;
        }
        #customMapMenu h2 {
            font-size: 1.1rem;
            font-weight: 700;
            margin: 0 0 10px 0;
            color: #1a1a1a;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }
        .menu-group {
            margin-bottom: 2px;
        }
        .menu-group label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 5px;
            display: block;
            color: #1a1a1a;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }
        /* 공통 버튼 스타일 - 터치 친화적 */
        .menu-group button, .toggle-btn, .map-type-btn {
            width: 100%;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            padding: 8px 6px;
            margin-bottom: 2px;
            font-size: 0.9rem;
            color: #1a1a1a;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            min-height: 31px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .menu-group button:hover, .toggle-btn:hover, .map-type-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            color: #000;
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        .menu-group button:active, .toggle-btn:active, .map-type-btn:active {
            background: rgba(255, 255, 255, 0.7);
            transform: scale(0.98);
        }
        .menu-group .submenu {
            margin-left: 10px;
            margin-top: 3px;
        }
        
        /* 마커 타이틀 라벨 스타일 */
        .marker-title-label {
            background: rgba(255, 255, 255, 0.95);
            padding: 3px 8px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            white-space: nowrap;
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* 마커 정보창 스와이프 편집 기능을 위한 스타일 */
        .marker-info-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
        }
        
        .marker-info-content {
            position: relative;
            transition: transform 0.3s ease;
            background: transparent;
            border-radius: 8px;
            cursor: grab;
        }
        
        .marker-info-content:active {
            cursor: grabbing;
        }
        
        .marker-info-container.swiped .marker-info-content {
            width: var(--content-width, 100%);
            transition: width 0.3s ease;
        }
        
        .marker-swipe-edit-btn {
            position: absolute;
            right: -80px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            color: #8b5cf6;
            border: 1px solid #8b5cf6;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 32px;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
        }
        
        .marker-info-container.swiped .marker-swipe-edit-btn {
            right: 8px;
        }
        
        .marker-swipe-edit-btn:hover {
            background: rgba(139, 92, 246, 0.1);
            border-color: #7c3aed;
            color: #7c3aed;
        }
        
        .marker-swipe-edit-btn:active {
            background: rgba(139, 92, 246, 0.2);
            border-color: #6d28d9;
            color: #6d28d9;
            transform: translateY(-50%) scale(0.95);
        }
        
        /* 데스크톱에서 항상 표시되는 편집 버튼 */
        @media (min-width: 769px) {
            .marker-info-container .marker-swipe-edit-btn {
                position: static;
                right: auto;
                top: auto;
                transform: none;
                margin-left: 8px;
                display: flex;
            }
            
            .marker-info-container .marker-info-content {
                cursor: default;
            }
            
            .marker-info-container .marker-info-content:active {
                cursor: default;
            }
            
            .route-info-container .route-swipe-edit-btn {
                position: static;
                right: auto;
                top: auto;
                transform: none;
                margin-left: 8px;
                display: flex;
            }
            
            .route-info-container .route-info-content {
                cursor: default;
            }
            
            .route-info-container .route-info-content:active {
                cursor: default;
            }
        }
        
        /* 경로 정보창 스와이프 편집 기능을 위한 스타일 */
        .route-info-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
        }
        
        .route-info-content {
            position: relative;
            transition: transform 0.3s ease;
            background: transparent;
            border-radius: 8px;
            cursor: grab;
        }
        
        .route-info-content:active {
            cursor: grabbing;
        }
        
        .route-info-container.swiped .route-info-content {
            width: var(--content-width, 100%);
            transition: width 0.3s ease;
        }
        
        .route-swipe-edit-btn {
            position: absolute;
            right: -80px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            color: #3b82f6;
            border: 1px solid #3b82f6;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 32px;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
        }
        
        .route-info-container.swiped .route-swipe-edit-btn {
            right: 8px;
        }
        
        .route-swipe-edit-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: #2563eb;
            color: #2563eb;
        }
        
        .route-swipe-edit-btn:active {
            background: rgba(59, 130, 246, 0.2);
            border-color: #1d4ed8;
            color: #1d4ed8;
            transform: translateY(-50%) scale(0.95);
        }
        
        /* 사이드 패널 토글 버튼 - 모바일 최적화 */
        #menuToggleBtn {
            position: absolute;
            top: 20px;
            left: 15px;
            z-index: 20;
            background: rgba(29, 78, 216, 0.5);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            font-size: 1.4rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.2s ease;
        }
        #menuToggleBtn.show {
            display: flex;
        }
        #menuToggleBtn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .toggle-btn {
            text-align: left;
            font-weight: 600;
        }
        
        /* 하위 옵션 들여쓰기 */
        .submenu {
            margin-left: 15px;
        }
        .submenu .submenu {
            margin-left: 15px;
        }
        .submenu button {
            width: 90%;
            margin-left: 0;
        }
        
        /* 구글맵 하위 옵션 들여쓰기 */
        #googleMapMenu > .toggle-btn {
            margin-left: 15px;
        }
        
        /* 오른쪽 상단 지도 타입 선택 버튼 - 모바일 최적화 */
        #mapTypeSelector {
            position: absolute;
            top: 20px;
            right: 15px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            padding: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
        }
        
        #mapTypeSelector.hide {
            right: -180px;
            opacity: 0;
            pointer-events: none;
        }
        

        
        /* GPS 위치 버튼 스타일 */
        #locationBtn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 10;
            background: transparent;
            color: #333;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.2s ease;
        }
        
        #locationBtn:hover {
            background: rgba(51, 51, 51, 0.1);
            transform: scale(1.05);
        }
        
        #locationBtn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        #locationBtn.loading {
            background: #6b7280;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* 오른쪽 상단 토글 버튼 - 모바일 최적화 */
        #rightMenuToggleBtn {
            position: absolute;
            top: 20px;
            right: 15px;
            z-index: 20;
            background: rgba(29, 78, 216, 0.5);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            font-size: 1.4rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.2s ease;
        }
        #rightMenuToggleBtn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .map-type-btn {
            justify-content: center;
            font-weight: 600;
            padding: 12px 16px;
        }
        

        
        .map-type-btn.active {
            background: #1d4ed8;
            color: white;
            border-color: #1d4ed8;
        }
        
        .map-type-btn.sub-option {
            margin-left: 0;
            font-size: 0.8rem;
            padding: 8px 12px;
            font-weight: 500;
            opacity: 0.9;
            background: rgba(255, 255, 255, 0.5);
        }
        
        /* 하위 버튼이 활성화될 때는 텍스트를 검은색으로 유지 */
        .map-type-btn.sub-option.active {
            color: #1a1a1a;
            background: rgba(29, 78, 216, 0.2);
            border-color: #1d4ed8;
        }
        
        /* 모바일 최적화를 위한 미디어 쿼리 */
        @media (max-width: 768px) {
            #customMapMenu {
                width: 180px;
                max-width: 80vw;
                top: 15px;
                left: 10px;
                padding: 12px 10px 10px 10px;
                max-height: calc(100vh - 30px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                scroll-behavior: smooth;
            }
            
            #customMapMenu.hide {
                left: -200px;
            }
            
            #menuToggleBtn, #rightMenuToggleBtn {
                width: 44px;
                height: 44px;
                font-size: 1.3rem;
                top: 15px;
            }
            
            #menuToggleBtn {
                left: 10px;
            }
            
            #rightMenuToggleBtn {
                right: 10px;
            }
            
            #mapTypeSelector {
                top: 15px;
                right: 10px;
            }
            
            .map-type-btn {
                padding: 7px 10px;
                font-size: 0.85rem;
                min-height: 28px;
            }
            
            .map-type-btn.sub-option {
                margin-left: 0;
                padding: 6px 8px;
                font-size: 0.75rem;
                min-height: 26px;
                font-weight: 500;
            }
            
            .toggle-btn {
                padding: 7px 6px;
                min-height: 28px;
                font-size: 0.85rem;
            }
            
            #locationBtn {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
                bottom: 15px;
                right: 15px;
            }
            

            
            /* 모바일에서 터치 최적화 */
            .menu-group button, .toggle-btn, .map-type-btn {
                min-height: 34px; /* 30% 줄인 높이 */
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
            }
            
            /* 모바일에서 스크롤 최적화 */
            .info-content {
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                scroll-behavior: smooth;
                /* 모바일에서 스크롤 바운스 효과 개선 */
                -webkit-overflow-scrolling: touch;
                /* 터치 스크롤 성능 향상 */
                will-change: scroll-position;
                /* 스크롤 민감도 향상 */
                touch-action: pan-y;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }
        }
        
        @media (max-width: 480px) {
            #customMapMenu {
                width: 160px;
                max-width: 75vw;
                top: 10px;
                left: 8px;
                padding: 10px 8px 8px 8px;
                max-height: calc(100vh - 20px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                scroll-behavior: smooth;
            }
            
            #customMapMenu.hide {
                left: -180px;
            }
            
            #menuToggleBtn, #rightMenuToggleBtn {
                width: 40px;
                height: 40px;
                font-size: 1.2rem;
                top: 10px;
            }
            
            #menuToggleBtn {
                left: 8px;
            }
            
            #rightMenuToggleBtn {
                right: 8px;
            }
            
            #mapTypeSelector {
                top: 10px;
                right: 8px;
            }
            
            .map-type-btn {
                padding: 6px 8px;
                font-size: 0.8rem;
                min-height: 25px;
            }
            
            .map-type-btn.sub-option {
                margin-left: 0;
                padding: 5px 6px;
                font-size: 0.7rem;
                min-height: 23px;
                font-weight: 500;
            }
            
            .toggle-btn {
                padding: 6px 4px;
                min-height: 25px;
                font-size: 0.8rem;
            }
            
            #locationBtn {
                width: 37px;
                height: 37px;
                font-size: 1rem;
                bottom: 10px;
                right: 10px;
            }
            

            
            /* 작은 화면에서 정보창 최적화 */
            #preparationInfo, #routeSaveDialog, #markerSaveDialog {
                width: 95vw;
                max-width: 95vw;
                left: 2.5vw !important;
                transform: none !important;
            }
            

            
        }
        
        /* 터치 최적화를 위한 추가 스타일 */
        * {
            -webkit-touch-callout: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* 스크롤바 숨기기 */
        ::-webkit-scrollbar {
            display: none;
        }
        
        /* 모바일에서 더블탭 줌 방지 및 한 손가락 드래그 최적화 */
        #map {
            touch-action: manipulation;
            user-select: none;
            -webkit-overflow-scrolling: touch;
        }
        
        /* 모바일에서 버튼 터치 최적화 */
        button, .toggle-btn, .map-type-btn {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            cursor: pointer;
        }
        
        /* 모바일에서 입력 필드 최적화 */
        input[type="text"], input[type="url"] {
            appearance: none;
            border-radius: 6px;
            font-size: 16px; /* iOS에서 줌 방지 */
        }
        
        /* 모바일에서 체크박스 최적화 */
        input[type="checkbox"] {
            appearance: none;
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            position: relative;
        }
        
        input[type="checkbox"]:checked {
            background: #1d4ed8;
        }
        
        input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        
        /* 모바일에서 추가 성능 최적화 */
        @media (max-width: 768px) {
            /* 모바일에서 하드웨어 가속 활성화 */
            #map, .info-content, .user-added-item {
                -webkit-transform: translateZ(0);
                -moz-transform: translateZ(0);
                -ms-transform: translateZ(0);
                transform: translateZ(0);
                will-change: transform;
            }
            
            /* 모바일에서 터치 피드백 최적화 */
            button:active, .toggle-btn:active, .map-type-btn:active {
                -webkit-transform: scale(0.95) translateZ(0);
                transform: scale(0.95) translateZ(0);
                transition: transform 0.1s ease;
            }
            
            /* 모바일에서 스크롤 성능 향상 */
            .info-content::-webkit-scrollbar {
                width: 4px;
            }
            
            .info-content::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.1);
                border-radius: 2px;
            }
            
            .info-content::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 2px;
            }
            

            
        }
        
        /* 모바일에서 안전 영역 지원 */
        @supports (padding: max(0px)) {
            @media (max-width: 768px) {
                #customMapMenu {
                    padding-top: max(15px, env(safe-area-inset-top));
                    padding-left: max(10px, env(safe-area-inset-left));
                }
                
                #menuToggleBtn, #rightMenuToggleBtn {
                    top: max(15px, env(safe-area-inset-top));
                }
                
                #menuToggleBtn {
                    left: max(10px, env(safe-area-inset-left));
                }
                
                #rightMenuToggleBtn {
                    right: max(10px, env(safe-area-inset-right));
                }
            }
        }
        
      

        
        /* 사전준비 정보창 스타일 */
        #preparationInfo {
            position: absolute;
            z-index: 15;
            width: 400px;
            max-width: 90vw;
            max-height: 80vh;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            animation: slideIn 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .info-header {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            color: white;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .info-header h3 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        
        .close-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .info-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            /* 모바일 친화적 스크롤 설정 */
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            scroll-behavior: smooth;
            /* 스크롤 민감도 향상 */
            touch-action: pan-y;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .info-section {
            margin-bottom: 12px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
        }
        
        .info-section h4 {
            margin: 0 0 6px 0;
            font-size: 0.77rem;
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .info-section p {
            margin: 4px 0;
            font-size: 0.665rem;
            color: #374151;
            line-height: 1.5;
        }
        
        .info-section ul {
            margin: 4px 0;
            padding-left: 20px;
        }
        
        .info-section li {
            margin: 3px 0;
            font-size: 0.665rem;
            color: #374151;
            line-height: 1.5;
        }
        
        .ticket-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
            width: 100%;
        }
        
        .ticket-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .ticket-btn:active {
            transform: translateY(0);
        }
        
        /* 모바일 최적화 */
        @media (max-width: 768px) {
            #preparationInfo {
                width: 350px;
                left: 50% !important;
                transform: translateX(-50%) !important;
                top: 80px !important;
                max-width: 90vw;
                max-height: 75vh;
                margin: 0 auto;
            }
            
            #routeSaveDialog, #markerSaveDialog {
                width: 350px;
                left: 50% !important;
                transform: translateX(-50%) !important;
                top: 80px !important;
                max-width: 90vw;
                margin: 0 auto;
            }
        }
        
        @media (max-width: 480px) {
            #preparationInfo {
                width: 320px;
                top: 70px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                max-width: 95vw;
                max-height: 70vh;
            }
            
            #routeSaveDialog, #markerSaveDialog {
                width: 320px;
                top: 70px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                max-width: 95vw;
            }
            
            .info-content {
                padding: 16px;
            }
            
            .info-header {
                padding: 14px 16px;
            }
        }
        
        /* 체크리스트 스타일 */
        .checklist-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
            padding: 4px 0;
            border-radius: 8px;
            transition: background-color 0.2s ease;
            position: relative; /* 스와이프 버튼 위치를 위해 추가 */
        }
        
        .checklist-item:hover {
            background-color: rgba(29, 78, 216, 0.05);
        }
        
        .prep-checkbox {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            accent-color: #1d4ed8;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .prep-checkbox:checked {
            background-color: #1d4ed8;
        }
        
        .checklist-item label {
            cursor: default;
            user-select: none;
            flex: 1;
            line-height: 1.4;
            font-size: 0.665rem;
        }
        .checklist-item:last-child {
            margin-bottom: 0;
        }
        
        /* 기존 항목의 item-content 스타일 추가 */
        .checklist-item .item-content {
            display: flex;
            align-items: center;
            width: 100%;
            transition: transform 0.3s ease;
            flex: 1;
        }
        
        /* 사용자 추가 항목 폼 스타일 */
        .add-item-form {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            overflow: hidden;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 6px;
        }
        
        .form-group input {
            padding: 5px 12px;
            border: 1px solid rgba(29, 78, 216, 0.2);
            border-radius: 8px;
            font-size: 0.63rem;
            font-family: inherit;
            background: white;
            transition: border-color 0.2s ease;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #1d4ed8;
            box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.1);
        }
        
        .form-buttons {
            display: flex;
            gap: 8px;
        }
        
                 .add-btn {
             width: 100%;
             padding: 14px 32px;
             border: none;
             border-radius: 12px;
             font-size: 15px;
             font-weight: 500;
             cursor: pointer;
             transition: all 0.2s ease;
             background: rgba(255, 255, 255, 0.12);
             color: #000;
             backdrop-filter: blur(10px);
             min-width: 120px;
         }
         
         .add-btn:hover {
             background: rgba(255, 255, 255, 0.18);
             transform: translateY(-1px);
         }
         
                 .add-btn:active {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(0);
        }
        
        /* 수정 폼 스타일 */
        .edit-item-form {
            position: fixed;
            z-index: 20;
            width: 400px;
            max-width: 90vw;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            box-shadow: 0 12px 32px rgba(0,0,0,0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            animation: slideIn 0.3s ease-out;
        }
        
        .edit-form-header {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            color: white;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .edit-form-header h4 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .edit-form-header .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        
        .edit-form-header .close-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .edit-item-form .form-group {
            padding: 20px;
            margin: 0;
        }
        
        .edit-item-form .form-buttons {
            padding: 0 20px 20px 20px;
            gap: 12px;
        }
        
        .save-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 20px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
        }
        
        .save-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .cancel-btn {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 20px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
        }
        
        .cancel-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.3);
        }
        
        /* 사용자 추가 항목 스타일 (기존 체크리스트와 동일한 스타일) */
        .user-added-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
            padding: 4px 0;
            border-radius: 8px;
            transition: background-color 0.2s ease;
            position: relative;
            overflow: hidden;
            touch-action: pan-y;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .user-added-item:hover {
            background-color: rgba(29, 78, 216, 0.05);
        }
        
        
        
        
        .user-added-item .item-content {
            display: flex;
            align-items: center;
            width: 100%;
            transition: width 0.3s ease, transform 0.3s ease;
            font-size: inherit;
            flex: 1;
        }
        
        
        
        /* 체크리스트 스와이프 버튼 스타일 (새로운 방식) */
        .checklist-swipe-buttons {
            position: absolute;
            right: -100px;
            top: 0;
            height: 100%;
            display: flex;
            align-items: center;
            transition: right 0.3s ease;
            z-index: 1000;
        }
        
        .user-added-item[data-item-type="user"].swiped .checklist-swipe-buttons {
            right: 0;
        }
        
        .user-added-item[data-item-type="user"].swiped .item-content {
            transform: translateX(-100px);
        }
        
        .checklist-swipe-edit-btn,
        .checklist-swipe-delete-btn {
            width: 50px;
            height: 100%;
            max-height: 40px;
            border: none;
            color: #1a1a1a;
            font-size: inherit;
            font-weight: 400;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            background: transparent;
        }
        
        .checklist-swipe-edit-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .checklist-swipe-delete-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* 데스크톱에서 체크리스트 버튼 항상 표시 */
        @media (min-width: 769px) {
            .user-added-item[data-item-type="user"] {
                display: flex !important;
                align-items: center !important;
                justify-content: space-between !important;
                gap: 8px !important;
            }
            
            .user-added-item[data-item-type="user"] .item-content {
                flex: 1 !important;
                transform: none !important;
                width: auto !important;
            }
            
            .checklist-swipe-buttons {
                position: static !important;
                right: auto !important;
                display: flex !important;
                gap: 4px !important;
                opacity: 1 !important;
                pointer-events: auto !important;
            }
            
            .checklist-swipe-edit-btn,
            .checklist-swipe-delete-btn {
                width: auto !important;
                padding: 6px 12px !important;
                border-radius: 6px !important;
                font-size: 0.85rem !important;
                white-space: nowrap !important;
                background: rgba(255, 255, 255, 0.15) !important;
                border: 1px solid rgba(255, 255, 255, 0.3) !important;
            }
            
            .checklist-swipe-edit-btn:hover {
                background: rgba(139, 92, 246, 0.2) !important;
                border-color: #8b5cf6 !important;
                color: #8b5cf6 !important;
            }
            
            .checklist-swipe-delete-btn:hover {
                background: rgba(239, 68, 68, 0.2) !important;
                border-color: #ef4444 !important;
                color: #ef4444 !important;
            }
        }
        
        /* 일정 항목 스와이프 버튼 스타일 (새로운 방식) */
        .schedule-swipe-buttons {
            position: absolute;
            right: -100px;
            top: 0;
            height: 100%;
            display: flex;
            align-items: center;
            transition: right 0.3s ease;
        }
        
        .user-added-item[data-item-type="schedule"].swiped .schedule-swipe-buttons {
            right: 0;
        }
        
        .user-added-item[data-item-type="schedule"].swiped .item-content {
            transform: translateX(-100px);
        }
        
        .schedule-swipe-edit-btn,
        .schedule-swipe-delete-btn {
            width: 50px !important;
            height: 100% !important;
            max-height: 40px !important;
            border: none !important;
            color: #1a1a1a !important;
            font-size: inherit !important;
            font-weight: 400 !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            transition: all 0.2s ease !important;
            background: transparent !important;
        }
        
        .schedule-swipe-edit-btn:hover {
            background: rgba(255, 255, 255, 0.1) !important;
        }
        
        .schedule-swipe-delete-btn:hover {
            background: rgba(255, 255, 255, 0.1) !important;
        }
        
        /* 데스크톱에서 일정 버튼 항상 표시 */
        @media (min-width: 769px) {
            .user-added-item[data-schedule-id] {
                display: flex !important;
                align-items: center !important;
                justify-content: space-between !important;
                gap: 8px !important;
            }
            
            .user-added-item[data-schedule-id] .item-content {
                flex: 1 !important;
                transform: none !important;
                width: auto !important;
            }
            
            .schedule-swipe-buttons {
                position: static !important;
                right: auto !important;
                display: flex !important;
                gap: 4px !important;
                opacity: 1 !important;
                pointer-events: auto !important;
            }
            
            .schedule-swipe-edit-btn,
            .schedule-swipe-delete-btn {
                width: auto !important;
                padding: 6px 12px !important;
                border-radius: 6px !important;
                font-size: 0.85rem !important;
                white-space: nowrap !important;
                background: rgba(255, 255, 255, 0.15) !important;
                border: 1px solid rgba(255, 255, 255, 0.3) !important;
            }
            
            .schedule-swipe-edit-btn:hover {
                background: rgba(139, 92, 246, 0.2) !important;
                border-color: #8b5cf6 !important;
                color: #8b5cf6 !important;
            }
            
            .schedule-swipe-delete-btn:hover {
                background: rgba(239, 68, 68, 0.2) !important;
                border-color: #ef4444 !important;
                color: #ef4444 !important;
            }
        }

        
        /* 새 항목 추가 섹션 스타일 */
        .add-item-section {
            margin-top: 10px;
            text-align: center;
        }
        
        /* 일정창 닫기 버튼 스타일 */
        .schedule-close-btn {
            transition: all 0.2s ease;
        }
        
        .schedule-close-btn:hover {
            background-color: rgba(0, 0, 0, 0.1) !important;
            color: #333 !important;
        }
        
        .schedule-close-btn:active {
            background-color: rgba(0, 0, 0, 0.2) !important;
            transform: translateY(-50%) scale(0.95) !important;
        }
        
        /* 새 항목 추가 폼 스타일 - 이제 edit-form-header 사용 */
        
        /* 통일된 폼 헤더 스타일 */
        .edit-form-header {
            padding: 28px 24px 8px 24px;
            text-align: center;
            position: relative;
            background: transparent;
            color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .edit-form-header h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        .edit-form-header .close-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 20px;
            color: #666;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .edit-form-header .close-btn:hover {
            background-color: rgba(0, 0, 0, 0.1);
            color: #333;
        }
        
        .edit-form-header .close-btn:active {
            background-color: rgba(0, 0, 0, 0.2);
            transform: translateY(-50%) scale(0.95);
        }
        
        .toggle-add-btn {
            background: rgba(255, 255, 255, 0.12);
            color: #000;
            border: none;
            border-radius: 12px;
            padding: 14px 32px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
        }
        
        .toggle-add-btn:hover {
            background: rgba(255, 255, 255, 0.18);
            transform: translateY(-1px);
        }
        
        .toggle-add-btn:active {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(0);
        }
        
        .toggle-add-btn.expanded {
            background: rgba(255, 255, 255, 0.18);
            margin-bottom: 8px;
        }
        
        /* 경로 저장 다이얼로그 스타일 */
        #routeSaveDialog, #markerSaveDialog {
            position: absolute;
            z-index: 15;
            width: 400px;
            max-width: 90vw;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            animation: slideIn 0.3s ease-out;
        }
        
        .route-save-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 16px;
        }
        
        .route-save-btn {
            background: rgba(255, 255, 255, 0.12);
            color: #000;
            border: none;
            border-radius: 12px;
            padding: 14px 32px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            width: 100%;
            min-width: 120px;
        }
        
        .route-save-btn:hover {
            background: rgba(255, 255, 255, 0.18);
            transform: translateY(-1px);
        }
        
        .route-save-btn:active {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(0);
        }
        
        /* 경로제거 버튼 스타일 */
        .route-remove-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }
        
        .route-remove-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        .route-remove-btn:active {
            transform: translateY(0);
        }
        
        /* 비활성화된 제거 버튼 스타일 */
        .route-remove-btn:disabled {
            opacity: 0.3 !important;
            cursor: not-allowed !important;
            pointer-events: none;
        }
        
        .route-remove-btn:disabled:hover {
            transform: none !important;
            box-shadow: none !important;
        }


        
        /* 경로/마커 제거 버튼 컨테이너 스타일 */
        [id$="RemoveButtons"] .route-remove-btn {
            width: auto;
            flex: 1;
            min-width: 0;
            padding: 10px 12px;
            font-size: 0.9rem;
        }
        
        /* InfoWindow 스타일 개선 */
        .gm-style .gm-style-iw-c {
            max-width: none !important;
            border-radius: 20px !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12) !important;
            background: rgba(255, 255, 255, 0.2) !important;
            backdrop-filter: blur(24px) !important;
            -webkit-backdrop-filter: blur(24px) !important;
            border: 1px solid rgba(255, 255, 255, 0.12) !important;
        }
        
        .gm-style .gm-style-iw-d {
            overflow: hidden !important;
        }
        
        /* 모바일에서 InfoWindow 최적화 */
        @media (max-width: 768px) {
            .gm-style .gm-style-iw-c {
                margin: 8px !important;
                max-width: calc(100vw - 40px) !important;
            }
            
            .gm-style .gm-style-iw-d {
                max-height: calc(100vh - 150px) !important;
                overflow-y: auto !important;
            }
        }
        
        /* 모바일에서 버튼 크기 최적화 */
        @media (max-width: 768px) {
            [id$="RemoveButtons"] .route-remove-btn {
                padding: 8px 10px;
                font-size: 0.85rem;
            }
        }
        
        /* 일정 추가 버튼 스타일 */
        #addScheduleBtn {
            background: rgba(255, 255, 255, 0.15) !important;
            color: #1a1a1a !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            font-weight: 600 !important;
            box-shadow: none !important;
            transition: all 0.2s ease !important;
        }
        
        #addScheduleBtn:hover {
            background: rgba(255, 255, 255, 0.4) !important;
            border-color: rgba(255, 255, 255, 0.5) !important;
            color: #000 !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
        }
        
        #addScheduleBtn:active {
            background: rgba(255, 255, 255, 0.3) !important;
            transform: scale(0.98) !important;
        }
        
        
        
        /* 추가된 일정 버튼들 스타일 */
        #additionalDays {
            overflow-y: auto !important; /* 세로 스크롤 허용 */
            overflow-x: hidden !important; /* 가로 스크롤 방지 (스와이프 버튼 숨김을 위해) */
            position: relative !important;
            max-height: 300px; /* 최대 높이 제한 */
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            scroll-behavior: smooth;
            /* 스크롤 민감도 향상 */
            touch-action: pan-y;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* 메뉴 그룹 자체에도 overflow 적용 */
        .menu-group {
            overflow: hidden !important;
        }
        
        #additionalDays .toggle-btn {
            background: rgba(255, 255, 255, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
            margin-bottom: 4px !important;
            position: relative !important;
            overflow: hidden !important;
            cursor: pointer !important;
        }
        
        #additionalDays .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.35) !important;
            border-color: rgba(255, 255, 255, 0.5) !important;
        }
        
        /* 스와이프 힌트 스타일 */
        #additionalDays .toggle-btn::after {
            content: '← 스와이프하여 편집/삭제 →' !important;
            position: absolute !important;
            top: 50% !important;
            right: 8px !important;
            transform: translateY(-50%) !important;
            font-size: 0.7rem !important;
            color: rgba(255, 255, 255, 0.6) !important;
            pointer-events: none !important;
            opacity: 0 !important;
            transition: opacity 0.3s ease !important;
            white-space: nowrap !important;
            font-weight: 500 !important;
        }
        
        #additionalDays .toggle-btn:hover::after {
            opacity: 1 !important;
        }
        
        /* 모바일에서 스와이프 힌트 최적화 */
        @media (max-width: 768px) {
            #additionalDays .toggle-btn::after {
                content: '← 스와이프 →' !important;
                font-size: 0.6rem !important;
                right: 4px !important;
                opacity: 0.8 !important;
            }
            
            #additionalDays .toggle-btn:hover::after {
                opacity: 1 !important;
            }
        }
        

        
        /* 일정 컨텍스트 메뉴 스타일 */
        #scheduleContextMenu button:hover {
            background-color: rgba(29, 78, 216, 0.1) !important;
        }
        
        #scheduleContextMenu button:active {
            background-color: rgba(29, 78, 216, 0.2) !important;
        }
        
        /* 모바일에서 컨텍스트 메뉴 최적화 */
        @media (max-width: 768px) {
            #scheduleContextMenu {
                min-width: 180px !important;
                font-size: 16px !important;
            }
            
            #scheduleContextMenu button {
                padding: 16px 20px !important;
                min-height: 48px !important;
            }
        }

        /* 드래그앤드롭 애니메이션 개선 */
        .user-added-item {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .user-added-item.dragging {
            transform: scale(1.05) rotate(3deg);
            box-shadow: 0 12px 30px rgba(0,0,0,0.25), 0 4px 15px rgba(0,0,0,0.1);
            z-index: 10000;
            border-radius: 12px;
            background-color: #ffffff;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: none;
        }
        
        /* 드래그가 아닐 때는 pointer-events를 복원 */
        .user-added-item:not(.dragging) {
            pointer-events: auto;
        }

        .drag-placeholder {
            background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
            border: 2px dashed #3b82f6;
            border-radius: 12px;
            opacity: 0.8;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            font-size: 14px;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .drag-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
        }

        .drag-placeholder.highlight {
            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
            border-color: #2563eb;
            transform: scale(1.02);
        }

        /* 드래그 중 다른 항목들 애니메이션 */
        .user-added-item:not(.dragging) {
            transition: transform 0.2s ease, margin 0.2s ease;
        }

    </style>
</head>
<body>
    <h1>WMAP</h1>
    <!-- 지도를 표시할 div 요소 -->
    <div id="map"></div>
    <!-- 사이드 패널 토글 버튼 (패널이 숨겨졌을 때만 보임) -->
    <button id="menuToggleBtn" class="show" onclick="showMenu()" title="메뉴 열기">P</button>
    
    <!-- 오른쪽 상단 토글 버튼 -->
    <button id="rightMenuToggleBtn" onclick="toggleRightMenu()" title="지도 타입 메뉴 열기">M</button>
    
    <!-- 오른쪽 상단 지도 타입 선택 버튼 -->
    <div id="mapTypeSelector" class="hide">
        <input type="file" id="kmlFileInput" accept=".kml,.kmz" onchange="loadKmlFile(event)" style="display: none;">
        <button class="map-type-btn" onclick="document.getElementById('kmlFileInput').click()" style="background: rgba(99, 102, 241, 0.15); color: #4f46e5; border: 1px solid rgba(99, 102, 241, 0.3);">
          📂 KML/KMZ 불러오기
        </button>
        <button class="map-type-btn" onclick="showKmlSaveDialog()" id="saveKmlBtn" style="display: none; background: rgba(16, 185, 129, 0.15); color: #059669; border: 1px solid rgba(16, 185, 129, 0.3);">
          📥 Firebase에 저장
        </button>
        <button class="map-type-btn" onclick="clearKmlLayer()" id="clearKmlBtn" style="display: none; background: rgba(239, 68, 68, 0.15); color: #dc2626; border: 1px solid rgba(239, 68, 68, 0.3);">
          🗑️ KML 레이어 제거
        </button>
        <button class="map-type-btn" onclick="toggleMarkerMode()" id="topMarkerBtn">마커생성</button>
        <button class="map-type-btn" onclick="toggleRouteMode()" id="topRouteBtn">경로생성</button>
        <button class="map-type-btn" onclick="toggleRoadmapSubmenu()" id="topRoadmapBtn">+일반</button>
        <div id="roadmapSubmenu" style="display: none; margin-left: 8px;">
            <button class="map-type-btn sub-option" onclick="setMapTypeFromTop('roadmap')" id="topGoogleRoadmapBtn">구글</button>
            <button class="map-type-btn sub-option" onclick="setMapTypeFromTop('브이월드일반')" id="topVworldRoadmapBtn">브이월드</button>
        <button class="map-type-btn sub-option" onclick="toggleHybridLabel()" id="topHybridBtn">라벨</button>
        </div>
        <button class="map-type-btn" onclick="toggleSatelliteSubmenu()" id="topSatelliteBtn">+위성</button>
        <div id="satelliteSubmenu" style="display: none; margin-left: 8px;">
            <button class="map-type-btn sub-option" onclick="setMapTypeFromTop('satellite')" id="topGoogleSatelliteBtn">구글</button>
            <button class="map-type-btn sub-option" onclick="setMapTypeFromTop('브이월드영상')" id="topVworldSatelliteBtn">브이월드</button>
        </div>
    </div>
    
    <!-- GPS 위치 버튼 -->
    <button id="locationBtn" onclick="getCurrentLocation()" title="현재 위치로 이동">📍</button>
    

    
    <!-- 왼쪽 고정형 사이드바 메뉴 -->
    <div id="customMapMenu" class="hide">
      <h2>WMAP</h2>
      <div class="menu-group">
        <input type="text" id="addressInput" placeholder="위치검색" style="width: 90%; margin-bottom: 4px; padding: 8px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; background: rgba(255, 255, 255, 0.1); color: #1a1a1a; font-size: 0.9rem;" onkeydown="if(event.key==='Enter'){searchAddress();}">
      </div>
      <div class="menu-group">
        <div id="additionalDays"></div>
      </div>
      <div class="menu-group">
        <button id="clearRouteBtn" class="toggle-btn" onclick="clearUserRoute()" style="display: none;">경로 초기화</button>
      </div>
      <div class="menu-group">
        <button id="addScheduleBtn" class="toggle-btn" onclick="showAddScheduleDialog()" style="background: linear-gradient(135deg, #10b981, #059669); color: white; border: none;">
          + 현장추가
        </button>
      </div>
    </div>
    


    
    <script>
      // ============================================================================
      // 📦 GLOBAL STATE - 전역 상태 관리
      // ============================================================================
      
      // 🗺️ 지도 관련 전역 변수
      let map;
      let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      let currentLocationMarker = null; // 현재 위치 마커
      let geocoder = null; // 주소 변환용 Geocoder
      let currentInfoWindow = null; // 현재 열린 정보창
      let kmlLayerActive = false; // KML 레이어 활성화 상태
      let kmlFeatures = []; // 현재 로드된 KML features
      
      // 🔍 주소 검색 관련 전역 변수
      let addressMarker = null; // 주소 검색 마커 (기존 호환성용)
      let addressMarkers = []; // 주소 검색 마커들 (여러 마커 지원)
      let addressSearchCandidates = []; // 주소 검색 후보들
      
      // 🛣️ 경로 관련 전역 변수
      let userRouteMarkers = []; // 사용자가 추가한 위치 마커들 (임시)
      let userRoutePath = null; // 사용자 경로 폴리라인
      let userRouteDottedPath = null; // 사용자 경로 점선 효과
      let isRouteMode = false; // 경로 생성 모드
      let savedUserRoutes = []; // Firebase 동기화된 저장된 경로들
      let routeInfoData = {}; // 경로 정보 저장소 { routeId: { content: "", link: "" } }
      
      // 📍 마커 관련 전역 변수
      let isMarkerMode = false; // 마커생성 모드
      let customMarkers = []; // 사용자가 생성한 마커들
      let markerInfoData = {}; // 마커 정보 저장소 { "groupName-index": { title: "", content: "", link: "" } }
      
      // ============================================================================
      // ⚙️ CONFIGURATION - 설정 및 상수
      // ============================================================================
      
      // 상수 정의
      const CONSTANTS = {
        // 타이밍 관련
        DEBOUNCE_DELAY: 300,
        BOUNDS_DEBOUNCE_DELAY: 500,
        RESIZE_DEBOUNCE_DELAY: 300,
        SYNC_INTERVAL: 10 * 60 * 1000, // 10분
        
        // 마커 관련
        MARKER_SCALE: 15,
        MARKER_FONT_SIZE: '14px',
        MARKER_Z_INDEX: 1000,
        
        // 줌 레벨
        MIN_ZOOM: 1,
        MAX_ZOOM: 20,
        DEFAULT_ZOOM: 4,
        MOBILE_ZOOM: 4,
        
        // 터치 관련
        TOUCH_DELAY: 500,
        LONG_PRESS_DELAY: 800,
        SWIPE_THRESHOLD: 10,
        
        // UI 관련
        ANIMATION_DURATION: 300,
        NOTIFICATION_DURATION: 3000
      };
      
      // 🎯 성능 최적화 관련 전역 변수
      let visibleMarkers = new Set();
      let markerVisibilityObserver = null;
      let cachedElements = {};
      
      // ============================================================================
      // 🛠️ UTILITY FUNCTIONS - 유틸리티 함수
      // ============================================================================
      
      // ─────────────────────────────────────────────────────────────────────────
      // DOM 관리 유틸리티
      // ─────────────────────────────────────────────────────────────────────────
      
      // DOM 캐시 관리
      function getElement(id) {
        if (!cachedElements[id]) {
          cachedElements[id] = document.getElementById(id);
        }
        return cachedElements[id];
      }
      
      // 캐시 무효화 함수 (동적 요소 추가 시 사용)
      function invalidateCache(key) {
        if (key) {
          delete cachedElements[key];
        } else {
          cachedElements = {}; // 전체 캐시 클리어
        }
      }
      
      // 다이얼로그/요소 제거 헬퍼
      function removeElement(id) {
        const element = document.getElementById(id);
        if (element) {
          element.remove();
          invalidateCache(id);
        }
      }
      
      // 여러 요소 한 번에 제거
      function removeElements(...ids) {
        ids.forEach(id => removeElement(id));
      }
      
      // ─────────────────────────────────────────────────────────────────────────
      // Firebase 헬퍼 유틸리티
      // ─────────────────────────────────────────────────────────────────────────
      
      // Firebase 문서 업데이트 헬퍼 (중복 코드 제거)
      async function updateFirebaseDoc(data, showSuccess = true, successMessage = '저장 완료') {
        try {
          if (!window.db || !window.firestore) {
            throw new Error('Firebase 연결이 되지 않았습니다.');
          }
          
          const docRef = window.firestore.doc(window.db, 'users', 'currentUser');
          await window.firestore.updateDoc(docRef, {
            ...data,
            lastUpdated: window.firestore.serverTimestamp()
          });
          
          if (showSuccess && typeof onFirebaseUploadSuccess === 'function') {
            onFirebaseUploadSuccess(successMessage);
          }
          
          return true;
        } catch (error) {
          console.error('Firebase 업데이트 실패:', error);
          if (typeof updateSyncStatus === 'function') {
            updateSyncStatus('저장 실패', 'error');
          }
          throw error;
        }
      }
      
      // Firebase 문서 가져오기 헬퍼
      async function getFirebaseDoc() {
        try {
          if (!window.db || !window.firestore) {
            throw new Error('Firebase 연결이 되지 않았습니다.');
          }
          
          const docRef = window.firestore.doc(window.db, 'users', 'currentUser');
          const docSnap = await window.firestore.getDoc(docRef);
          
          return docSnap.exists() ? docSnap.data() : null;
        } catch (error) {
          console.error('Firebase 읽기 실패:', error);
          throw error;
        }
      }
      
      // ─────────────────────────────────────────────────────────────────────────
      // 동기화 상태 관리 헬퍼
      // ─────────────────────────────────────────────────────────────────────────
      
      // 동기화 작업 래퍼 (자동으로 isSyncing 관리)
      async function withSyncStatus(asyncFunction, statusMessage = '처리 중...') {
        if (typeof window.isSyncing !== 'undefined' && window.isSyncing) {
          if (typeof updateSyncStatus === 'function') {
            updateSyncStatus('다른 작업이 진행 중입니다', 'warning');
          }
          return false;
        }
        
        try {
          if (typeof window.isSyncing !== 'undefined') {
            window.isSyncing = true;
          }
          if (typeof updateSyncStatus === 'function') {
            updateSyncStatus(statusMessage, 'info');
          }
          
          await asyncFunction();
          return true;
        } catch (error) {
          console.error('동기화 작업 실패:', error);
          if (typeof updateSyncStatus === 'function') {
            updateSyncStatus('작업 실패', 'error');
          }
          return false;
        } finally {
          if (typeof window.isSyncing !== 'undefined') {
            window.isSyncing = false;
          }
        }
      }
      
      // ─────────────────────────────────────────────────────────────────────────
      // KML/KMZ 파일 처리 유틸리티
      // ─────────────────────────────────────────────────────────────────────────
      
      // KML/KMZ 파일 로드 함수
      async function loadKmlFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // 파일 선택 초기화 (같은 파일 재선택 가능하도록)
        event.target.value = '';
        
        try {
          let kmlText;
          
          // KMZ 파일 처리 (압축 파일)
          if (file.name.toLowerCase().endsWith('.kmz')) {
            if (typeof JSZip === 'undefined') {
              alert('JSZip 라이브러리가 로드되지 않았습니다.');
              return;
            }
            
            const zip = new JSZip();
            const contents = await zip.loadAsync(file);
            
            // doc.kml 또는 .kml 확장자 파일 찾기
            const kmlFile = contents.file('doc.kml') || 
                            Object.values(contents.files).find(f => f.name.endsWith('.kml'));
            
            if (!kmlFile) {
              alert('KMZ 파일에서 KML을 찾을 수 없습니다.');
              return;
            }
            
            kmlText = await kmlFile.async('string');
          } 
          // KML 파일 처리
          else if (file.name.toLowerCase().endsWith('.kml')) {
            kmlText = await new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = e => resolve(e.target.result);
              reader.onerror = reject;
              reader.readAsText(file);
            });
          }
          else {
            alert('KML 또는 KMZ 파일만 선택할 수 있습니다.');
            return;
          }
          
          // KML 파싱 및 표시
          parseAndDisplayKml(kmlText, file.name);
          
        } catch (error) {
          console.error('KML 파일 로드 오류:', error);
          alert('KML/KMZ 파일을 불러오는데 실패했습니다.\n오류: ' + error.message);
        }
      }
      
      // KML 파싱 및 지도 표시 함수
      function parseAndDisplayKml(kmlText, fileName) {
        try {
          // toGeoJSON 라이브러리 체크
          if (typeof toGeoJSON === 'undefined') {
            alert('toGeoJSON 라이브러리가 로드되지 않았습니다.');
            return;
          }
          
          // XML 파싱
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
          
          // 파싱 오류 체크
          const parserError = kmlDoc.getElementsByTagName('parsererror');
          if (parserError.length > 0) {
            throw new Error('KML 파일 파싱 실패: 유효하지 않은 XML 형식');
          }
          
          // KML → GeoJSON 변환
          const geoJson = toGeoJSON.kml(kmlDoc);
          
          if (!geoJson || !geoJson.features || geoJson.features.length === 0) {
            alert('KML 파일에 유효한 데이터가 없습니다.');
            return;
          }
          
          // 기존 KML 레이어 제거
          clearKmlLayer();
          
          // GeoJSON을 구글맵에 추가
          const addedFeatures = map.data.addGeoJson(geoJson);
          kmlFeatures = addedFeatures;
          
          // 스타일 적용
          map.data.setStyle(function(feature) {
            // KML에 정의된 스타일이 있으면 사용
            const strokeColor = feature.getProperty('stroke') || '#FF0000';
            const strokeOpacity = feature.getProperty('stroke-opacity') || 0.8;
            const strokeWeight = feature.getProperty('stroke-width') || 2;
            const fillColor = feature.getProperty('fill') || '#FF6B6B';
            const fillOpacity = feature.getProperty('fill-opacity') || 0.3;
            
            return {
              strokeColor: strokeColor,
              strokeOpacity: parseFloat(strokeOpacity),
              strokeWeight: parseFloat(strokeWeight),
              fillColor: fillColor,
              fillOpacity: parseFloat(fillOpacity),
              clickable: true
            };
          });
          
          // 클릭 이벤트 추가 (정보창 표시)
          map.data.addListener('click', function(event) {
            const feature = event.feature;
            const name = feature.getProperty('name') || '이름 없음';
            const description = feature.getProperty('description') || '';
            
            // 정보창 내용 생성
            let infoContent = `
              <div style="padding: 12px; max-width: 300px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                <div style="font-weight: 700; font-size: 15px; color: #1f2937; margin-bottom: 8px;">
                  ${name}
                </div>
            `;
            
            if (description) {
              infoContent += `
                <div style="font-size: 13px; color: #6b7280; margin-bottom: 8px; line-height: 1.4;">
                  ${description}
                </div>
              `;
            }
            
            infoContent += `</div>`;
            
            // 정보창 생성
            const infoWindow = new google.maps.InfoWindow({
              content: infoContent,
              position: event.latLng,
              maxWidth: isMobile ? 280 : 320
            });
            
            // 기존 정보창 닫기
            if (currentInfoWindow) {
              currentInfoWindow.close();
            }
            
            // 정보창 표시
            infoWindow.open(map);
            currentInfoWindow = infoWindow;
          });
          
          // 지도 범위 자동 조정
          const bounds = new google.maps.LatLngBounds();
          let hasGeometry = false;
          
          map.data.forEach(function(feature) {
            feature.getGeometry().forEachLatLng(function(latlng) {
              bounds.extend(latlng);
              hasGeometry = true;
            });
          });
          
          if (hasGeometry) {
            map.fitBounds(bounds);
            
            // 너무 확대되지 않도록 제한
            google.maps.event.addListenerOnce(map, 'bounds_changed', function() {
              const currentZoom = map.getZoom();
              if (currentZoom > 18) {
                map.setZoom(18);
              }
            });
          }
          
          // 상태 업데이트
          kmlLayerActive = true;
          document.getElementById('clearKmlBtn').style.display = 'block';
          document.getElementById('saveKmlBtn').style.display = 'block';
          
          // 성공 메시지
          const featureCount = geoJson.features.length;
          alert(`✅ ${fileName}\n${featureCount}개의 지형지물을 불러왔습니다.\n\n"📥 Firebase에 저장" 버튼을 눌러 현장에 저장할 수 있습니다.`);
          
        } catch (error) {
          console.error('KML 파싱 오류:', error);
          alert('KML 파일을 표시하는데 실패했습니다.\n오류: ' + error.message);
        }
      }
      
      // KML 레이어 제거 함수
      function clearKmlLayer() {
        if (kmlLayerActive) {
          // 모든 features 제거
          map.data.forEach(function(feature) {
            map.data.remove(feature);
          });
          
          // 상태 초기화
          kmlFeatures = [];
          kmlLayerActive = false;
          document.getElementById('clearKmlBtn').style.display = 'none';
          document.getElementById('saveKmlBtn').style.display = 'none';
          
          // 현재 정보창도 닫기
          if (currentInfoWindow) {
            currentInfoWindow.close();
            currentInfoWindow = null;
          }
        }
      }
      
      // KML 데이터 분석 함수
      function analyzeKmlData() {
        const points = [];
        const lines = [];
        const polygons = [];
        
        map.data.forEach(feature => {
          const geometry = feature.getGeometry();
          const name = feature.getProperty('name') || '이름없음';
          const description = feature.getProperty('description') || '';
          
          // KML 스타일 정보 추출
          const strokeColor = feature.getProperty('stroke') || '#3b82f6';
          const strokeOpacity = feature.getProperty('stroke-opacity') || 0.8;
          const strokeWeight = feature.getProperty('stroke-width') || 2;
          
          // Point (포인트) → 마커로 변환
          if (geometry.getType() === 'Point') {
            const point = geometry.get();
            points.push({
              lat: point.lat(),
              lng: point.lng(),
              title: name,
              description: description
            });
          }
          
          // LineString (라인) → 경로로 변환
          else if (geometry.getType() === 'LineString') {
            const path = [];
            geometry.getArray().forEach(latlng => {
              path.push({
                lat: latlng.lat(),
                lng: latlng.lng()
              });
            });
            lines.push({
              name: name,
              path: path,
              description: description,
              color: strokeColor,
              strokeOpacity: strokeOpacity,
              strokeWeight: strokeWeight
            });
          }
          
          // Polygon (폴리곤) → 경로로 변환 (외곽선)
          else if (geometry.getType() === 'Polygon') {
            const path = [];
            const outerRing = geometry.getAt(0);
            outerRing.getArray().forEach(latlng => {
              path.push({
                lat: latlng.lat(),
                lng: latlng.lng()
              });
            });
            polygons.push({
              name: name,
              path: path,
              description: description,
              isPolygon: true,
              color: strokeColor,
              strokeOpacity: strokeOpacity,
              strokeWeight: strokeWeight
            });
          }
        });
        
        return { points, lines, polygons };
      }
      
      // KML 저장 다이얼로그 표시
      function showKmlSaveDialog() {
        if (!kmlLayerActive) {
          alert('먼저 KML 파일을 불러오세요.');
          return;
        }
        
        // 사이드 패널 닫기
        closeSidePanel();
        
        // KML 데이터 분석
        const { points, lines, polygons } = analyzeKmlData();
        const totalCount = points.length + lines.length + polygons.length;
        
        if (totalCount === 0) {
          alert('저장할 데이터가 없습니다.');
          return;
        }
        
        // 현장 목록 가져오기
        const scheduleItems = getActiveScheduleItems();
        
        if (scheduleItems.length === 0) {
          alert('먼저 현장을 추가해주세요.');
          return;
        }
        
        // 현장 버튼 생성
        let scheduleButtons = '';
        scheduleItems.forEach(item => {
          scheduleButtons += `
            <button class="route-save-btn" 
                    onclick="executeKmlSave('${item.title}')"
                    style="
                      width: 100%;
                      background: rgba(255, 255, 255, 0.12);
                      border: 1px solid rgba(255, 255, 255, 0.2);
                      border-radius: 12px;
                      padding: 14px 18px;
                      margin-bottom: 10px;
                      font-size: 15px;
                      font-weight: 500;
                      color: #000;
                      cursor: pointer;
                      transition: all 0.2s ease;
                      backdrop-filter: blur(10px);
                      text-align: center;
                    "
                    onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'; this.style.transform='translateY(-1px)';"
                    onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'; this.style.transform='translateY(0)';">
              ${item.title}
            </button>
          `;
        });
        
        // 다이얼로그 생성
        const dialogDiv = document.createElement('div');
        dialogDiv.id = 'kmlSaveDialog';
        dialogDiv.innerHTML = `
          <div style="padding: 28px 24px 24px 24px;">
            <div style="text-align: center; margin-bottom: 24px;">
              <h3 style="color: #000; margin: 0 0 12px 0; font-size: 18px; font-weight: 600; letter-spacing: -0.01em;">
                📥 KML 데이터 저장
              </h3>
              <div style="font-size: 14px; color: #666; line-height: 1.6;">
                ${points.length > 0 ? `📍 포인트 ${points.length}개 → 마커<br>` : ''}
                ${lines.length > 0 ? `🛣️ 라인 ${lines.length}개 → 경로<br>` : ''}
                ${polygons.length > 0 ? `🔷 폴리곤 ${polygons.length}개 → 경로<br>` : ''}
              </div>
            </div>
            
            <div style="margin-bottom: 20px; padding: 16px; background: rgba(59, 130, 246, 0.08); border-radius: 12px; border-left: 4px solid #3b82f6;">
              <div style="font-size: 13px; color: #1e40af; font-weight: 500; margin-bottom: 4px;">
                💡 저장 방식
              </div>
              <div style="font-size: 12px; color: #64748b; line-height: 1.5;">
                선택한 현장에 마커와 경로가 추가됩니다.<br>
                저장 후 KML 레이어는 자동으로 제거됩니다.
              </div>
            </div>
            
            <div style="margin-bottom: 16px;">
              <div style="font-size: 14px; font-weight: 500; color: #000; margin-bottom: 12px;">
                저장할 현장 선택:
              </div>
              <div class="route-save-options" style="max-height: 300px; overflow-y: auto;">
                ${scheduleButtons}
              </div>
            </div>
            
            <div style="text-align: center;">
              <button onclick="closeKmlSaveDialog()"
                      style="
                        width: 100%;
                        background: rgba(0, 0, 0, 0.05);
                        border: 1px solid rgba(0, 0, 0, 0.1);
                        border-radius: 12px;
                        padding: 12px 24px;
                        font-size: 14px;
                        color: #666;
                        cursor: pointer;
                        transition: all 0.2s ease;
                      "
                      onmouseover="this.style.background='rgba(0, 0, 0, 0.08)';"
                      onmouseout="this.style.background='rgba(0, 0, 0, 0.05)';">
                취소
              </button>
            </div>
          </div>
        `;
        
        // 다이얼로그를 body에 추가
        document.body.appendChild(dialogDiv);
        
        // 다이얼로그 포커스
        setTimeout(() => {
          const firstButton = dialogDiv.querySelector('.route-save-btn');
          if (firstButton) {
            firstButton.focus();
          }
        }, 100);
      }
      
      // KML 저장 다이얼로그 닫기
      function closeKmlSaveDialog() {
        removeElement('kmlSaveDialog');
      }
      
      // KML 데이터를 Firebase에 저장 실행
      async function executeKmlSave(targetLocation) {
        if (!kmlLayerActive) {
          alert('KML 데이터가 없습니다.');
          return;
        }
        
        // 다이얼로그 닫기
        closeKmlSaveDialog();
        
        try {
          // Firebase에서 현재 데이터 먼저 가져오기 (병합을 위해)
          const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
          const existingData = docSnap.exists() ? docSnap.data() : {};
          const existingRouteInfoData = existingData.routeInfoData || {};
          const existingMarkerInfoData = existingData.markerInfoData || {};
          
          // KML 데이터 분석
          const { points, lines, polygons } = analyzeKmlData();
          
          let savedMarkerCount = 0;
          let savedRouteCount = 0;
          
          // 업데이트할 데이터를 먼저 준비
          const newRouteInfoData = { ...existingRouteInfoData };
          const newMarkerInfoData = { ...existingMarkerInfoData };
          const routesToAdd = [];
          const markersToAdd = [];
          
          // 1. 포인트 → 마커 저장 준비
          if (points.length > 0) {
            const markerData = {
              id: (window.crypto && window.crypto.randomUUID)
                    ? `marker_kml_${window.crypto.randomUUID()}`
                    : `marker_kml_${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
              name: `${targetLocation} KML 마커`,
              location: targetLocation,
              markers: points,
              createdAt: new Date().toISOString()
            };
            
            // 각 포인트에 📍 이모지 설정
            points.forEach((point, index) => {
              const key = `${markerData.id}-${index}`;
              newMarkerInfoData[key] = {
                emoji: '📍',
                title: point.title || '',
                content: point.description || '',
                link: ''
              };
            });
            
            markersToAdd.push(markerData);
            savedMarkerCount = points.length;
          }
          
          // 2. 라인 → 경로 저장 준비
          for (const line of lines) {
            const routeData = {
              id: (window.crypto && window.crypto.randomUUID)
                    ? `route_kml_${window.crypto.randomUUID()}`
                    : `route_kml_${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
              name: line.name || `${targetLocation} KML 경로`,
              location: targetLocation,
              path: line.path,
              createdAt: new Date().toISOString()
            };
            
            // routeInfoData에 KML 스타일 정보 추가 (원본 색상 유지)
            newRouteInfoData[routeData.id] = {
              content: line.description || '',
              link: '',
              color: line.color || '#3b82f6',
              isKmlRoute: true,
              strokeWeight: 2.0,
              strokeOpacity: parseFloat(line.strokeOpacity) || 0.8
            };
            
            routesToAdd.push(routeData);
            savedRouteCount++;
          }
          
          // 3. 폴리곤 → 경로 저장 준비
          for (const polygon of polygons) {
            const routeData = {
              id: (window.crypto && window.crypto.randomUUID)
                    ? `route_kml_${window.crypto.randomUUID()}`
                    : `route_kml_${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
              name: polygon.name || `${targetLocation} KML 영역`,
              location: targetLocation,
              path: polygon.path,
              createdAt: new Date().toISOString()
            };
            
            // routeInfoData에 KML 스타일 정보 추가 (원본 색상 유지)
            newRouteInfoData[routeData.id] = {
              content: polygon.description || '',
              link: '',
              color: polygon.color || '#3b82f6',
              isKmlRoute: true,
              strokeWeight: 2.0,
              strokeOpacity: parseFloat(polygon.strokeOpacity) || 0.8
            };
            
            routesToAdd.push(routeData);
            savedRouteCount++;
          }
          
          // 4. 모든 데이터를 한 번에 Firebase에 저장
          await withSyncStatus(async () => {
            // savedUserRoutes와 savedUserMarkers에 추가
            const updateData = {
              routeInfoData: newRouteInfoData,
              markerInfoData: newMarkerInfoData,
              lastUpdated: window.firestore.serverTimestamp()
            };
            
            // arrayUnion으로 경로와 마커 추가
            if (routesToAdd.length > 0) {
              updateData.savedUserRoutes = window.firestore.arrayUnion(...routesToAdd);
            }
            if (markersToAdd.length > 0) {
              updateData.savedUserMarkers = window.firestore.arrayUnion(...markersToAdd);
            }
            
            await window.firestore.updateDoc(
              window.firestore.doc(window.db, 'users', 'currentUser'),
              updateData
            );
            
            // 전역 변수 업데이트
            window.routeInfoData = newRouteInfoData;
            window.markerInfoData = newMarkerInfoData;
            
            routesToAdd.forEach(route => savedUserRoutes.push(route));
            markersToAdd.forEach(marker => {
              if (!window.savedUserMarkers) {
                window.savedUserMarkers = [];
              }
              window.savedUserMarkers.push(marker);
            });
          }, `KML 데이터 저장 중... (총 ${savedMarkerCount + savedRouteCount}개)`);
          
          console.log('[KML Save] newRouteInfoData:', newRouteInfoData);
          
          // KML 레이어 제거
          clearKmlLayer();
          
          // 저장된 마커와 경로를 지도에 표시
          drawAllSavedMarkers();
          drawAllSavedRoutes();
          
          // 마커/경로 제거 버튼 상태 업데이트
          updateMarkerRemoveButtons();
          updateRouteRemoveButtons();
          
          // 성공 메시지
          const totalSaved = savedMarkerCount + savedRouteCount;
          alert(`✅ Firebase 저장 완료!\n\n${targetLocation}에 추가됨:\n• 마커: ${savedMarkerCount}개\n• 경로: ${savedRouteCount}개\n• 총 ${totalSaved}개`);
          
          // 동기화 상태 표시
          if (typeof updateSyncStatus === 'function') {
            updateSyncStatus(`KML 저장 완료 (${totalSaved}개)`, 'success');
          }
          
        } catch (error) {
          console.error('KML 저장 오류:', error);
          alert('KML 데이터를 저장하는데 실패했습니다.\n오류: ' + error.message);
          
          if (typeof updateSyncStatus === 'function') {
            updateSyncStatus('KML 저장 실패', 'error');
          }
        }
      }
      
      // 마커 가시성 최적화 함수
      function optimizeMarkerVisibility() {
        if (!map) return;
        
        const bounds = map.getBounds();
        if (!bounds) return;
        
        // 현재 지도 범위에 있는 마커들만 표시
        if (window.savedUserMarkers) {
          window.savedUserMarkers.forEach(markerGroup => {
            if (markerGroup.markerElements) {
              markerGroup.markerElements.forEach(marker => {
                if (marker && marker.getPosition) {
                  const isVisible = bounds.contains(marker.getPosition());
                  if (isVisible) {
                    visibleMarkers.add(marker);
                    marker.setVisible(true);
                  } else {
                    visibleMarkers.delete(marker);
                    marker.setVisible(false);
                  }
                }
              });
            }
          });
        }
      }
      
      // 마커 메모리 정리 함수
      function cleanupMarkerMemory(marker) {
        if (marker) {
          // 이벤트 리스너 정리
          if (marker.listenerHandles) {
            marker.listenerHandles.forEach(handle => {
              google.maps.event.removeListener(handle);
            });
            marker.listenerHandles = [];
          }
          
          // 마커 제거
          marker.setMap(null);
          visibleMarkers.delete(marker);
        }
      }
      
      // 에러 처리 강화 함수
      function handleError(error, context = 'Unknown') {
        console.error(`[${context}] Error:`, error);
        
        // 사용자에게 친화적인 에러 메시지 표시
        let userMessage = '오류가 발생했습니다.';
        
        if (error.name === 'NetworkError' || error.message.includes('network')) {
          userMessage = '네트워크 연결을 확인해주세요.';
        } else if (error.name === 'QuotaExceededError') {
          userMessage = '저장 공간이 부족합니다.';
        } else if (error.message.includes('Firebase')) {
          userMessage = '데이터 저장에 실패했습니다.';
        } else if (error.message.includes('Google Maps')) {
          userMessage = '지도 서비스에 문제가 있습니다.';
        }
        
        // 에러 상태 업데이트
        if (typeof updateSyncStatus === 'function') {
          updateSyncStatus(userMessage, 'error');
        }
        
        return userMessage;
      }
      
      // 안전한 함수 실행 래퍼
      function safeExecute(fn, context = 'Unknown', fallback = null) {
        try {
          return fn();
        } catch (error) {
          handleError(error, context);
          return fallback;
        }
      }
      
      // Promise 에러 처리 래퍼
      function safePromise(promise, context = 'Unknown', fallback = null) {
        return promise.catch(error => {
          handleError(error, context);
          return fallback;
        });
      }
      
      // 통합 이벤트 핸들러 (이벤트 위임 패턴)
      function setupEventDelegation() {
        // 문서 레벨에서 이벤트 위임
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('click', handleClick, { passive: false });
      }
      
      // 터치 시작 이벤트 핸들러
      function handleTouchStart(event) {
        const target = event.target;
        
        // 버튼 터치 피드백
        if (target.matches('button, .toggle-btn, .map-type-btn')) {
          target.style.transform = 'scale(0.95)';
          target.style.transition = 'transform 0.1s ease';
        }
        
        // 지도 요소에서 다중 터치 방지
        if (target.closest('#map') && event.touches.length > 1) {
          event.preventDefault();
        }
      }
      
      // 터치 이동 이벤트 핸들러
      function handleTouchMove(event) {
        const target = event.target;
        
        // 지도 요소에서 다중 터치 방지
        if (target.closest('#map') && event.touches.length > 1) {
          event.preventDefault();
        }
      }
      
      // 터치 종료 이벤트 핸들러
      function handleTouchEnd(event) {
        const target = event.target;
        
        // 버튼 터치 피드백 복원
        if (target.matches('button, .toggle-btn, .map-type-btn')) {
          target.style.transform = 'scale(1)';
        }
      }
      
      // 클릭 이벤트 핸들러 (데스크톱용)
      function handleClick(event) {
        const target = event.target;
        
        // 버튼 클릭 피드백
        if (target.matches('button, .toggle-btn, .map-type-btn')) {
          target.style.transform = 'scale(0.95)';
          setTimeout(() => {
            target.style.transform = 'scale(1)';
          }, 100);
        }
      }
      
      // 모바일 최적화 함수
      function optimizeForMobile() {
        if (isMobile) {
          // 이벤트 위임 설정
          setupEventDelegation();
          
          // 지도 요소에 제스처 이벤트 방지
          const mapElement = document.getElementById('map');
          if (mapElement) {
            mapElement.addEventListener('gesturestart', function(event) {
              event.preventDefault();
            }, { passive: false });
            
            mapElement.addEventListener('gesturechange', function(event) {
              event.preventDefault();
            }, { passive: false });
            
            mapElement.addEventListener('gestureend', function(event) {
              event.preventDefault();
            }, { passive: false });
          }
          
          // 모바일에서 스크롤 성능 최적화 - 즉시 반응하는 스크롤
          document.addEventListener('touchstart', function(event) {
            // 스크롤 가능한 영역에서 터치 시작 시 즉시 스크롤 활성화
            if (event.target.closest('.info-content') || event.target.closest('#customMapMenu')) {
              const target = event.target.closest('.info-content') || event.target.closest('#customMapMenu');
              if (target) {
                // 터치 시작 시 즉시 스크롤 준비
                target.style.touchAction = 'pan-y';
                target.style.webkitOverflowScrolling = 'touch';
              }
            }
          }, { passive: true });
          
          document.addEventListener('touchmove', function(event) {
            // 스크롤 가능한 영역에서는 이벤트 방해하지 않음
            if (event.target.closest('.info-content') || event.target.closest('#customMapMenu')) {
              // 스크롤 이벤트는 완전히 자연스럽게 허용
              return;
            }
          }, { passive: true });
          
          // 모바일에서 버튼 터치 피드백 최적화 (일정 항목 스와이프 버튼 제외)
          const buttons = document.querySelectorAll('button, .toggle-btn, .map-type-btn');
          buttons.forEach(button => {
            // 일정 항목의 스와이프 버튼은 터치 애니메이션 제외
            const isScheduleSwipeBtn = button.closest('[data-item-type="schedule"]') && 
                                      (button.classList.contains('schedule-swipe-edit-btn') || button.classList.contains('schedule-swipe-delete-btn'));
            
            if (!isScheduleSwipeBtn) {
              button.addEventListener('touchstart', function() {
                this.style.transform = 'scale(0.95)';
              }, { passive: true });
              
              button.addEventListener('touchend', function() {
                this.style.transform = 'scale(1)';
              }, { passive: true });
            }
          });
        }
      }
      
      // URL 해시에서 맵 뷰(lat,lng,zoom) 복원
      function parseMapViewFromUrl() {
        try {
          const hash = window.location.hash || '';
          if (!hash.startsWith('#')) return null;
          const params = new URLSearchParams(hash.slice(1));
          const lat = parseFloat(params.get('lat'));
          const lng = parseFloat(params.get('lng'));
          const z = parseInt(params.get('z'), 10);
          if (isFinite(lat) && isFinite(lng) && isFinite(z)) {
            return { center: { lat: lat, lng: lng }, zoom: z };
          }
          return null;
        } catch (e) { return null; }
      }
      
      // 현재 맵 뷰를 URL 해시에 저장 (새로고침 시 유지)
      let _lastHashUpdateTs = 0;
      function updateMapViewInUrl(center, zoom) {
        try {
          const now = Date.now();
          if (now - _lastHashUpdateTs < 300) return; // 과도한 업데이트 방지
          _lastHashUpdateTs = now;
          const lat = (center.lat || center.lat()).toFixed(6);
          const lng = (center.lng || center.lng()).toFixed(6);
          const z = zoom;
          const params = new URLSearchParams(window.location.hash.slice(1));
          params.set('lat', lat);
          params.set('lng', lng);
          params.set('z', z);
          const newHash = '#' + params.toString();
          if (newHash !== window.location.hash) {
            history.replaceState(null, '', newHash);
          }
        } catch (e) { /* noop */ }
      }
      
      // ============================================================================
      // 🗺️ MAP MODULE - 지도 초기화 및 관리
      // ============================================================================
      
      // 구글맵 초기화 함수
      function initMap() {
        // 모바일 최적화 적용
        optimizeForMobile();
        
        // 기본 지도 중심 (대한민국 전체)
        let center = { lat: 36.5, lng: 127.5 };
        
        // 대한민국 전체가 보이도록 줌 레벨 조정
        let zoom = isMobile ? 6 : 7;
        
        // URL 해시에서 뷰 복원 (있으면 우선 적용)
        const savedView = parseMapViewFromUrl();
        if (savedView) {
          center = savedView.center;
          zoom = savedView.zoom;
        }
        
        // 지도 스타일 - 전역으로 승격 (라벨 on/off에 공통 사용)
        window.mapStyle = [
          {
            featureType: 'all',
            elementType: 'labels',
            stylers: [{ visibility: 'on' }] // 라벨 표시
          },
          {
            featureType: 'road',
            elementType: 'geometry',
            stylers: [{ visibility: 'simplified' }] // 도로 단순화
          }
        ];
        window.hideLabelsStyle = [
          {
            featureType: 'all',
            elementType: 'labels',
            stylers: [{ visibility: 'off' }]
          },
          {
            featureType: 'all',
            elementType: 'labels.text',
            stylers: [{ visibility: 'off' }]
          },
          {
            featureType: 'all',
            elementType: 'labels.icon',
            stylers: [{ visibility: 'off' }]
          }
        ];
        
        // 구글 맵 객체 생성 및 옵션 설정 - 모바일 최적화
        map = new google.maps.Map(document.getElementById('map'), {
          zoom: zoom,
          center: center,
          mapTypeControl: false,
          mapTypeControlOptions: {
            mapTypeIds: ['roadmap', 'satellite', 'hybrid', '브이월드일반', '브이월드영상'],
            style: google.maps.MapTypeControlStyle.VERTICAL_BAR,
            position: google.maps.ControlPosition.LEFT_TOP
          },
          // 모바일에서 기본 컨트롤들 비활성화
          fullscreenControl: false,
          streetViewControl: false,
          zoomControl: false,
          scaleControl: false,
          rotateControl: false,
          tilt: 0,
          // 모바일에서 한 손가락 드래그 허용
          gestureHandling: 'greedy',
          // 기본: 라벨 숨김
          styles: window.hideLabelsStyle,
          // 모바일 성능 최적화
          disableDefaultUI: true,
          clickableIcons: false,
          // 모바일에서 부드러운 애니메이션
          animation: google.maps.Animation.NONE,
          // 모바일에서 배터리 절약
          backgroundColor: '#f5f5f5',
          // 더블클릭 줌 비활성화 (기본 확대 기능 제거)
          disableDoubleClickZoom: true
        });
        
        // 맵 이동/줌 변경 시 URL에 현재 뷰 저장
        map.addListener('idle', function() {
          try {
            const c = map.getCenter();
            const z = map.getZoom();
            updateMapViewInUrl(c, z);
          } catch (e) {}
        });
        
        geocoder = new google.maps.Geocoder(); // Geocoder 객체 생성
        
        // 브이월드 일반 지도(기본 지도) 타일 레이어 정의
        var vworldRoadmapType = new google.maps.ImageMapType({
          getTileUrl: function(coord, zoom) {
            return 'https://xdworld.vworld.kr/2d/Base/service/' + zoom + '/' + coord.x + '/' + coord.y + '.png';
          },
          tileSize: new google.maps.Size(256, 256),
          name: '브이월드일반',
          maxZoom: 19
        });
        
        // 브이월드 영상 지도(위성 지도) 타일 레이어 정의
        var vworldSatelliteType = new google.maps.ImageMapType({
          getTileUrl: function(coord, zoom) {
            return 'https://xdworld.vworld.kr/2d/Satellite/service/' + zoom + '/' + coord.x + '/' + coord.y + '.jpeg';
          },
          tileSize: new google.maps.Size(256, 256),
          name: '브이월드영상',
          maxZoom: 19
        });
        
        // 사용자 정의 지도 타입(브이월드 일반, 브이월드 영상)을 구글 맵에 추가
        map.mapTypes.set('브이월드일반', vworldRoadmapType);
        map.mapTypes.set('브이월드영상', vworldSatelliteType);
        
        // 커스텀 더블클릭 이벤트 - 1단계 축소 기능
        map.addListener('dblclick', function(event) {
          const currentZoom = map.getZoom();
          // 현재 줌 레벨에서 1단계 축소
          const newZoom = Math.max(currentZoom - 1, CONSTANTS.MIN_ZOOM); // 최소 줌 레벨 제한
          map.setZoom(newZoom);
          
          // 축소된 위치로 중심점 이동 (클릭한 지점을 중심으로)
          map.setCenter(event.latLng);
          
        });
        
        // 두 손가락 더블클릭 감지 변수
        let twoFingerTouchCount = 0;
        let twoFingerTimer = null;
        let lastTwoFingerPosition = null;
        
        // 터치 이벤트 리스너 - 두 손가락 더블클릭 감지
        const mapElement = document.getElementById('map');
        
        mapElement.addEventListener('touchstart', function(event) {
          // 두 손가락 터치 감지
          if (event.touches.length === 2) {
            twoFingerTouchCount++;
            lastTwoFingerPosition = {
              lat: (event.touches[0].clientY + event.touches[1].clientY) / 2,
              lng: (event.touches[0].clientX + event.touches[1].clientX) / 2
            };
            
            // 기존 타이머 클리어
            if (twoFingerTimer) {
              clearTimeout(twoFingerTimer);
            }
            
            // 500ms 후에 터치 카운터 리셋
            twoFingerTimer = setTimeout(function() {
              twoFingerTouchCount = 0;
            }, 500);
            
            // 두 손가락 더블클릭 감지
            if (twoFingerTouchCount === 2) {
              const currentZoom = map.getZoom();
              const newZoom = Math.min(currentZoom + 1, CONSTANTS.MAX_ZOOM); // 최대 줌 레벨 제한
              map.setZoom(newZoom);
              
              // 터치 중심점을 지도 좌표로 변환하여 중심점 이동
              const centerLatLng = map.getCenter();
              map.setCenter(centerLatLng);
              
              twoFingerTouchCount = 0;
            }
          }
        }, { passive: true });
        
        
        // 🔥 지도 롱프레스 기능을 위한 변수들
        let longPressTimer = null;
        let longPressStartLatLng = null;
        let longPressTriggered = false;
        const LONG_PRESS_DURATION = 600; // 600ms 롱프레스
        const LONG_PRESS_MOVE_THRESHOLD = 10; // 10픽셀 이내 이동 허용
        let longPressStartPixel = null;
        
        // 지도 mousedown/touchstart 이벤트 - 롱프레스 시작
        map.addListener('mousedown', function(event) {
          // 모드 활성화 시에는 롱프레스 비활성화
          if (isMarkerMode || isRouteMode) {
            return;
          }
          
          longPressTriggered = false;
          longPressStartLatLng = event.latLng;
          
          // 픽셀 좌표 저장 (이동 감지용)
          const projection = map.getProjection();
          if (projection && longPressStartLatLng) {
            longPressStartPixel = projection.fromLatLngToPoint(longPressStartLatLng);
          }
          
          // 롱프레스 타이머 시작
          longPressTimer = setTimeout(function() {
            longPressTriggered = true;
            
            // 롱프레스 발생 - 해당 위치의 주소 정보 표시
            if (longPressStartLatLng) {
              showLongPressInfoWindow(longPressStartLatLng);
            }
          }, LONG_PRESS_DURATION);
        });
        
        // 지도 mousemove/touchmove 이벤트 - 이동 시 롱프레스 취소
        map.addListener('mousemove', function(event) {
          if (longPressTimer && longPressStartPixel && event.latLng) {
            const projection = map.getProjection();
            if (projection) {
              const currentPixel = projection.fromLatLngToPoint(event.latLng);
              const deltaX = Math.abs(currentPixel.x - longPressStartPixel.x);
              const deltaY = Math.abs(currentPixel.y - longPressStartPixel.y);
              
              // 일정 거리 이상 이동하면 롱프레스 취소
              if (deltaX > LONG_PRESS_MOVE_THRESHOLD || deltaY > LONG_PRESS_MOVE_THRESHOLD) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
              }
            }
          }
        });
        
        // 지도 mouseup/touchend 이벤트 - 롱프레스 타이머 취소
        map.addListener('mouseup', function() {
          if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
          }
        });
        
        // 지도 drag 시작 시 롱프레스 취소
        map.addListener('dragstart', function() {
          if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
          }
        });
        
        // 지도 클릭 시 모든 창들 닫기 기능 - 모바일 최적화
        map.addListener('click', function(event) {
          // 롱프레스였으면 클릭 이벤트 무시
          if (longPressTriggered) {
            longPressTriggered = false;
            return;
          }
          
          // 모바일에서 터치 이벤트 최적화
          if (isMobile && event.placeId) {
            return; // 장소 클릭 시 무시
          }
          
          // 정보창이 열려있으면 우선 정보창 닫기
          if (currentInfoWindow) {
            closeAllDialogsAndMenus();
            return;
          }
          
          // 수정창이 열려있으면 수정창만 닫기 (패널창은 유지)
          const editItemForm = document.getElementById('editItemForm');
          const editScheduleDialog = document.getElementById('editScheduleDialog');
          if (editItemForm || editScheduleDialog) {
            if (editItemForm) {
              editItemForm.remove();
            }
            if (editScheduleDialog) {
              editScheduleDialog.remove();
            }
            return; // 수정창만 닫고 패널창은 유지
          }
          
          // 마커생성 모드일 때는 마커 생성
          if (isMarkerMode) {
            addCustomMarker(event.latLng);
            return;
          }
          
          // 경로 생성 모드일 때는 위치 추가
          if (isRouteMode) {
            addUserRoutePoint(event.latLng);
            return;
          }
          
          // 모든 창들 닫기
          closeAllDialogsAndMenus();
        });
        
        // 🔥 롱프레스 시 정보창 표시 함수
        let longPressMarker = null; // 롱프레스로 생성된 임시 마커
        
        function showLongPressInfoWindow(latLng) {
          if (!latLng || !geocoder) return;
          
          const lat = typeof latLng.lat === 'function' ? latLng.lat() : latLng.lat;
          const lng = typeof latLng.lng === 'function' ? latLng.lng() : latLng.lng;
          
          // 기존 롱프레스 마커 제거
          if (longPressMarker) {
            longPressMarker.setMap(null);
            longPressMarker = null;
          }
          
          // 임시 마커 생성 (파란색 핀으로 구별)
          longPressMarker = new google.maps.Marker({
            position: latLng,
            map: map,
            title: '선택한 위치',
            zIndex: 999,
            icon: {
              url: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png',
              scaledSize: new google.maps.Size(isMobile ? 32 : 36, isMobile ? 32 : 36)
            },
            animation: google.maps.Animation.DROP,
            optimized: false
          });
          
          // Geocoding으로 주소 조회
          geocoder.geocode({ location: latLng }, function(results, status) {
            if (status === 'OK' && results && results[0]) {
              const result = results[0];
              const address = result.formatted_address;
              
              // 정보창 내용 생성
              const infoContent = `
                <div style="padding: 16px; max-width: 320px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                  <div style="font-weight: 700; font-size: 16px; color: #1f2937; margin-bottom: 8px; line-height: 1.4;">
                    📍 선택한 위치
                  </div>
                  <div style="font-size: 14px; color: #6b7280; margin-bottom: 8px; line-height: 1.3;">
                    ${address}
                  </div>
                  <div style="font-size: 12px; color: #9ca3af; margin-bottom: 12px;">
                    위도: ${lat.toFixed(6)}, 경도: ${lng.toFixed(6)}
                  </div>
                  <div style="border-top: 1px solid #e5e7eb; padding-top: 12px; display: flex; gap: 8px;">
                    <button onclick="saveLongPressMarker()" 
                            style="
                              flex: 1;
                              background: rgba(16, 185, 129, 0.12);
                              color: #059669;
                              border: 1px solid rgba(16, 185, 129, 0.3);
                              border-radius: 8px;
                              padding: 10px 16px;
                              font-size: 13px;
                              font-weight: 500;
                              cursor: pointer;
                              transition: all 0.2s ease;
                            "
                            onmouseover="this.style.background='rgba(16, 185, 129, 0.18)';"
                            onmouseout="this.style.background='rgba(16, 185, 129, 0.12)';">
                      마커 저장
                    </button>
                    <button onclick="openInGoogleMaps('${lat}', '${lng}', '선택한 위치', '${encodeURIComponent(address)}')" 
                            style="
                              flex: 1;
                              background: rgba(255, 255, 255, 0.12);
                              color: #000;
                              border: 1px solid rgba(0, 0, 0, 0.1);
                              border-radius: 8px;
                              padding: 10px 16px;
                              font-size: 13px;
                              font-weight: 500;
                              cursor: pointer;
                              transition: all 0.2s ease;
                            "
                            onmouseover="this.style.background='rgba(255, 255, 255, 0.18)';"
                            onmouseout="this.style.background='rgba(255, 255, 255, 0.12)';">
                      상세보기
                    </button>
                  </div>
                </div>
              `;
              
              // 정보창 생성 및 표시
              const infoWindow = new google.maps.InfoWindow({
                content: infoContent,
                disableAutoPan: false,
                maxWidth: isMobile ? 300 : 350
              });
              
              // 정보창 열린 후 X 버튼 제거
              google.maps.event.addListener(infoWindow, 'domready', function() {
                const closeBtn = document.querySelector('.gm-ui-hover-effect');
                if (closeBtn) {
                  closeBtn.style.display = 'none';
                }
              });
              
              // 정보창 표시
              infoWindow.open(map, longPressMarker);
              currentInfoWindow = infoWindow;
              
              // 정보창 닫힐 때 마커도 제거
              google.maps.event.addListener(infoWindow, 'closeclick', function() {
                if (longPressMarker) {
                  longPressMarker.setMap(null);
                  longPressMarker = null;
                }
              });
              
              // 마커 클릭 시 정보창 다시 열기
              longPressMarker.addListener('click', function() {
                infoWindow.open(map, longPressMarker);
                currentInfoWindow = infoWindow;
              });
              
            } else {
              // 주소 조회 실패 시 기본 정보 표시
              const infoContent = `
                <div style="padding: 16px; max-width: 320px;">
                  <div style="font-weight: 700; font-size: 16px; color: #1f2937; margin-bottom: 8px;">
                    📍 선택한 위치
                  </div>
                  <div style="font-size: 12px; color: #9ca3af;">
                    위도: ${lat.toFixed(6)}<br>
                    경도: ${lng.toFixed(6)}
                  </div>
                </div>
              `;
              
              const infoWindow = new google.maps.InfoWindow({
                content: infoContent,
                maxWidth: isMobile ? 300 : 350
              });
              
              infoWindow.open(map, longPressMarker);
              currentInfoWindow = infoWindow;
            }
          });
        }
        
        // 롱프레스로 생성된 마커를 저장하는 함수
        window.saveLongPressMarker = function() {
          if (!longPressMarker) {
            alert('마커를 찾을 수 없습니다.');
            return;
          }
          
          // 롱프레스 마커를 customMarkers 배열에 추가
          // 마커 아이콘을 일반 마커로 변경 (빨간색)
          longPressMarker.setIcon({
            url: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
            scaledSize: new google.maps.Size(isMobile ? 32 : 36, isMobile ? 32 : 36)
          });
          
          // customMarkers 배열에 추가
          customMarkers.push(longPressMarker);
          
          // 정보창 닫기
          if (currentInfoWindow) {
            currentInfoWindow.close();
            currentInfoWindow = null;
          }
          
          // 마커 저장 위치 선택 다이얼로그 열기
          showMarkerSaveDialog();
          
          // 롱프레스 마커 참조 초기화 (이제 customMarkers에서 관리)
          longPressMarker = null;
        };
        
        // 오른쪽 상단 버튼 초기 상태 설정
        updateTopButtonStates('roadmap');
        
        // 줌 레벨 변경 이벤트 리스너 추가 - 모바일 최적화
        let zoomTimeout;
        map.addListener('zoom_changed', function() {
            // 디바운싱으로 성능 최적화
            clearTimeout(zoomTimeout);
            zoomTimeout = setTimeout(function() {
                const currentZoom = map.getZoom();
                toggleMarkerTitleVisibility(currentZoom); // 줌 레벨에 따라 마커 타이틀 표시/숨김
            }, CONSTANTS.DEBOUNCE_DELAY); // 디바운싱 (배터리 절약)
        });
        
        // 지도 이동 이벤트 리스너 추가 - 주소 마커와 현재 위치 마커 자동 제거 (모바일 최적화)
        let boundsTimeout;
        map.addListener('bounds_changed', function() {
            // 디바운싱으로 성능 최적화
            clearTimeout(boundsTimeout);
            boundsTimeout = setTimeout(function() {
                checkAddressMarkerVisibility();
                checkCurrentLocationMarkerVisibility();
                optimizeMarkerVisibility(); // 마커 가시성 최적화
            }, CONSTANTS.BOUNDS_DEBOUNCE_DELAY); // 디바운싱 (배터리 절약)
        });
        
        // 창 크기 조정 시 스와이프 상태 해제, 사이드패널 닫기, 검색 마커 제거
        let resizeTimeout;
        window.addEventListener('resize', function() {
            // 디바운싱으로 성능 최적화
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                clearAllSwipeStates();
                closeSidePanel();
                clearAllAddressMarkers();
            }, CONSTANTS.RESIZE_DEBOUNCE_DELAY); // 디바운싱 (배터리 절약)
        });
        
        // 초기 줌 레벨 표시
        const initialZoom = map.getZoom();
        toggleMarkerTitleVisibility(initialZoom); // 초기 줌 레벨에 따라 마커 타이틀 표시/숨김
        
        // Firebase 초기화 완료 후 동기화 시작
        waitForFirebaseAndStartSync();
        
        // 페이지 로드 시 대기 작업 자동 처리
        if (navigator.onLine) {
          setTimeout(() => {
            processPendingOperations().catch(error => {
              handleError(error, '초기 대기 작업 처리');
            });
          }, 2000); // Firebase 초기화 대기
        }
        
        // 저장된 사용자 경로들 복원
        restoreSavedUserRoutes().then(() => {
          // 경로제거 버튼 상태 업데이트
          updateRouteRemoveButtons();
          // 마커제거 버튼 상태 업데이트
          updateMarkerRemoveButtons();
        });
        
        // 저장된 사용자 마커들 복원
        restoreSavedUserMarkers();
        
        // 저장된 사용자 정의 일정들 복원
        restoreCustomSchedules();
        

        
        // GeoJSON 스타일 설정 - 항로 스타일로 개선
        map.data.setStyle(function(feature) {
          const geometryType = feature.getGeometry().getType();
          
          if (geometryType === 'LineString' || geometryType === 'MultiLineString') {
            // 선형 지오메트리: 항로 스타일 적용
            return {
              strokeColor: '#60a5fa',
              strokeWeight: 1.5,
              strokeOpacity: 0.5,
              fillColor: 'transparent',
              fillOpacity: 0
            };
          } else if (geometryType === 'Point' || geometryType === 'MultiPoint') {
            // 점형 지오메트리: 마커 스타일 적용
            return {
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: '#1d4ed8',
                fillOpacity: 1,
                strokeColor: '#ffffff',
                strokeWeight: 1,
                scale: 6
              }
            };
          } else {
            // 면형 지오메트리: 기본 스타일 적용
            return {
              fillColor: '#1d4ed8',
              fillOpacity: 0.3,
              strokeColor: '#1d4ed8',
              strokeWeight: 1,
              strokeOpacity: 0.6
            };
          }
        });
      }
      
      function setMapType(type) {
        // 지도 타입 설정
        if (map && map.setMapTypeId) {
          map.setMapTypeId(type);
        }
        
        // 지도 타입에 따라 라벨 표시 여부 제어
        if (map && map.setOptions) {
          if (type === 'roadmap') {
            // 일반지도: 기본 라벨 OFF
            map.setOptions({ styles: window.hideLabelsStyle });
          } else if (type === 'satellite') {
            // 위성지도: 기본 라벨
            map.setOptions({ styles: [] });
          } else if (type === 'hybrid') {
            // 하이브리드: 기본 라벨 ON (위성+라벨)
            map.setOptions({ styles: [] });
          }
        }
        
        // 오른쪽 상단 버튼 상태 업데이트
        updateTopButtonStates(type);
      }
      
      // 일반 서브메뉴 토글
      function toggleRoadmapSubmenu() {
        const submenu = document.getElementById('roadmapSubmenu');
        const satelliteSubmenu = document.getElementById('satelliteSubmenu');
        const roadmapBtn = document.getElementById('topRoadmapBtn');
        const satelliteBtn = document.getElementById('topSatelliteBtn');
        
        // 위성 서브메뉴는 닫기
        if (satelliteSubmenu) {
          satelliteSubmenu.style.display = 'none';
        }
        if (satelliteBtn) {
          satelliteBtn.textContent = '+위성';
        }
        
        // 일반 서브메뉴 토글
        if (submenu && roadmapBtn) {
          const isVisible = submenu.style.display !== 'none';
          submenu.style.display = isVisible ? 'none' : 'block';
          roadmapBtn.textContent = isVisible ? '+일반' : '-일반';
        }
      }
      
      // 위성 서브메뉴 토글
      function toggleSatelliteSubmenu() {
        const submenu = document.getElementById('satelliteSubmenu');
        const roadmapSubmenu = document.getElementById('roadmapSubmenu');
        const satelliteBtn = document.getElementById('topSatelliteBtn');
        const roadmapBtn = document.getElementById('topRoadmapBtn');
        
        // 일반 서브메뉴는 닫기
        if (roadmapSubmenu) {
          roadmapSubmenu.style.display = 'none';
        }
        if (roadmapBtn) {
          roadmapBtn.textContent = '+일반';
        }
        
        // 위성 서브메뉴 토글
        if (submenu && satelliteBtn) {
          const isVisible = submenu.style.display !== 'none';
          submenu.style.display = isVisible ? 'none' : 'block';
          satelliteBtn.textContent = isVisible ? '+위성' : '-위성';
        }
      }
      
      // 오른쪽 상단 버튼에서 지도 타입 설정
      function setMapTypeFromTop(type) {
        if (map && map.setMapTypeId) {
          map.setMapTypeId(type);
        }
        
        // 오른쪽 상단 버튼 상태 업데이트
        updateTopButtonStates(type);
        
        // 사이드패널과 동기화
        syncSidePanelWithTop(type);
      }
      
      // 오른쪽 상단 버튼 상태 업데이트
      function updateTopButtonStates(activeType) {
        const topButtons = {
          roadmap: getElement('topRoadmapBtn'),
          satellite: getElement('topSatelliteBtn'),
          hybrid: getElement('topHybridBtn'),
          googleRoadmap: getElement('topGoogleRoadmapBtn'),
          vworldRoadmap: getElement('topVworldRoadmapBtn'),
          googleSatellite: getElement('topGoogleSatelliteBtn'),
          vworldSatellite: getElement('topVworldSatelliteBtn')
        };
        
        // 모든 메인 버튼 비활성화
        [topButtons.roadmap, topButtons.satellite, topButtons.hybrid].forEach(btn => {
          if (btn) btn.classList.remove('active');
        });
        
        // 모든 서브 버튼 비활성화
        [topButtons.googleRoadmap, topButtons.vworldRoadmap, topButtons.googleSatellite, topButtons.vworldSatellite, topButtons.hybrid].forEach(btn => {
          if (btn) btn.classList.remove('active');
        });
        
        // 활성 타입에 따라 버튼 상태 설정
        const activationMap = {
          roadmap: { main: ['roadmap'], sub: ['googleRoadmap'], menuType: 'roadmap' },
          satellite: { main: ['satellite'], sub: ['googleSatellite'], menuType: 'satellite' },
          hybrid: { main: ['roadmap'], sub: ['googleRoadmap', 'hybrid'], menuType: 'roadmap' },
          '브이월드일반': { main: ['roadmap'], sub: ['vworldRoadmap'], menuType: 'roadmap' },
          '브이월드영상': { main: ['satellite'], sub: ['vworldSatellite'], menuType: 'satellite' }
        };
        
        const activation = activationMap[activeType];
        if (activation) {
          // 메인 버튼 활성화
          activation.main?.forEach(btnType => {
          if (topButtons[btnType]) {
            topButtons[btnType].classList.add('active');
          }
        });
        
          // 서브 버튼 활성화
          activation.sub?.forEach(btnType => {
            if (topButtons[btnType]) {
              topButtons[btnType].classList.add('active');
            }
          });
          
          // 서브메뉴 표시 및 버튼 텍스트 업데이트 (초기 로드 시에는 숨김)
          // 초기 로드가 아니라 사용자가 버튼을 클릭해서 지도 타입이 변경된 경우만 서브메뉴 표시
          const roadmapSubmenu = document.getElementById('roadmapSubmenu');
          const satelliteSubmenu = document.getElementById('satelliteSubmenu');
          
          // 버튼 텍스트만 업데이트 (서브메뉴는 토글 함수에서만 제어)
          if (topButtons.roadmap) {
            // 서브메뉴가 이미 열려있으면 텍스트 유지, 아니면 +로 설정
            const isRoadmapOpen = roadmapSubmenu && roadmapSubmenu.style.display === 'block';
            topButtons.roadmap.textContent = isRoadmapOpen ? '-일반' : '+일반';
          }
          if (topButtons.satellite) {
            const isSatelliteOpen = satelliteSubmenu && satelliteSubmenu.style.display === 'block';
            topButtons.satellite.textContent = isSatelliteOpen ? '-위성' : '+위성';
          }
        }
      }
      
      // 사이드패널과 오른쪽 상단 버튼 동기화
      function syncSidePanelWithTop(activeType) {
        const menuConfigs = {
          roadmap: { roadmap: { show: true, text: '-일반' }, satellite: { show: false, text: '+위성' } },
          satellite: { roadmap: { show: false, text: '+일반' }, satellite: { show: true, text: '-위성' } },
          hybrid: { roadmap: { show: false, text: '+일반' }, satellite: { show: true, text: '-위성' } }
        };
        
        const config = menuConfigs[activeType];
        if (!config) return;
        
        Object.entries(config).forEach(([menuType, settings]) => {
          const menu = getElement(`${menuType}Menu`);
          const btn = getElement(`${menuType}ToggleBtn`);
          if (menu && btn) {
            menu.style.display = settings.show ? 'block' : 'none';
            btn.textContent = settings.text;
          }
        });
      }
      
      // 최적화된 메뉴 토글 함수
      function toggleMenu(menuId, btnId, menuName, subMenus = []) {
        const menu = getElement(menuId);
        const btn = getElement(btnId);
        const isHidden = menu.style.display === 'none';
        
        menu.style.display = isHidden ? 'block' : 'none';
        btn.textContent = isHidden ? `-${menuName}` : `+${menuName}`;
        
        if (!isHidden && subMenus.length) {
          subMenus.forEach(({menuId, btnId, btnText}) => {
            getElement(menuId).style.display = 'none';
            getElement(btnId).textContent = btnText;
          });
        }
      }
      
      // 구글맵 메뉴 토글
      function toggleGoogleMapMenu() {
        toggleMenu('googleMapMenu', 'googleMapToggleBtn', '구글맵', [
          {menuId: 'roadmapMenu', btnId: 'roadmapToggleBtn', btnText: '+일반'},
          {menuId: 'satelliteMenu', btnId: 'satelliteToggleBtn', btnText: '+위성'}
        ]);
      }
      
      // +일반 클릭 시 바로 일반지도를 로드하고, 하위 메뉴만 토글
      function toggleRoadmapMenuAndSetRoadmap() {
        const menu = document.getElementById('roadmapMenu');
        const btn = document.getElementById('roadmapToggleBtn');
        if(menu.style.display === 'none') {
          setMapType('roadmap');
          menu.style.display = 'block';
          btn.textContent = '-일반';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+일반';
        }
      }
      
      // +위성 클릭 시 바로 위성지도를 로드하고, 하위에 하이브리드만 보이도록
      function toggleSatelliteMenuAndSetSatellite() {
        const menu = document.getElementById('satelliteMenu');
        const btn = document.getElementById('satelliteToggleBtn');
        if(menu.style.display === 'none') {
          setMapType('satellite');
          menu.style.display = 'block';
          btn.textContent = '-위성';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+위성';
        }
      }

      // 라벨 버튼 토글 함수
      function toggleHybridLabel() {
        const hybridBtn = document.getElementById('topHybridBtn');
        const currentMapType = map.getMapTypeId();
        
        // 기본 OFF 기준으로 토글: active = 라벨 ON
        const willActivate = !hybridBtn.classList.contains('active');
        if (currentMapType === 'roadmap') {
          map.setOptions({ styles: willActivate ? window.mapStyle : window.hideLabelsStyle });
        } else if (currentMapType === 'satellite') {
          setMapType(willActivate ? 'hybrid' : 'satellite');
        } else if (currentMapType === 'hybrid') {
          if (!willActivate) setMapType('satellite');
        }
        hybridBtn.classList.toggle('active', willActivate);
        
        // 사이드패널과 동기화
        syncSidePanelWithTop(currentMapType);
      }
       // 체크박스 상태 저장 함수
       async function saveCheckboxStates() {
         // 동기화 중이면 무시 (무한 루프 방지)
         if (isSyncing) {

           return;
         }
         
         const checkboxes = cachedElements['prep-checkboxes'] || (cachedElements['prep-checkboxes'] = document.querySelectorAll('.prep-checkbox'));
         const states = {};
         checkboxes.forEach(checkbox => {
           states[checkbox.id] = checkbox.checked;
         });
         
         try {
           // 동기화 상태 설정
           isSyncing = true;
           updateSyncStatus('체크박스 저장 중...', 'info');
           
           // Firebase에 저장
           await window.firestore.setDoc(window.firestore.doc(window.db, 'users', 'currentUser'), {
             preparationCheckboxes: states,
             lastUpdated: window.firestore.serverTimestamp()
           }, { merge: true });
           
           // 사용자 추가 항목의 체크박스 상태도 업데이트
           updateUserItemsCheckboxStates();
           

          onFirebaseUploadSuccess('체크박스');
           
         } catch (error) {
           handleError(error, 'Firebase 저장');
           updateSyncStatus('저장 실패', 'error');
           
           // 사용자에게 알림
           setTimeout(() => {
             updateSyncStatus('Firebase 연결 실패', 'error');
           }, 2000);
         } finally {
           // 동기화 상태 해제 (즉시 해제하여 실시간 동기화 허용)
           isSyncing = false;
         }
       }
       
       // 사용자 추가 항목의 체크박스 상태 업데이트 함수 (Firebase 저장 포함)
       async function updateUserItemsCheckboxStates() {
         if (!window.firebaseUserItems) return;
         
         const currentSection = window.currentActiveSection || '';
         let hasChanges = false;
         
         const updatedItems = window.firebaseUserItems.map(item => {
           // 현재 섹션의 항목만 체크박스 상태 업데이트
           if (item.section === currentSection) {
             const checkbox = document.getElementById(item.id);
             if (checkbox && item.checked !== checkbox.checked) {
               item.checked = checkbox.checked;
               hasChanges = true;

             }
           }
           return item;
         });
         
         // 변경사항이 있으면 Firebase에 저장
         if (hasChanges) {
           try {
             await window.firestore.setDoc(window.firestore.doc(window.db, 'users', 'currentUser'), {
               userAddedItems: updatedItems,
               lastUpdated: window.firestore.serverTimestamp()
             }, { merge: true });
             

           } catch (error) {
             handleError(error, '사용자 항목 체크박스 상태 저장');
           }
         }
         
         // 전역 변수 업데이트
         window.firebaseUserItems = updatedItems;
       }
       
      // 체크박스 상태 복원 함수
      async function restoreCheckboxStates() {
        try {
          const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
          if (docSnap.exists()) {
            const data = docSnap.data();
            
            // 체크박스 상태 복원 (현재 섹션의 항목만)
            if (data.preparationCheckboxes) {
              const currentSection = window.currentActiveSection || '';
              Object.keys(data.preparationCheckboxes).forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                  // 현재 섹션의 항목인지 확인
                  const item = window.firebaseUserItems?.find(item => item.id === id);
                  if (item && item.section === currentSection) {
                    checkbox.checked = data.preparationCheckboxes[id];
                  }
                }
              });
            }
            
            // 사용자 추가 항목 복원 - 즉시 표시
            if (data.userAddedItems && data.userAddedItems.length > 0) {
              // 전역 변수에 저장하고 UI 업데이트
              window.firebaseUserItems = data.userAddedItems;
              setTimeout(() => {
                displayUserAddedItemsFromFirebase(data.userAddedItems);
              }, 100);
            } else {
              window.firebaseUserItems = [];
              setTimeout(() => {
                displayUserAddedItemsFromFirebase([]);
              }, 100);
            }
            
            // 경로제거 버튼 상태 업데이트
            updateRouteRemoveButtons();
            // 마커제거 버튼 상태 업데이트
            updateMarkerRemoveButtons();
            

            // 기존 항목 숨김/오버라이드 상태 복원 (없을 경우 기본값)
            window.hiddenExistingItems = data.hiddenExistingItems || [];
            window.existingItemOverrides = data.existingItemOverrides || {};
            if (typeof applyOverridesAndHides === 'function') {
              setTimeout(() => applyOverridesAndHides(), 0);
            }
          } else {
            // Firebase 문서가 존재하지 않는 경우

            
            // UI 초기화
            window.firebaseUserItems = [];
            displayUserAddedItemsFromFirebase([]);
            updateRouteRemoveButtons();
            updateMarkerRemoveButtons();
          }
          
        } catch (error) {
          console.error('Firebase 로드 실패:', error);
          updateSyncStatus('Firebase 로드 실패', 'error');
          
          // UI 초기화 비활성화 - 기존 데이터 보호
          // window.firebaseUserItems = [];
          // displayUserAddedItemsFromFirebase([]);
          // updateRouteRemoveButtons();
          // updateMarkerRemoveButtons();
          

        }
      }
       

      
      // 사전준비 정보창 닫기 함수
      function closePreparationInfo() {
        const infoDiv = document.getElementById('preparationInfo');
        if (infoDiv) {
          infoDiv.remove();
        }
      }
      
      // 모든 창들 닫기 함수
      function closeAllDialogsAndMenus() {
        // 1. 정보창 닫기
        if (currentInfoWindow) {
          currentInfoWindow.close();
          currentInfoWindow = null;
          // 추적 변수 초기화
          window.currentOpenMarkerGroup = null;
          window.currentOpenMarkerIndex = null;
          window.currentOpenRouteId = null;
        }
        
        // 2. 스와이프 상태 해제, 일정창 닫기
        clearAllSwipeStates();
        closeScheduleInfo();
        
        // 마커 정보창 스와이프 상태 초기화
        const markerInfoContainer = document.querySelector('.marker-info-container');
        if (markerInfoContainer) {
          markerInfoContainer.classList.remove('swiped');
          const content = markerInfoContainer.querySelector('.marker-info-content');
          if (content) {
            content.style.width = '100%';
          }
        }
        
        // 경로 정보창 스와이프 상태 초기화
        const routeInfoContainer = document.querySelector('.route-info-container');
        if (routeInfoContainer) {
          routeInfoContainer.classList.remove('swiped');
          const content = routeInfoContainer.querySelector('.route-info-content');
          if (content) {
            content.style.width = '100%';
          }
        }
        
        // 3. 메뉴창들 닫기
        const customMapMenu = getElement('customMapMenu');
        const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
        
        if (!customMapMenu.classList.contains('hide')) {
          hideMenu();
        }
        if (rightPanelOpen) {
          hideRightMenu();
        }
        
        // 4. 사전준비 정보창 닫기
        closePreparationInfo();
        
        // 5. 수정창 닫기
        closeEditForm();
        
        // 6. 다이얼로그들 닫기
        closeRouteSaveDialog();
        closeMarkerSaveDialog();
        closeAddScheduleDialog();
        
        closeEditScheduleDialog();
        closeAddressSelection();
        
        // 7. 기타 다이얼로그들 닫기
        const editItemForm = document.getElementById('editItemForm');
        if (editItemForm) {
          editItemForm.remove();
        }
        
        // 8. 다이얼로그, 컨텍스트 메뉴, 폼들 닫기 (헬퍼 함수 사용)
        removeElements(
          'addScheduleDialog',
          'editScheduleDialog',
          'addressSelectDialog',
          'dialogOverlay',
          'scheduleContextMenu',
          'routeEditDialog',
          'markerEditDialog',
          'addItemForm'
        );
      }
      

      

      


      // 기존 항목 숨김/오버라이드 적용 함수
      function applyOverridesAndHides() {
        try {
          const hidden = Array.isArray(window.hiddenExistingItems) ? window.hiddenExistingItems : [];
          const overrides = window.existingItemOverrides || {};
          

          
          document.querySelectorAll('.checklist-item[data-item-type="existing"]').forEach(el => {
            const id = el.getAttribute('data-item-id');
            // 숨김 적용
            if (hidden.includes(id)) {
              el.style.display = 'none';
              return;
            } else {
              el.style.display = '';
            }
            // 제목/링크 오버라이드 적용
            if (overrides[id]) {
              const span = el.querySelector('.item-content span');
              if (span) {
                const { title, link } = overrides[id];
                if (link) {
                  span.innerHTML = `<span onclick="openUserItemLink('${link}')" style="cursor: pointer;">${title}</span>`;
                } else {
                  span.textContent = title;
                }
                
                // 링크 강조 표시 추가
                if (link) {
                  const linkIndicator = span.querySelector('.link-indicator');
                  if (!linkIndicator) {
                    const indicator = document.createElement('span');
                    indicator.className = 'link-indicator';
                    indicator.textContent = '❗';
                    indicator.setAttribute('aria-hidden', 'true');
                    indicator.style.cssText = [
                      'display:inline-block',
                      'font-size:0.6em',
                      'line-height:1',
                      'vertical-align:super',
                      'margin-left:4px',
                      'position:relative',
                      'top:-0.1em'
                    ].join(';');
                    span.appendChild(indicator);
                  }
                }
              }
            }
          });
          

        } catch (e) {
          console.error('applyOverridesAndHides 실패:', e);
        }
      }
      
      // 사이드 패널 토글 함수
      function hideMenu() {
        getElement('customMapMenu').classList.add('hide');
        getElement('menuToggleBtn').classList.add('show');
      }
      
      function showMenu() {
        // 오른쪽 패널이 열려있다면 먼저 닫기
        if (!getElement('mapTypeSelector').classList.contains('hide')) {
          hideRightMenu();
        }
        getElement('customMapMenu').classList.remove('hide');
        getElement('menuToggleBtn').classList.remove('show');
      }

      // 오른쪽 메뉴 토글 함수
      function toggleRightMenu() {
        const mapTypeSelector = document.getElementById('mapTypeSelector');
        const rightMenuToggleBtn = document.getElementById('rightMenuToggleBtn');
        const isHidden = mapTypeSelector.classList.contains('hide');
        
        if (isHidden) {
          // 메뉴를 보여줄 때
          // 왼쪽 패널이 열려있다면 닫기
          if (!getElement('customMapMenu').classList.contains('hide')) {
            hideMenu();
          }
          mapTypeSelector.classList.remove('hide');
          rightMenuToggleBtn.style.display = 'none'; // 토글 버튼 숨기기
        } else {
          // 메뉴를 숨길 때
          mapTypeSelector.classList.add('hide');
          rightMenuToggleBtn.style.display = 'flex'; // 토글 버튼 보이기
        }
      }
      
      // 오른쪽 메뉴 숨기기 함수
      function hideRightMenu() {
        getElement('mapTypeSelector').classList.add('hide');
        getElement('rightMenuToggleBtn').style.display = 'flex'; // 토글 버튼 보이기
      }
      
      
      
      
      

      
      
      
      // 사용자 추가 항목들 표시 함수
      function displayUserAddedItems() {
        // 이 함수는 하위 호환성을 위해 유지하지만, 
        // 실제로는 displayUserAddedItemsFromFirebase를 호출합니다
        const userItems = window.firebaseUserItems || [];
        displayUserAddedItemsFromFirebase(userItems);
      }
      

      // 모든 스와이프 상태를 해제하는 공통 함수
      function clearAllSwipeStates() {
        
        // 마커 정보창 스와이프 상태 해제
        const markerInfoContainer = document.querySelector('.marker-info-container');
        if (markerInfoContainer) {
          markerInfoContainer.classList.remove('swiped');
          const content = markerInfoContainer.querySelector('.marker-info-content');
          if (content) {
            content.style.width = '100%';
            content.style.transform = 'translateX(0)';
          }
        }
        
        // 모든 사용자 추가 항목의 스와이프 상태 해제 (더 포괄적으로)
        document.querySelectorAll('.user-added-item.swiped').forEach(item => {
          item.classList.remove('swiped');
          const itemContent = item.querySelector('.item-content');
          if (itemContent) {
            itemContent.style.transform = 'translateX(0)';
            itemContent.style.width = '100%';
          }
        });
        
        // 체크리스트 항목 스와이프 상태 해제 (추가 보장)
        document.querySelectorAll('.user-added-item[data-item-type="user"]').forEach(item => {
          item.classList.remove('swiped');
          const itemContent = item.querySelector('.item-content');
          if (itemContent) {
            itemContent.style.transform = 'translateX(0)';
            itemContent.style.width = '100%';
          }
        });
        
        // 일정 항목 스와이프 상태 해제 (추가 보장)
        document.querySelectorAll('.user-added-item[data-item-type="schedule"]').forEach(item => {
          item.classList.remove('swiped');
          const itemContent = item.querySelector('.item-content');
          if (itemContent) {
            itemContent.style.transform = 'translateX(0)';
            itemContent.style.width = '100%';
          }
        });
        
        // 루트 정보창 스와이프 상태 해제
        const routeInfoContainer = document.querySelector('.route-info-container');
        if (routeInfoContainer) {
          routeInfoContainer.classList.remove('swiped');
          const content = routeInfoContainer.querySelector('.route-info-content');
          if (content) {
            content.style.width = '100%';
            content.style.transform = 'translateX(0)';
          }
        }
        
        // 모든 스와이프 관련 클래스 제거 (추가 보장)
        document.querySelectorAll('.swiped, .swiping').forEach(element => {
          element.classList.remove('swiped', 'swiping');
        });
        
      }

      // 스와이프 기능 초기화
      function initializeSwipeFeatures() {
        // 체크리스트 항목에 스와이프 기능 추가
        addSwipeToChecklistItems();
        
        // 일정 항목에 스와이프 기능 추가
        addSwipeToScheduleItems();
      }
      
      // 체크리스트 항목에 스와이프 기능 추가
      function addSwipeToChecklistItems() {
        
        // 체크리스트 항목들만 찾기 (data-item-type="user"인 user-added-item)
        const allChecklistItems = document.querySelectorAll('.user-added-item[data-item-type="user"]');
        
        allChecklistItems.forEach((item, index) => {
          // 이미 스와이프 버튼이 있으면 건너뛰기
          if (item.querySelector('.checklist-swipe-buttons')) {
            return;
          }
          
          const itemId = item.getAttribute('data-item-id');
          if (!itemId) {
            return;
          }
          
          
          // 스와이프 버튼 생성
          const swipeButtons = document.createElement('div');
          swipeButtons.className = 'checklist-swipe-buttons';
          // Firebase 데이터에서 직접 제목과 링크 가져오기
          const firebaseItem = window.firebaseUserItems?.find(firebaseItem => firebaseItem.id === itemId);
          const currentTitle = firebaseItem?.title || '';
          const currentLink = firebaseItem?.link || '';
          
          swipeButtons.innerHTML = `
            <button class="checklist-swipe-edit-btn" onclick="editUserItem('${itemId}', '${currentTitle}', '', '${currentLink}')">수정</button>
            <button class="checklist-swipe-delete-btn" onclick="deleteUserItem('${itemId}')">삭제</button>
          `;
          item.appendChild(swipeButtons);
          
          // 터치 이벤트 추가
          addSwipeTouchEvents(item, 'checklist');
          
        });
        
      }
      
      // 일정 항목에 스와이프 기능 추가
      function addSwipeToScheduleItems() {
        document.querySelectorAll('.user-added-item[data-schedule-id]').forEach(item => {
          // 이미 스와이프 버튼이 있으면 건너뛰기
          if (item.querySelector('.schedule-swipe-buttons')) return;
          
          const scheduleId = item.getAttribute('data-schedule-id');
          if (!scheduleId) return;
          
          // 스와이프 버튼 생성
          const swipeButtons = document.createElement('div');
          swipeButtons.className = 'schedule-swipe-buttons';
          // 현재 제목 가져오기
          const currentTitle = item.getAttribute('data-schedule-title') || '';
          
          swipeButtons.innerHTML = `
            <button class="schedule-swipe-edit-btn" onclick="editSchedule('${scheduleId}', '${currentTitle}')">수정</button>
            <button class="schedule-swipe-delete-btn" onclick="deleteSchedule('${scheduleId}', '${currentTitle}')">삭제</button>
          `;
          item.appendChild(swipeButtons);
          
          // 터치 이벤트 추가
          addSwipeTouchEvents(item, 'schedule');
        });
      }
      
      // 스와이프 터치 이벤트 추가 (롱프레스 드래그앤드롭 포함)
      function addSwipeTouchEvents(item, type) {
        // 데스크톱(768px 이상)에서는 스와이프 기능 비활성화
        if (window.innerWidth > 768) {
          return;
        }
        
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let currentY = 0;
        let hasSwiped = false;
        let startTime = 0;
        let isScrolling = false;
        let isSwiping = false;
        
        item.addEventListener('touchstart', function(e) {
          // 스와이프 버튼을 터치한 경우에는 스와이프 방지
          if (e.target.classList.contains('checklist-swipe-edit-btn') ||
              e.target.classList.contains('checklist-swipe-delete-btn') ||
              e.target.classList.contains('schedule-swipe-edit-btn') ||
              e.target.classList.contains('schedule-swipe-delete-btn')) {
            return;
          }
          
          // 다른 항목의 스와이프 상태 해제 (즉시 실행)
          clearAllSwipeStates();
          
          // 현재 항목의 스와이프 상태도 초기화
          this.classList.remove('swiped', 'swiping');
          const itemContent = this.querySelector('.item-content');
          if (itemContent) {
            itemContent.style.transform = 'translateX(0)';
            itemContent.style.width = '100%';
          }
          
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          startTime = Date.now();
          hasSwiped = false;
          isScrolling = false;
          isSwiping = true;
          this.classList.add('swiping');
          
          // 기존 롱프레스 타이머 취소
          if (currentLongPressTimer) {
            clearTimeout(currentLongPressTimer);
          }
          
          // 현재 드래그 아이템 설정
          currentDragItem = this;
          
          // 롱프레스 타이머 시작 (800ms 후 드래그 모드 활성화)
          currentLongPressTimer = setTimeout(() => {
            
            if (isSwiping && !hasSwiped && currentDragItem === this) {
              // 가상 이벤트 객체 생성 (현재 터치 위치 기준)
              const mockEvent = {
                touches: [{
                  clientX: startX,
                  clientY: startY
                }]
              };
              startDragMode(this, mockEvent);
            }
          }, 800);
        }, { passive: false });
        
        item.addEventListener('touchmove', function(e) {
          if (!isSwiping) return;
          
          currentX = e.touches[0].clientX;
          currentY = e.touches[0].clientY;
          const diffX = startX - currentX;
          const diffY = Math.abs(startY - currentY);
          const diffTime = Date.now() - startTime;
          
          // 드래그 모드일 때
          if (isDraggingGlobal) {
            e.preventDefault();
            handleDragMove(this, e);
            return;
          }
          
          // 롱프레스 타이머 취소 (움직임이 감지되면)
          if (currentLongPressTimer && (Math.abs(diffX) > 10 || diffY > 10)) {
            clearTimeout(currentLongPressTimer);
            currentLongPressTimer = null;
            currentDragItem = null;
          }
          
          // 세로 움직임이 가로보다 크면 스와이프 취소
          if (diffY > Math.abs(diffX) && diffY > 20) {
            clearTimeout(currentLongPressTimer);
            currentLongPressTimer = null;
            currentDragItem = null;
            return;
          }
          
          // 수직 스크롤이 수평 스와이프보다 크면 스와이프 방지
          if (diffY > Math.abs(diffX)) {
            isScrolling = true;
            return;
          }
          
          // 빠른 스와이프 감지 (모바일에서 더 민감하게)
          if (diffX > 30 && diffTime < 500 && diffY < 30) {
            const translateX = Math.min(diffX, 160);
            const itemContent = this.querySelector('.item-content');
            if (itemContent) {
              itemContent.style.transform = `translateX(-${translateX}px)`;
              itemContent.style.width = 'calc(100% - 160px)'; // 버튼 공간 확보
            }
            hasSwiped = true;
          }
          // 왼쪽으로 스와이프 (버튼 표시)
          else if (diffX > 10 && !isScrolling) {
            hasSwiped = true;
            e.preventDefault();
            item.classList.add('swiped');
            const itemContent = item.querySelector('.item-content');
            if (itemContent) {
              itemContent.style.width = 'calc(100% - 160px)'; // 버튼 공간 확보
            }
          }
          // 오른쪽으로 스와이프 (버튼 숨김)
          else if (diffX < -10 && !isScrolling) {
            hasSwiped = true;
            e.preventDefault();
            item.classList.remove('swiped');
            const itemContent = item.querySelector('.item-content');
            if (itemContent) {
              itemContent.style.width = '100%';
              itemContent.style.transform = 'translateX(0)';
            }
          }
        }, { passive: false });
        
        item.addEventListener('touchend', function(e) {
          // 롱프레스 타이머 취소
          if (currentLongPressTimer) {
            clearTimeout(currentLongPressTimer);
            currentLongPressTimer = null;
            currentDragItem = null;
          }
          
          if (!isSwiping) return;
          
          // 드래그 모드 종료
          if (isDraggingGlobal) {
            handleDragEnd(this, e);
            isDraggingGlobal = false;
            isSwiping = false;
            this.classList.remove('swiping');
            return;
          }
          
          isSwiping = false;
          this.classList.remove('swiping');
          
          if (!hasSwiped || isScrolling) return;
          
          const endTime = Date.now();
          const diffTime = endTime - startTime;
          const currentX = e.changedTouches[0].clientX;
          const diffX = startX - currentX;
          
          // 모바일에서 더 민감한 스와이프 감지
          if (hasSwiped && diffX > 30 && diffTime < 1000) {
            // 스와이프 완료 - 수정/삭제 버튼 표시
            this.classList.add('swiped');
            const itemContent = this.querySelector('.item-content');
            if (itemContent) {
              itemContent.style.width = 'calc(100% - 160px)'; // 버튼 공간 확보
            }
          } else {
            // 스와이프 취소 - 원래 위치로 복원
            this.classList.remove('swiped');
            const itemContent = this.querySelector('.item-content');
            if (itemContent) {
              itemContent.style.transform = 'translateX(0)';
              itemContent.style.width = '100%';
            }
          }
        }, { passive: false });
        
        // 클릭 시 스와이프 상태 해제 - 모바일 최적화
        item.addEventListener('click', function(e) {
          // 수정/삭제 버튼 클릭이 아닌 경우에만 스와이프 해제
          if (!e.target.classList.contains('checklist-swipe-edit-btn') &&
              !e.target.classList.contains('checklist-swipe-delete-btn') &&
              !e.target.classList.contains('schedule-swipe-edit-btn') &&
              !e.target.classList.contains('schedule-swipe-delete-btn')) {
            clearAllSwipeStates();
          }
        });
      }

      // 사이드패널을 닫는 함수
      function closeSidePanel() {
        const customMapMenu = document.getElementById('customMapMenu');
        if (customMapMenu && !customMapMenu.classList.contains('hide')) {
          hideMenu();
        }
      }
      
      // 일정창만 닫는 함수
      function closeScheduleInfo() {
        const existingInfo = document.getElementById('preparationInfo');
        if (existingInfo) {
          existingInfo.remove();
        }
        
        // 현재 활성 섹션 초기화 (화면은 그대로 유지)
        window.currentActiveSection = '';
      }
      
      // 전체 지도를 모든 마커와 경로가 보이도록 조정하는 함수
      function resetMapToShowAllItems() {

        
        const bounds = new google.maps.LatLngBounds();
        let hasItems = false;
        
        // 1. 모든 저장된 경로들 포함
        savedUserRoutes.forEach(route => {
          if (route.path && route.path.length > 0) {
            route.path.forEach(point => {
              bounds.extend(new google.maps.LatLng(point.lat, point.lng));
              hasItems = true;
            });
          }
        });
        
        // 2. 모든 저장된 마커들 포함
        (window.savedUserMarkers || []).forEach(markerGroup => {
          if (markerGroup.markers && markerGroup.markers.length > 0) {
            markerGroup.markers.forEach(marker => {
              bounds.extend(new google.maps.LatLng(marker.lat, marker.lng));
              hasItems = true;
            });
          }
        });
        
        // 3. 마커나 경로가 있으면 화면에 맞추기, 없으면 기본 홋카이도 지역으로
        if (hasItems) {

          
          const paddingOptions = {
            top: isMobile ? 80 : 60,
            bottom: isMobile ? 80 : 60,
            left: isMobile ? 40 : 220,  // 사이드메뉴 공간 고려
            right: isMobile ? 40 : 60
          };
          
          map.fitBounds(bounds, paddingOptions);
          
          // 너무 많이 확대되는 것을 방지
          setTimeout(() => {
            const currentZoom = map.getZoom();
            if (currentZoom > 14) {
              map.setZoom(14);
            }
          }, 100);
        } else {

          // 기본 홋카이도 지역으로 설정
          map.setCenter({ lat: 43.2203, lng: 142.8635 });
          map.setZoom(7);
        }
      }
      
      // 사이드패널 터치 이벤트 리스너 추가 (스와이프 상태 해제용)
      function setupSidePanelTouchEvents() {
        const customMapMenu = document.getElementById('customMapMenu');
        if (customMapMenu) {
          customMapMenu.addEventListener('touchstart', function(e) {
            // 스와이프 버튼이나 일정 버튼을 터치한 경우가 아니면 스와이프 상태 해제
            if (!e.target.classList.contains('checklist-swipe-edit-btn') &&
                !e.target.classList.contains('checklist-swipe-delete-btn') &&
                !e.target.classList.contains('schedule-swipe-edit-btn') &&
                !e.target.classList.contains('schedule-swipe-delete-btn') &&
                !e.target.classList.contains('toggle-btn') &&
                !e.target.closest('.user-added-item')) {
              clearAllSwipeStates();
            }
          });
          
          // 모바일에서 사이드 패널 스크롤 최적화
          if (isMobile) {
            customMapMenu.addEventListener('touchstart', function(e) {
              // 터치 시작 시 즉시 스크롤 활성화
              this.style.touchAction = 'pan-y';
              this.style.webkitOverflowScrolling = 'touch';
            }, { passive: true });
            
            customMapMenu.addEventListener('touchmove', function(e) {
              // 스크롤 중 부드러운 애니메이션 비활성화
              this.style.scrollBehavior = 'auto';
            }, { passive: true });
            
            customMapMenu.addEventListener('touchend', function(e) {
              // 터치 종료 시 부드러운 스크롤 복원
              setTimeout(() => {
                this.style.scrollBehavior = 'smooth';
              }, 100);
            }, { passive: true });
          }
        }
      }
      
      // 사용자 추가 항목 삭제 함수
      async function deleteUserItem(itemId) {
        if (!confirm('이 항목을 삭제하시겠습니까?')) {
          return;
        }
        
        // 스와이프 상태 해제
        const item = document.querySelector(`[data-item-id="${itemId}"]`);
        if (item) {
          item.classList.remove('swiped');
          const itemContent = item.querySelector('.item-content');
          if (itemContent) {
            itemContent.style.width = '100%';
          }
        }
        
        // 헬퍼 함수를 사용한 간결한 삭제 (기능 동일)
        const success = await withSyncStatus(async () => {
          // 현재 Firebase 항목들에서 해당 항목 제거
          const currentItems = window.firebaseUserItems || [];
          const currentSection = window.currentActiveSection || '';
          
          // 현재 섹션의 항목인지 확인
          const itemToDelete = currentItems.find(item => item.id === itemId);
          if (!itemToDelete || itemToDelete.section !== currentSection) {
            updateSyncStatus('해당 섹션의 항목이 아닙니다', 'error');
            return;
          }
          
          const updatedUserItems = currentItems.filter(item => item.id !== itemId);
          
          // Firebase에서 항목 제거
          await updateFirebaseDoc(
            { userAddedItems: updatedUserItems },
            false
          );
          
          // Firebase에서 해당 항목의 체크박스 상태도 제거
          const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
          if (docSnap.exists() && docSnap.data().preparationCheckboxes) {
            const currentCheckboxStates = { ...docSnap.data().preparationCheckboxes };
            delete currentCheckboxStates[itemId];
            await window.firestore.updateDoc(window.firestore.doc(window.db, 'users', 'currentUser'), {
              preparationCheckboxes: currentCheckboxStates,
              lastUpdated: window.firestore.serverTimestamp()
            });
          }
          
          // 전역 변수 업데이트
          window.firebaseUserItems = updatedUserItems;
          
          // 화면에서 항목 제거
          displayUserAddedItemsFromFirebase(updatedUserItems);
          
          // 경로제거/마커제거 버튼 상태 업데이트
          updateRouteRemoveButtons();
          
          onFirebaseUploadSuccess('항목 삭제');
        }, '항목 삭제 중...');
        
        // 에러 발생 시 처리
        if (!success) {
           // Firebase 실패 시 UI만 업데이트
           const currentItems = window.firebaseUserItems || [];
           const currentSection = window.currentActiveSection || '';
           
           const itemToDelete = currentItems.find(item => item.id === itemId);
           if (itemToDelete && itemToDelete.section === currentSection) {
             const updatedUserItems = currentItems.filter(item => item.id !== itemId);
             window.firebaseUserItems = updatedUserItems;
             displayUserAddedItemsFromFirebase(updatedUserItems);
           }
           
           updateRouteRemoveButtons();
         }
      }
      
             // 사용자 항목 수정 함수
      function editUserItem(itemId, currentTitle, currentDescription, currentLink) {
        // 모든 스와이프 상태 해제
        clearAllSwipeStates();
        
        // 수정 폼 표시
        showEditForm(itemId, currentTitle, currentDescription, currentLink, 'user');
      }
      
      // 기존 항목 수정 함수
      function editExistingItem(itemId, currentTitle, currentDescription, currentLink) {
        // 수정 폼 표시
        showEditForm(itemId, currentTitle, currentDescription, currentLink, 'existing');
      }
      
      // 기존 항목 삭제 함수
      function deleteExistingItem(itemId) {
        if (!confirm('이 항목을 삭제하시겠습니까?')) {
          return;
        }
        
        // 체크박스 상태 제거
        const checkbox = document.getElementById(itemId);
        if (checkbox) {
          checkbox.remove();
        }
        
        // 항목 제거
        const itemElement = cachedElements[`item_${itemId}`] || document.querySelector(`[data-item-id="${itemId}"]`);
        if (itemElement) {
          itemElement.remove();
        }
        
        // 숨김 목록에 반영 및 Firebase 저장
        (async () => {
          try {
            window.hiddenExistingItems = Array.isArray(window.hiddenExistingItems) ? window.hiddenExistingItems : [];
            if (!window.hiddenExistingItems.includes(itemId)) {
              window.hiddenExistingItems.push(itemId);
            }
            // 즉시 UI 반영
            if (typeof applyOverridesAndHides === 'function') {
              applyOverridesAndHides();
            }
            // 체크박스 상태도 동기 저장
            saveCheckboxStates();
            // Firebase 저장
            await window.firestore.setDoc(
              window.firestore.doc(window.db, 'users', 'currentUser'),
              { hiddenExistingItems: window.firestore.arrayUnion(itemId), lastUpdated: window.firestore.serverTimestamp() },
              { merge: true }
            );
            updateSyncStatus('항목이 삭제되었습니다', 'success');
          } catch (e) {
            console.error('항목 삭제 동기화 실패:', e);
            updateSyncStatus('삭제는 로컬에만 반영됨', 'warning');
          }
        })();
      }
      
      // 수정 폼 표시 함수 - 일정 수정 다이얼로그 스타일 적용
      function showEditForm(itemId, currentTitle, currentDescription, currentLink, itemType) {
        // 기존 수정 폼이 있으면 제거
        const existingForm = document.getElementById('editItemForm');
        if (existingForm) {
          existingForm.remove();
        }
        
        // 수정 폼 생성 - 일정 수정 다이얼로그와 동일한 스타일
        const editForm = document.createElement('div');
        editForm.id = 'editItemForm';
        editForm.style.cssText = `
          position: fixed;
          top: 120px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
          width: 400px;
          max-width: 90vw;
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.12);
          border-radius: 20px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.12);
          backdrop-filter: blur(24px);
          -webkit-backdrop-filter: blur(24px);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          overflow: hidden;
        `;
        
        editForm.innerHTML = `
          <div class="edit-form-header">
            <h4>항목 수정</h4>
            <button type="button" onclick="closeEditForm()" class="close-btn">×</button>
          </div>
          <div style="padding: 20px 24px 24px 24px;">
            <div style="margin-bottom: 16px;">
              <input type="text" id="editItemTitle" placeholder="항목 제목을 입력하세요" maxlength="50" value="${currentTitle}"
                     style="width: 100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px);" 
                     onfocus="this.style.background='rgba(255, 255, 255, 0.18)'"
                     onblur="this.style.background='rgba(255, 255, 255, 0.12)'">
            </div>
            <div style="margin-bottom: 24px;">
              <input type="url" id="editItemLink" placeholder="링크를 입력하세요 (선택사항)" maxlength="200" value="${currentLink}"
                     style="width: 100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px);" 
                     onfocus="this.style.background='rgba(255, 255, 255, 0.18)'"
                     onblur="this.style.background='rgba(255, 255, 255, 0.12)'">
            </div>
            <div style="display: flex; gap: 12px;">
              <button onclick="saveEditedItem('${itemId}', '${itemType}')" style="width: 100%; background: rgba(255, 255, 255, 0.12); color: #000; border: none; border-radius: 12px; padding: 14px 16px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'">
                저장
              </button>
            </div>
          </div>
        `;
        
        // 폼을 화면에 추가
        document.body.appendChild(editForm);
        
        // 제목 입력란에 포커스
        setTimeout(() => {
          document.getElementById('editItemTitle').focus();
        }, 100);
      }
      
      // 수정 폼 닫기 함수
      function closeEditForm() {
        removeElement('editItemForm');
      }
      
      // 수정된 항목 저장 함수
      async function saveEditedItem(itemId, itemType) {
        const titleInput = document.getElementById('editItemTitle');
        const linkInput = document.getElementById('editItemLink');
        
        const title = titleInput.value.trim();
        const link = linkInput.value.trim();
        
        if (!title) {
          updateSyncStatus('항목 제목을 입력해주세요', 'error');
          titleInput.focus();
          return;
        }
        
        if (itemType === 'user') {
          // 사용자 추가 항목 수정
          await updateUserItem(itemId, title, link);
        } else {
          // 기존 항목 수정: 오버라이드 저장
          await updateExistingItem(itemId, title, link);
          // 오버라이드 정보 Firebase 저장 및 즉시 적용
          try {
            window.existingItemOverrides = window.existingItemOverrides || {};
            window.existingItemOverrides[itemId] = { title, link };
            if (typeof applyOverridesAndHides === 'function') {
              applyOverridesAndHides();
            }
            await window.firestore.setDoc(
              window.firestore.doc(window.db, 'users', 'currentUser'),
              { existingItemOverrides: { [itemId]: { title, link } }, lastUpdated: window.firestore.serverTimestamp() },
              { merge: true }
            );
            
            // 실시간 동기화를 위한 강제 업데이트 트리거

            onFirebaseUploadSuccess('세부항목 수정');
          } catch (e) {
            console.error('오버라이드 저장 실패:', e);
          }
        }
        
        // 수정 폼 닫기
        closeEditForm();
      }
      
      // 사용자 항목 업데이트 함수 (헬퍼 함수 사용)
      async function updateUserItem(itemId, title, link) {
        await withSyncStatus(async () => {
          // 현재 항목 찾기
          const currentItems = window.firebaseUserItems || [];
          const currentSection = window.currentActiveSection || '';
          const itemIndex = currentItems.findIndex(item => item.id === itemId);
          
          if (itemIndex === -1) {
            updateSyncStatus('항목을 찾을 수 없습니다', 'error');
            return;
          }
          
          // 현재 섹션의 항목인지 확인
          if (currentItems[itemIndex].section !== currentSection) {
            updateSyncStatus('해당 섹션의 항목이 아닙니다', 'error');
            return;
          }
          
          // 항목 업데이트 (기존 속성 모두 유지)
          const updatedItem = {
            ...currentItems[itemIndex],
            title: title,
            link: link || null,
            timestamp: new Date().toISOString(),
            section: currentItems[itemIndex].section, // 섹션 정보 유지
            order: currentItems[itemIndex].order || 0, // 순서 정보 유지
            checked: currentItems[itemIndex].checked || false // 체크 상태 유지
          };
          
          currentItems[itemIndex] = updatedItem;
          
          // Firebase에 저장
          await updateFirebaseDoc(
            { userAddedItems: currentItems },
            true,
            '항목 수정'
          );
          
          // 전역 변수 업데이트
          window.firebaseUserItems = currentItems;
          
          // UI 업데이트
          displayUserAddedItemsFromFirebase(currentItems);
        }, '항목 수정 중...');
      }
      
      // 기존 항목 업데이트 함수 (헬퍼 함수 사용)
      async function updateExistingItem(itemId, title, link) {
        await withSyncStatus(async () => {
          // HTML 요소 업데이트
          const itemElement = cachedElements[`item_${itemId}`] || document.querySelector(`[data-item-id="${itemId}"]`);
          if (itemElement) {
            const titleSpan = itemElement.querySelector('span');
            if (titleSpan) {
              titleSpan.innerHTML = `${title} - ${link || ''}`;
            }
          }
          
          // Firebase에 저장 (기존 항목은 체크박스 상태만 저장)
          await saveCheckboxStates();
          
          // 오버라이드 로컬 상태 업데이트 (화면 재오픈 시 반영)
          window.existingItemOverrides = window.existingItemOverrides || {};
          window.existingItemOverrides[itemId] = { title, link };
          
          // 즉시 UI에 반영
          if (typeof applyOverridesAndHides === 'function') {
            applyOverridesAndHides();
          }
          
          onFirebaseUploadSuccess('기존 항목 수정');
        }, '항목 수정 중...');
      }
      
      // 사용자 항목 링크 열기 함수 (현재 탭에서 열기)
       function openUserItemLink(link) {
         if (!link) return;
         
         try {
           // 현재 탭에서 링크 열기 (뒤로가기로 돌아올 수 있음)
           window.location.href = link;
         } catch (error) {
           console.error('링크 열기 실패:', error);
           alert('링크를 열 수 없습니다. 직접 링크를 복사하여 사용해주세요: ' + link);
         }
       }
      
      // ============================================================================
      // 📍 LOCATION & ADDRESS MODULE - 위치 및 주소 검색
      // ============================================================================
      
      // 현재 위치 가져오기 함수 - 모바일 최적화
      function getCurrentLocation() {
        const locationBtn = document.getElementById('locationBtn');
        const isLoading = locationBtn.classList.contains('loading');

        if (isLoading) {
          alert('현재 위치를 가져오는 중입니다.');
          return;
        }

        // 기존 마커가 있으면 먼저 제거
        if (currentLocationMarker) {
          // 열린 정보창 닫기
          if (currentInfoWindow) {
            currentInfoWindow.close();
            currentInfoWindow = null;
          }
          currentLocationMarker.setMap(null);
          currentLocationMarker = null;
        }

        locationBtn.classList.add('loading');
        locationBtn.textContent = '로딩중...';

        if (navigator.geolocation) {
          // 모바일에서 위치 정확도 최적화
          const options = {
            enableHighAccuracy: isMobile ? false : true, // 모바일에서는 배터리 절약
            timeout: isMobile ? 10000 : 5000, // 모바일에서는 더 긴 타임아웃
            maximumAge: isMobile ? 60000 : 0 // 모바일에서는 1분간 캐시된 위치 허용
          };
          
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              const currentLocation = { lat: lat, lng: lng };
              
              // 현재 위치 중심으로 확대
              const currentZoom = map.getZoom();
              map.setCenter(currentLocation);
              map.setZoom(Math.max(currentZoom, 15)); // 최소 줌 레벨 15로 확대

              // 새로운 현재 위치 마커 추가 - 모바일 최적화
              currentLocationMarker = new google.maps.Marker({
                position: currentLocation,
                map: map,
                icon: {
                  url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32">
                      <text x="12" y="20" font-family="Arial, sans-serif" font-size="24" text-anchor="middle" fill="#FF0000">📍</text>
                    </svg>
                  `),
                  scaledSize: new google.maps.Size(isMobile ? 28 : 32, isMobile ? 28 : 32),
                  anchor: new google.maps.Point(isMobile ? 14 : 16, isMobile ? 14 : 16)
                },
                title: '현재 위치',
                zIndex: 1000, // 다른 마커보다 위에 표시
                optimized: isMobile ? false : true // 모바일에서는 최적화 비활성화로 성능 향상
              });

              // 현재 위치 마커 클릭 시 정보창 표시 및 줌 레벨 15로 조정
              currentLocationMarker.addListener('click', function() {
                // 메뉴창 닫기
                const customMapMenu = getElement('customMapMenu');
                const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
                
                if (!customMapMenu.classList.contains('hide')) {
                  hideMenu();
                }
                if (rightPanelOpen) {
                  hideRightMenu();
                }
                
                try {
                  map.setZoom(15);
                  map.panTo(currentLocation);
                } catch (_) {}
              });

              locationBtn.classList.remove('loading');
              locationBtn.textContent = '📍';
            },
            (error) => {
              console.error('위치 정보를 가져올 수 없습니다:', error.message);
              let errorMessage = '위치 정보를 가져올 수 없습니다.';
              
              // 모바일에서 더 자세한 오류 메시지
              if (isMobile) {
                switch(error.code) {
                  case error.PERMISSION_DENIED:
                    errorMessage = '위치 접근 권한이 거부되었습니다. 브라우저 설정에서 위치 권한을 허용해주세요.';
                    break;
                  case error.POSITION_UNAVAILABLE:
                    errorMessage = '위치 정보를 사용할 수 없습니다. 네트워크 연결을 확인해주세요.';
                    break;
                  case error.TIMEOUT:
                    errorMessage = '위치 정보 요청 시간이 초과되었습니다. 다시 시도해주세요.';
                    break;
                }
              }
              
              alert(errorMessage);
              locationBtn.classList.remove('loading');
              locationBtn.textContent = '📍';
            },
            options
          );
        } else {
          alert('이 브라우저는 위치 정보를 지원하지 않습니다.');
          locationBtn.classList.remove('loading');
          locationBtn.textContent = '📍';
        }
      }
      
      

      

      

      
              
        

      

      

      // 페이지 로드 시 모바일 최적화 및 동기화 상태 확인
      document.addEventListener('DOMContentLoaded', function() {
        optimizeForMobile();
        
        // 동기화 상태 초기화
        initializeSyncSystem();
        
        
        
        // 새로운 스와이프 기능 초기화
        initializeSwipeFeatures();
        
        // 모바일에서 추가 최적화
        if (isMobile) {
          // 모바일에서 메타 태그 동적 설정
          const viewport = document.querySelector('meta[name="viewport"]');
          if (viewport) {
            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
          }
          
          // 모바일에서 터치 이벤트 최적화 (이미 optimizeForMobile에서 처리됨)
          
          // 모바일에서 스크롤 성능 최적화
          document.body.style.webkitOverflowScrolling = 'touch';
          
          // 모바일에서 터치 지연 제거
          document.body.style.touchAction = 'manipulation';
          
          // 모바일에서 배터리 절약을 위한 애니메이션 최적화
          if ('IntersectionObserver' in window) {
            // 뷰포트 밖의 애니메이션은 일시정지 (모바일 배터리 절약)
            const observer = new IntersectionObserver((entries) => {
              entries.forEach(entry => {
                if (!entry.isIntersecting && entry.target.style.transform) {
                  entry.target.style.willChange = 'auto';
                } else {
                  entry.target.style.willChange = 'transform';
                }
              });
            });
            
            // 변환 요소들 관찰
            document.querySelectorAll('[style*="transform"]').forEach(el => {
              observer.observe(el);
            });
          }
        }
        
        // 모바일 최적화 적용 완료
      });
      
      // 동기화 시스템 초기화
      function initializeSyncSystem() {
        // 네트워크 상태 모니터링 (통합)
        window.addEventListener('online', function() {

          updateSyncStatus('네트워크 연결됨', 'success');
          
          // Firebase 동기화 재설정
          if (window.unsubscribeFirebase) {
            window.unsubscribeFirebase();
          }
          setTimeout(() => {
            setupFirebaseSync();
            // 온라인 전환 시 대기 작업 자동 처리
            processPendingOperations().catch(error => {
              console.error('온라인 전환 시 대기 작업 처리 실패:', error);
            });
          }, 1000);
        });
        
        window.addEventListener('offline', function() {

          updateSyncStatus('오프라인 모드', 'warning');
          enableOfflineMode();
        });
        
        // 페이지 가시성 변경 시 동기화 상태 확인
        document.addEventListener('visibilitychange', function() {
          if (!document.hidden && navigator.onLine) {

            updateSyncStatus('동기화 상태 확인 중...', 'info');
            
            // Firebase 연결 상태 확인
            setTimeout(() => {
              if (window.db) {
                updateSyncStatus('동기화 연결됨', 'success');
                
                // 페이지 복귀 시 대기 작업 자동 처리
                processPendingOperations().catch(error => {
                  console.error('가시성 변경 시 대기 작업 처리 실패:', error);
                });
              } else {
                updateSyncStatus('동기화 연결 실패', 'error');
              }
            }, 1000);
          }
        });
        
        // 주기적 동기화 상태 확인 (5분마다)
        setInterval(() => {
          if (navigator.onLine && window.db && !isSyncing) {

            updateSyncStatus('동기화 상태 확인 중...', 'info');
            
            // 간단한 연결 테스트
            window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'))
              .then(() => {
                updateSyncStatus('동기화 정상', 'success');
                
                // 주기적 동기화 시 대기 작업 자동 처리
                processPendingOperations().catch(error => {
                  console.error('대기 작업 처리 실패:', error);
                });
              })
              .catch(() => {
                updateSyncStatus('동기화 연결 실패', 'error');
                enableOfflineMode();
              });
          }
        }, CONSTANTS.SYNC_INTERVAL); // 배터리 절약
      }
      
      // ============================================================================
      // 🎯 MARKER MODULE - 마커 생성 및 관리
      // ============================================================================
      
      // 마커생성 모드 토글 함수
      function toggleMarkerMode() {

        
        if (isMarkerMode) {

          
          // 버튼 텍스트 확인
          const markerBtn = document.getElementById('topMarkerBtn');
          const buttonText = markerBtn.textContent;

          
          // 마커가 생성되어 있고 "마커완성" 상태라면 저장 다이얼로그 표시
          if (customMarkers.length > 0 || buttonText === '마커완성') {

            
            try {
              showMarkerSaveDialog();

            } catch (error) {
              console.error('showMarkerSaveDialog 호출 실패:', error);
              // 대안: 직접 다이얼로그 생성
              showMarkerSaveDialog();
            }
            
            // 마커 모드 비활성화하여 더 이상 마커 생성 방지
            isMarkerMode = false;
            markerBtn.textContent = '마커생성';
            markerBtn.style.background = 'rgba(255, 255, 255, 0.12)';
            markerBtn.style.color = '#1a1a1a';
            return;
          }
          
          // 마커생성 모드 비활성화
          isMarkerMode = false;
          markerBtn.textContent = '마커생성';
          markerBtn.style.background = 'rgba(255, 255, 255, 0.12)';
          markerBtn.style.color = '#1a1a1a';
          
          // 마커생성 모드 안내 메시지 제거
          if (window.markerModeMessage) {
            window.markerModeMessage.remove();
            window.markerModeMessage = null;
          }
          

        } else {
          // 경로 생성 모드가 활성화되어 있으면 비활성화
          if (isRouteMode) {
            // 경로 생성 모드 비활성화
            isRouteMode = false;
            const routeBtn = document.getElementById('topRouteBtn');
            routeBtn.textContent = '경로생성';
            routeBtn.style.background = 'rgba(255, 255, 255, 0.12)';
            routeBtn.style.color = '#1a1a1a';
            
            // 경로 관련 마커들 제거
            userRouteMarkers.forEach(marker => marker.setMap(null));
            userRouteMarkers = [];
            
            // 경로 폴리라인 제거
            if (userRoutePath) {
              userRoutePath.setMap(null);
              userRoutePath = null;
            }
            if (userRouteDottedPath) {
              userRouteDottedPath.setMap(null);
              userRouteDottedPath = null;
            }
          }
          
          // 마커생성 모드 활성화
          isMarkerMode = true;
          const markerBtn = document.getElementById('topMarkerBtn');
          markerBtn.textContent = '마커생성 중...';
          markerBtn.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
          markerBtn.style.color = 'white';
          
          // 안내 메시지 없이 바로 시작

        }
      }
      
      // 마커생성 모드 안내 메시지 표시 함수
      function showMarkerModeMessage() {
        // 기존 메시지가 있으면 제거
        if (window.markerModeMessage) {
          window.markerModeMessage.remove();
        }
        
        // 안내 메시지 생성
        const message = document.createElement('div');
        message.id = 'markerModeMessage';
        message.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 20px;
          border-radius: 10px;
          text-align: center;
          z-index: 1000;
          font-size: 16px;
          max-width: 300px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;
        message.innerHTML = `
          <div style="margin-bottom: 15px;">📍</div>
          <div style="font-weight: bold; margin-bottom: 10px;">마커생성 모드</div>
          <div>지도를 클릭하여 원하는 위치에 마커를 생성하세요.</div>
          <div style="margin-top: 10px; font-size: 14px; opacity: 0.8;">마커를 클릭하면 제거할 수 있습니다.</div>
        `;
        
        document.body.appendChild(message);
        window.markerModeMessage = message;
        
        // 3초 후 자동으로 메시지 제거
        setTimeout(() => {
          if (message.parentNode) {
            message.remove();
            window.markerModeMessage = null;
          }
        }, 3000);
      }
      
      // 사용자 정의 마커 추가 함수
      function addCustomMarker(latLng) {
        // 마커 생성
        const marker = new google.maps.Marker({
          position: latLng,
          map: map,
          title: `사용자 마커 ${customMarkers.length + 1}`,
          zIndex: 1000, // 경로와 라벨 위에 표시
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#8b5cf6',
            fillOpacity: 1,
            strokeColor: '#ffffff',
            strokeWeight: 2,
            scale: 15 // 10 * 1.5 = 15
          },
          label: {
            text: (customMarkers.length + 1).toString(),
            fontSize: '21px', // 14px * 1.5 = 21px
            fontWeight: 'bold',
            color: '#ffffff'
          }
        });

        // 마커 타이틀 라벨 생성 (줌 레벨 18 이상일 때만 표시)
        const titleLabel = new google.maps.Marker({
          position: new google.maps.LatLng(
            latLng.lat() + 0.0001, // 마커 위에 표시
            latLng.lng()
          ),
          map: null, // 초기에는 숨김
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: 'transparent',
            fillOpacity: 0,
            strokeColor: 'transparent',
            strokeWeight: 0,
            scale: 0
          },
          label: {
            text: '새 마커', // 초기 텍스트 (사용자가 수정하면 업데이트됨)
            fontSize: '12px',
            fontWeight: 'bold',
            color: '#374151',
            className: 'marker-title-label'
          },
          zIndex: 999
        });

        // 마커 객체에 타이틀 라벨 참조 저장
        marker.titleLabel = titleLabel;
        
        // 마커 정보가 업데이트될 때 타이틀 라벨도 함께 업데이트하는 함수
        marker.updateTitleLabel = function(title) {
          if (this.titleLabel) {
            this.titleLabel.setLabel({
              text: title || '새 마커',
              fontSize: '12px',
              fontWeight: 'bold',
              color: '#374151',
              className: 'marker-title-label'
            });
          }
        };
        
        // 마커 클릭 시 제거 기능
        marker.addListener('click', function() {
          // 메뉴창 닫기
          const customMapMenu = getElement('customMapMenu');
          const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
          
          if (!customMapMenu.classList.contains('hide')) {
            hideMenu();
          }
          if (rightPanelOpen) {
            hideRightMenu();
          }
          
          if (confirm('이 마커를 제거하시겠습니까?')) {
            removeCustomMarker(marker);
          }
        });
        
        customMarkers.push(marker);

        
        // 마커가 생성되면 버튼을 "마커완성"으로 변경
        if (customMarkers.length >= 1) {
          const markerBtn = document.getElementById('topMarkerBtn');
          markerBtn.textContent = '마커완성';
          markerBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
          markerBtn.style.color = 'white';

        }
        
        // 성공 메시지

        
        // 현재 줌 레벨에 따라 타이틀 표시/숨김
        toggleMarkerTitleVisibility(map.getZoom());
      }
      
      // 사용자 정의 마커 제거 함수
      function removeCustomMarker(marker) {

        const index = customMarkers.indexOf(marker);
        if (index > -1) {
          // 타이틀 라벨도 함께 제거
          if (marker.titleLabel) {
            marker.titleLabel.setMap(null);
          }
          
          marker.setMap(null);
          customMarkers.splice(index, 1);

          
          // 마커 번호 재정렬
          customMarkers.forEach((m, i) => {
            m.setTitle(`사용자 마커 ${i + 1}`);
            m.setLabel({
              text: (i + 1).toString(),
              fontSize: '21px', // 14px * 1.5 = 21px
              fontWeight: 'bold',
              color: '#ffffff'
            });
            
                                   // 타이틀 라벨도 업데이트
                       if (m.updateTitleLabel) {
                         // 마커 정보에서 실제 타이틀 가져오기
                         const markerId = `${markerGroup.name}-${i}`;
                         const markerInfo = markerInfoData[markerId];
                         m.updateTitleLabel(markerInfo && markerInfo.title);
                       }
          });
          
          // 마커가 모두 제거되면 버튼을 "마커생성 중..."으로 변경
          if (customMarkers.length === 0) {
            const markerBtn = document.getElementById('topMarkerBtn');
            markerBtn.textContent = '마커생성 중...';
            markerBtn.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
            markerBtn.style.color = 'white';

          }
          

        }
      }
      
      // 마커 타이틀 표시/숨김 토글 함수
      function toggleMarkerTitleVisibility(zoomLevel) {
        const shouldShow = zoomLevel >= 18;
        
        // 사용자 생성 마커들의 타이틀 표시/숨김
        customMarkers.forEach(marker => {
          if (marker.titleLabel) {
            if (shouldShow) {
              marker.titleLabel.setMap(map);
            } else {
              marker.titleLabel.setMap(null);
            }
          }
        });
        
        // 저장된 사용자 마커들의 타이틀 표시/숨김
        if (window.savedUserMarkers) {
          window.savedUserMarkers.forEach(markerGroup => {
            if (markerGroup.markerElements) {
              markerGroup.markerElements.forEach(marker => {
                if (marker.titleLabel) {
                  if (shouldShow) {
                    marker.titleLabel.setMap(map);
                  } else {
                    marker.titleLabel.setMap(null);
                  }
                }
              });
            }
          });
        }
      }
      
      // ============================================================================
      // 🛣️ ROUTE MODULE - 경로 생성 및 관리
      // ============================================================================
      
      // 사용자 경로 모드 토글 함수
      function toggleRouteMode() {
        // 마커생성 모드가 활성화되어 있으면 비활성화
        if (isMarkerMode) {
          toggleMarkerMode();
        }
        
        if (userRouteMarkers.length === 0) {
          // 첫 번째 클릭: 경로 생성 모드 시작
          isRouteMode = true;
          const routeBtn = document.getElementById('topRouteBtn');
          routeBtn.textContent = '경로생성 중...';
          routeBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          routeBtn.style.color = 'white';
          

        } else if (userRouteMarkers.length >= 2) {
          // 마커가 2개 이상일 때: 경로완성 모드
          const routeBtn = document.getElementById('topRouteBtn');
          routeBtn.textContent = '경로완성';
          routeBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
          routeBtn.style.color = 'white';
          
          // 경로 저장 위치 선택 다이얼로그 표시
          showRouteSaveDialog();
        }
      }
      
      // 경로 저장 위치 선택 다이얼로그
      function showRouteSaveDialog() {
        // 기존 다이얼로그가 있으면 제거
        const existingDialog = document.getElementById('routeSaveDialog');
        if (existingDialog) {
          existingDialog.remove();
        }
        
        // 현재 활성화된 일정 항목들 가져오기
        const scheduleItems = getActiveScheduleItems();
        
        // 일정 항목 버튼들 생성
        let scheduleButtons = '';
        if (scheduleItems.length === 0) {
          scheduleButtons = '<p style="text-align: center; color: #666; margin: 20px 0;">먼저 일정을 추가해주세요.</p>';
        } else {
          scheduleItems.forEach(item => {
              scheduleButtons += `<button class="route-save-btn" onclick="saveRouteToLocation('${item.title}')">${item.title}</button>`;
          });
        }
        
        // 다이얼로그 생성
        const dialogDiv = document.createElement('div');
        dialogDiv.id = 'routeSaveDialog';
        dialogDiv.innerHTML = `
          <div style="padding: 28px 24px 24px 24px;">
            <div style="text-align: center; margin-bottom: 24px;">
              <h3 style="color: #000; margin: 0; font-size: 18px; font-weight: 500; letter-spacing: -0.01em;">경로 저장 위치 선택</h3>
            </div>
            <div class="route-save-options">
              ${scheduleButtons}
            </div>
          </div>
        `;
        
        // 다이얼로그를 지도 위에 표시
        document.body.appendChild(dialogDiv);
        
        // 다이얼로그 위치 조정 - 모바일 최적화
        setTimeout(() => {
          const mapElement = document.getElementById('map');
          const mapRect = mapElement.getBoundingClientRect();
          
          if (isMobile) {
            // 모바일: 화면 중앙에 표시
            dialogDiv.style.left = '50%';
            dialogDiv.style.transform = 'translateX(-50%)';
            dialogDiv.style.top = '80px';
          } else {
            // 데스크톱: 지도 중앙에 표시
            dialogDiv.style.left = (mapRect.width / 2 - 200) + 'px';
            dialogDiv.style.top = (mapRect.height / 2 - 150) + 'px';
          }
        }, 10);
      }
      
      // 사용자 경로에 위치 추가 함수
      function addUserRoutePoint(latLng) {
        if (!isRouteMode) return;
        
        // 마커 생성
        const marker = new google.maps.Marker({
          position: latLng,
          map: map,
          title: `위치 ${userRouteMarkers.length + 1}`,
          zIndex: 1000, // 경로와 라벨 위에 표시
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#ef4444',
            fillOpacity: 1,
            strokeColor: '#ffffff',
            strokeWeight: 2,
            scale: 12 // 8 * 1.5 = 12
          },
          label: {
            text: (userRouteMarkers.length + 1).toString(),
            fontSize: '18px', // 12px * 1.5 = 18px
            fontWeight: 'bold',
            color: '#ffffff'
          }
        });
        
        // 마커 클릭 시 제거 기능
        marker.addListener('click', function() {
          if (confirm('이 위치를 경로에서 제거하시겠습니까?')) {
            removeUserRoutePoint(marker);
          }
        });
        
        userRouteMarkers.push(marker);
        
        // 경로 업데이트
        updateUserRoute();
        
        // 마커가 2개 이상일 때 버튼을 "경로완성"으로 변경
        if (userRouteMarkers.length >= 2) {
          const routeBtn = document.getElementById('topRouteBtn');
          routeBtn.textContent = '경로완성';
          routeBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
          routeBtn.style.color = 'white';
        }
        
        // 성공 메시지
        const message = userRouteMarkers.length === 1 ? 
          '첫 번째 위치가 추가되었습니다. 계속해서 다음 위치를 클릭하세요.' :
          `위치 ${userRouteMarkers.length}이 추가되었습니다.`;

      }
      
      // 사용자 경로에서 위치 제거 함수
      function removeUserRoutePoint(marker) {
        const index = userRouteMarkers.indexOf(marker);
        if (index > -1) {
          marker.setMap(null);
          userRouteMarkers.splice(index, 1);
          
          // 마커 번호 재정렬
          userRouteMarkers.forEach((m, i) => {
            m.setTitle(`위치 ${i + 1}`);
            m.setLabel({
              text: (i + 1).toString(),
              fontSize: '12px',
              fontWeight: 'bold',
              color: '#ffffff'
            });
          });
          
          // 경로 업데이트
          updateUserRoute();
          
          // 마커가 2개 미만일 때 버튼을 "경로 생성 중..."으로 변경
          if (userRouteMarkers.length < 2) {
            const routeBtn = document.getElementById('topRouteBtn');
            routeBtn.textContent = '경로생성 중...';
            routeBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
            routeBtn.style.color = 'white';
          }
        }
      }
      
      // 사용자 경로 업데이트 함수
      function updateUserRoute() {
        // 기존 경로 제거
        if (userRoutePath) {
          userRoutePath.setMap(null);
        }
        if (userRouteDottedPath) {
          userRouteDottedPath.setMap(null);
        }
        
        // 마커가 2개 이상일 때만 경로 생성
        if (userRouteMarkers.length >= 2) {
          const path = userRouteMarkers.map(marker => marker.getPosition());
          
          // 메인 경로 (파란색)
          userRoutePath = new google.maps.Polyline({
            path: path,
            geodesic: true,
            strokeColor: '#3b82f6',
            strokeOpacity: 0.1,
            strokeWeight: 2,
            zIndex: 10 // 라벨 아래에 표시
          });
          userRoutePath.setMap(map);
          
          // 임시 경로 클릭 이벤트 추가
          userRoutePath.addListener('click', function(event) {
            // 메뉴창 닫기
            const customMapMenu = getElement('customMapMenu');
            const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
            
            if (!customMapMenu.classList.contains('hide')) {
              hideMenu();
            }
            if (rightPanelOpen) {
              hideRightMenu();
            }
            
            const tempRoute = {
              name: '생성 중인 경로',
              path: path
            };
            showRouteInfo(tempRoute, event.latLng);
          });
          
          // 점선 효과 (흰색 점들)
          userRouteDottedPath = new google.maps.Polyline({
            path: path,
            geodesic: true,
            strokeColor: '#ffffff',
            strokeOpacity: 0.1,
            strokeWeight: 1,
            zIndex: 15, // 메인 경로보다는 위에, 라벨보다는 아래
            icons: [{
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: '#3b82f6',
                fillOpacity: 1,
                strokeColor: '#ffffff',
                strokeWeight: 1,
                scale: 6
              },
              offset: '0',
              repeat: '15px'
            }]
          });
          userRouteDottedPath.setMap(map);
          
          // 점선 경로에도 클릭 이벤트 추가
          userRouteDottedPath.addListener('click', function(event) {
            // 메뉴창 닫기
            const customMapMenu = getElement('customMapMenu');
            const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
            
            if (!customMapMenu.classList.contains('hide')) {
              hideMenu();
            }
            if (rightPanelOpen) {
              hideRightMenu();
            }
            
            const tempRoute = {
              name: '생성 중인 경로',
              path: path
            };
            showRouteInfo(tempRoute, event.latLng);
          });
          
          // 경로 정보 표시
          const totalDistance = calculateRouteDistance(path);
        }
      }
      
      // 사용자 경로 초기화 함수
      function clearUserRoute() {
        if (!confirm('생성된 경로를 모두 초기화하시겠습니까?\n(저장된 경로도 함께 제거됩니다)')) {
          return;
        }
        
        // 모든 마커 제거
        userRouteMarkers.forEach(marker => {
          marker.setMap(null);
        });
        userRouteMarkers = [];
        
        // 경로 제거
        if (userRoutePath) {
          userRoutePath.setMap(null);
          userRoutePath = null;
        }
        if (userRouteDottedPath) {
          userRouteDottedPath.setMap(null);
          userRouteDottedPath = null;
        }
        
        // 저장된 모든 경로 제거
        savedUserRoutes.forEach(route => {
          if (route.pathElement) {
            route.pathElement.setMap(null);
          }
          if (route.dottedPathElement) {
            route.dottedPathElement.setMap(null);
          }
        });
        savedUserRoutes = [];
        
        // 경로 모드 비활성화
        isRouteMode = false;
        const routeBtn = document.getElementById('topRouteBtn');
        const clearRouteBtn = document.getElementById('clearRouteBtn');
        
        routeBtn.textContent = '경로생성';
        routeBtn.style.background = 'rgba(255, 255, 255, 0.12)';
        routeBtn.style.color = '#1a1a1a';
        clearRouteBtn.style.display = 'none';
        
        alert('모든 경로가 초기화되었습니다.');
      }
      
      // 경로 초기화 버튼 표시/숨김 함수
      function updateClearRouteButton() {
        const clearRouteBtn = document.getElementById('clearRouteBtn');
        if (clearRouteBtn) {
          clearRouteBtn.style.display = userRouteMarkers.length > 0 ? 'block' : 'none';
        }
      }
      
      // 현재 활성화된 일정 항목들 가져오기
      function getActiveScheduleItems() {
        const scheduleItems = [];
        
        // 사용자가 추가한 일정들만 가져오기
        const customScheduleButtons = document.querySelectorAll('#additionalDays [data-item-type="schedule"]');
        customScheduleButtons.forEach(item => {
          const scheduleId = item.getAttribute('data-schedule-id');
          const scheduleTitle = item.getAttribute('data-schedule-title');
          if (scheduleId && scheduleTitle) {
            scheduleItems.push({ id: scheduleId, title: scheduleTitle });
          }
        });
        
        return scheduleItems;
      }


      
      // 경로 저장 위치 선택 다이얼로그 닫기 (헬퍼 함수 사용)
      function closeRouteSaveDialog() {
        removeElement('routeSaveDialog');
      }
      
      // 선택된 위치에 경로 저장 (개선된 버전)
      async function saveRouteToLocation(location) {
        if (userRouteMarkers.length < 2) {
          updateSyncStatus('경로를 생성하려면 최소 2개의 위치가 필요합니다', 'error');
          return;
        }
        
        // 동기화 중이면 무시
        if (isSyncing) {
          updateSyncStatus('동기화 중입니다. 잠시 후 다시 시도해주세요', 'warning');
          return;
        }
        
        // 경로 데이터 생성
        const routeData = {
          id: 'route_' + Date.now(),
          name: `${location} 경로`,
          location: location,
          path: userRouteMarkers.map(marker => ({
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          })),
          distance: calculateRouteDistance(userRouteMarkers.map(marker => marker.getPosition())),
          createdAt: new Date().toISOString()
        };
        
        // 헬퍼 함수를 사용한 간결한 저장 (기능 동일)
        const success = await withSyncStatus(async () => {
          try {
            await updateFirebaseDoc(
              { savedUserRoutes: window.firestore.arrayUnion(routeData) },
              true,
              '경로 저장'
            );
          savedUserRoutes.push(routeData);
        } catch (error) {
            // 오류 발생 시에도 전역 변수에 추가 (오프라인 대비)
          console.error('Firebase 저장 실패:', error);
          savedUserRoutes.push(routeData);
          setTimeout(() => {
            updateSyncStatus('Firebase 연결 실패', 'error');
          }, 2000);
        }
        }, '경로 저장 중...');
        
        // 임시 마커들 제거
        userRouteMarkers.forEach(marker => {
          marker.setMap(null);
        });
        userRouteMarkers = [];
        
        // 임시 경로 제거
        if (userRoutePath) {
          userRoutePath.setMap(null);
          userRoutePath = null;
        }
        if (userRouteDottedPath) {
          userRouteDottedPath.setMap(null);
          userRouteDottedPath = null;
        }
        
        // 경로 모드 비활성화
        isRouteMode = false;
        
        // 버튼 상태 복원
        const routeBtn = document.getElementById('topRouteBtn');
        routeBtn.textContent = '경로생성';
        routeBtn.style.background = 'rgba(255, 255, 255, 0.12)';
        routeBtn.style.color = '#1a1a1a';
        
        // 다이얼로그 닫기
        closeRouteSaveDialog();
        
        // 저장된 경로들 다시 그리기
        drawAllSavedRoutes();
        
        // 경로제거 버튼 상태 업데이트
        updateRouteRemoveButtons();
        // 마커제거 버튼 상태 업데이트
        updateMarkerRemoveButtons();
      }

      
      // 마커 저장 위치 선택 다이얼로그 표시
      function showMarkerSaveDialog() {

        
        // 기존 다이얼로그가 있으면 제거
        const existingDialog = document.getElementById('markerSaveDialog');
        if (existingDialog) {
          existingDialog.remove();
        }
        
        // 현재 활성화된 일정 항목들 가져오기
        const scheduleItems = getActiveScheduleItems();
        
        // 일정 항목 버튼들 생성
        let scheduleButtons = '';
        if (scheduleItems.length === 0) {
          scheduleButtons = '<p style="text-align: center; color: #666; margin: 20px 0;">먼저 일정을 추가해주세요.</p>';
        } else {
          scheduleItems.forEach(item => {
            scheduleButtons += `<button class="route-save-btn" onclick="saveMarkersToLocation('${item.title}')">${item.title}</button>`;
          });
        }
        
        // 다이얼로그 생성
        const dialogDiv = document.createElement('div');
        dialogDiv.id = 'markerSaveDialog';
        dialogDiv.innerHTML = `
          <div style="padding: 28px 24px 24px 24px;">
            <div style="text-align: center; margin-bottom: 24px;">
              <h3 style="color: #000; margin: 0; font-size: 18px; font-weight: 500; letter-spacing: -0.01em;">마커 저장 위치 선택</h3>
            </div>
            <div class="route-save-options">
              ${scheduleButtons}
            </div>
          </div>
        `;
        
        // 다이얼로그를 지도 위에 표시

        document.body.appendChild(dialogDiv);
        
        // 다이얼로그 위치 조정 - 모바일 최적화
        setTimeout(() => {
          const mapElement = document.getElementById('map');
          const mapRect = mapElement.getBoundingClientRect();
          
          if (isMobile) {
            // 모바일: 화면 중앙에 표시
            dialogDiv.style.left = '50%';
            dialogDiv.style.transform = 'translateX(-50%)';
            dialogDiv.style.top = '80px';
          } else {
            // 데스크톱: 지도 중앙에 표시
            dialogDiv.style.left = (mapRect.width / 2 - 200) + 'px';
            dialogDiv.style.top = (mapRect.height / 2 - 150) + 'px';
            dialogDiv.style.transform = 'none';
          }

        }, 100);
      }
      
      // 마커 저장 위치 선택 다이얼로그 닫기 (헬퍼 함수 사용)
      function closeMarkerSaveDialog() {
        removeElement('markerSaveDialog');
        
        // 다이얼로그가 닫힐 때 마커 모드가 완전히 비활성화되었는지 확인
        if (isMarkerMode) {
          isMarkerMode = false;
          const markerBtn = document.getElementById('topMarkerBtn');
          markerBtn.textContent = '마커생성';
          markerBtn.style.background = 'rgba(255, 255, 255, 0.12)';
          markerBtn.style.color = '#1a1a1a';
        }
      }
      
      // 선택된 위치에 마커 저장
      // 선택된 위치에 마커 저장 (개선된 버전)
      async function saveMarkersToLocation(location) {
        if (customMarkers.length === 0) {
          updateSyncStatus('저장할 마커가 없습니다', 'error');
          return;
        }
        
        // 동기화 중이면 무시
        if (isSyncing) {
          updateSyncStatus('동기화 중입니다. 잠시 후 다시 시도해주세요', 'warning');
          return;
        }
        
        // 마커 데이터 생성
        const markerData = {
          id: (window.crypto && window.crypto.randomUUID)
                ? `marker_${window.crypto.randomUUID()}`
                : `marker_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`,
          name: `${location} 마커`,
          location: location,
          markers: customMarkers.map(marker => ({
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng(),
            title: marker.getTitle()
          })),
          createdAt: new Date().toISOString()
        };
        
        // 헬퍼 함수를 사용한 간결한 저장 (기능 동일)
        await withSyncStatus(async () => {
          try {
            await updateFirebaseDoc(
              { savedUserMarkers: window.firestore.arrayUnion(markerData) },
              true,
              '마커 저장'
            );
          // 전역 변수에 추가
          if (!window.savedUserMarkers) {
            window.savedUserMarkers = [];
          }
          window.savedUserMarkers.push(markerData);
        } catch (error) {
            // 오류 발생 시에도 전역 변수에 추가 (오프라인 대비)
          console.error('Firebase 저장 실패:', error);
          if (!window.savedUserMarkers) {
            window.savedUserMarkers = [];
          }
          window.savedUserMarkers.push(markerData);
          setTimeout(() => {
            updateSyncStatus('Firebase 연결 실패', 'error');
          }, 2000);
        }
        }, '마커 저장 중...');
        
        // 임시 마커들 제거
        customMarkers.forEach(marker => {
          marker.setMap(null);
        });
        customMarkers = [];
        
        // 마커 모드가 아직 활성화되어 있다면 비활성화 (중복 방지)
        if (isMarkerMode) {
          isMarkerMode = false;
          
          // 버튼 상태 복원
          const markerBtn = document.getElementById('topMarkerBtn');
          markerBtn.textContent = '마커생성';
          markerBtn.style.background = 'rgba(255, 255, 255, 0.12)';
          markerBtn.style.color = '#1a1a1a';
        }
        
        // 다이얼로그 닫기
        closeMarkerSaveDialog();
        
        // 저장된 마커들 다시 그리기
        clearAllRenderedMarkers();
        drawAllSavedMarkers();
        
        // 마커제거 버튼 상태 업데이트
        updateMarkerRemoveButtons();
      }
      
      // 저장된 모든 마커 그리기
      function drawAllSavedMarkers() {
        // 기존 저장된 마커들 제거
        if (window.savedUserMarkers) {
          window.savedUserMarkers.forEach(markerGroup => {
            if (markerGroup.markerElements) {
              markerGroup.markerElements.forEach(marker => {
                marker.setMap(null);
              });
            }
          });
        }
        
        // 저장된 마커들 다시 그리기
        if (window.savedUserMarkers) {
          window.savedUserMarkers.forEach(markerGroup => {
            if (markerGroup.markers && markerGroup.markers.length > 0) {
              markerGroup.markerElements = [];
              
              markerGroup.markers.forEach((markerData, index) => {
                const idKey = (markerGroup && markerGroup.id) ? `${markerGroup.id}-${index}` : null;
                const nameKey = `${markerGroup.name}-${index}`;
                const infoForMarker = markerInfoData
                  ? (idKey && markerInfoData[idKey]) || markerInfoData[nameKey] || null
                  : null;
                const emoji = (infoForMarker && infoForMarker.emoji) ? infoForMarker.emoji : '';
                const useEmoji = !!emoji;
                const markerOptions = {
                  position: new google.maps.LatLng(markerData.lat, markerData.lng),
                  map: map,
                  title: markerData.title || markerGroup.location || `${markerGroup.name} ${index + 1}`,
                  zIndex: 1000
                };
                if (useEmoji) {
                  markerOptions.icon = {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: 'transparent',
                    fillOpacity: 0,
                    strokeColor: 'transparent',
                    strokeWeight: 0,
                    scale: 12
                  };
                  markerOptions.label = {
                    text: emoji,
                    fontSize: '20px',
                    fontWeight: 'bold'
                  };
                } else {
                  markerOptions.icon = {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: '#8b5cf6',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 1,
                    scale: 12
                  };
                  markerOptions.label = {
                    text: (index + 1).toString(),
                    fontSize: '18px',
                    fontWeight: 'bold',
                    color: '#ffffff'
                  };
                }
                const marker = new google.maps.Marker(markerOptions);
                
                // 마커 타이틀 라벨 생성 (줌 레벨 18 이상일 때만 표시)
                const titleLabel = new google.maps.Marker({
                  position: new google.maps.LatLng(
                    markerData.lat + 0.0001, // 마커 위에 표시
                    markerData.lng
                  ),
                  map: null, // 초기에는 숨김
                  icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: 'transparent',
                    fillOpacity: 0,
                    strokeColor: 'transparent',
                    strokeWeight: 0,
                    scale: 0
                  },
                  label: {
                    text: markerData.title || (infoForMarker && infoForMarker.title) || markerGroup.location || `${markerGroup.name} ${index + 1}`,
                    fontSize: '12px',
                    fontWeight: 'bold',
                    color: '#374151',
                    className: 'marker-title-label'
                  },
                  zIndex: 999
                });

                // 마커 객체에 타이틀 라벨 참조 저장
                marker.titleLabel = titleLabel;
                
                // 마커 정보가 업데이트될 때 타이틀 라벨도 함께 업데이트하는 함수
                marker.updateTitleLabel = function(title) {
                  if (this.titleLabel) {
                    this.titleLabel.setLabel({
                      text: title || `마커 ${index + 1}`,
                      fontSize: '12px',
                      fontWeight: 'bold',
                      color: '#374151',
                      className: 'marker-title-label'
                    });
                  }
                };
                
                // 마커 클릭 시 정보 표시 및 줌 15로 중심 이동
                marker.addListener('click', function() {
                  // 메뉴창 닫기
                  const customMapMenu = getElement('customMapMenu');
                  const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
                  
                  if (!customMapMenu.classList.contains('hide')) {
                    hideMenu();
                  }
                  if (rightPanelOpen) {
                    hideRightMenu();
                  }
                  
                  if (isMarkerMode) { addCustomMarker(marker.getPosition()); return; }
                  if (isRouteMode) { addUserRoutePoint(marker.getPosition()); return; }
                  
                  showMarkerInfo(markerGroup, markerData, index);
                });
                
                markerGroup.markerElements.push(marker);
              });
            }
          });
        }
      }

      // 현재 지도에 그려진 모든 사용자 마커를 제거 (실시간 동기화용)
      function clearAllRenderedMarkers() {
        try {
          (window.savedUserMarkers || []).forEach(function(markerGroup) {
            if (markerGroup && markerGroup.markerElements) {
              markerGroup.markerElements.forEach(function(marker) {
                if (marker) {
                  marker.setMap(null);
                }
              });
            }
          });
        } catch (e) {
          console.warn('마커 요소 제거 중 경고:', e);
        }
      }
      
      // Firestore 저장용으로 사용자 마커 데이터를 정제 (비직렬화 필드 제거)
      function sanitizeSavedUserMarkersForFirestore(markers) {
        try {
          return (markers || []).map(function(group) {
            return {
              id: group && group.id ? group.id : undefined,
              name: group && group.name ? group.name : undefined,
              location: group && group.location ? group.location : undefined,
              createdAt: group && group.createdAt ? group.createdAt : undefined,
              markers: Array.isArray(group && group.markers)
                ? group.markers.map(function(m) {
                    return {
                      lat: m && typeof m.lat === 'number' ? m.lat : (m && m.lat ? Number(m.lat) : undefined),
                      lng: m && typeof m.lng === 'number' ? m.lng : (m && m.lng ? Number(m.lng) : undefined),
                      title: (m && m.title) ? m.title : ''
                    };
                  })
                : []
            };
          });
        } catch (e) {
          console.error('마커 데이터 정제 실패:', e);
          return [];
        }
      }
      
      // 마커 정보 표시
      function showMarkerInfo(markerGroup, markerData, index) {
        // 생성 모드에서는 정보창을 표시하지 않음
        if (isMarkerMode || isRouteMode) {
          return;
        }
         // 기존 정보창이 있으면 제거
         if (window.currentInfoWindow) {
           window.currentInfoWindow.close();
           window.currentInfoWindow = null;
         }
        
        // 저장된 정보로 정보창 표시 (그룹 id 우선 전달)
        showMarkerInfoWithData(markerGroup.id || markerGroup.name, index);
        
        // X 버튼 제거를 위한 스타일 추가
        google.maps.event.addListener(window.currentInfoWindow, 'domready', function() {
          const closeBtn = document.querySelector('.gm-ui-hover-effect');
          if (closeBtn) {
            closeBtn.style.display = 'none';
          }
        });
        
        // 마커 위치에 정보창 표시 (마커 상단에 표시)
        const marker = markerGroup.markerElements[index];
        window.currentInfoWindow.open(map, marker);
        
        try {
          const currentZoom = map.getZoom();
          // 현재 줌레벨이 15 미만일 때만 줌레벨 15로 확대
          if (currentZoom < 15) {
            map.setZoom(15);
          }
          map.panTo(marker.getPosition());
        } catch (_) {}
      }
      
      // 경로 거리 계산 함수
      function calculateRouteDistance(path) {
        if (!path || path.length < 2) return 0;
        
        let totalDistance = 0;
        for (let i = 0; i < path.length - 1; i++) {
          const from = path[i];
          const to = path[i + 1];
          
          // 두 지점 간의 거리 계산 (미터 단위)
          totalDistance += google.maps.geometry.spherical.computeDistanceBetween(from, to);
        }
        
        return totalDistance;
      }
      
      // 거리를 사용자 친화적 형태로 포맷
      function formatDistance(distanceInMeters) {
        if (distanceInMeters < 1000) {
          return `${Math.round(distanceInMeters)}m`;
        } else {
          const kilometers = distanceInMeters / 1000;
          if (kilometers < 10) {
            return `${kilometers.toFixed(1)}km`;
          } else {
            return `${Math.round(kilometers)}km`;
          }
        }
      }
      
      // 경로 정보창 표시 함수
      function showRouteInfo(route, clickPosition) {
        // 생성 모드에서는 정보창을 표시하지 않음
        if (isMarkerMode || isRouteMode) {
          return;
        }
        
        // 현재 열린 경로 정보 추적
        window.currentOpenRouteId = route.id;
         const path = route.path || route.getPath();
         const distance = calculateRouteDistance(path);
         const formattedDistance = formatDistance(distance);
         
         // 경로 전체가 보이도록 지도 이동 (필요한 경우에만)
         if (path && path.length >= 2) {
           const bounds = new google.maps.LatLngBounds();
           path.forEach(point => {
             if (point instanceof google.maps.LatLng) {
               bounds.extend(point);
             } else {
               bounds.extend(new google.maps.LatLng(point.lat, point.lng));
             }
           });
           
           // 경로의 크기에 따라 동적으로 여백 조정
           const routeSize = calculateRouteDistance(path);
           
           // 경로 크기에 따른 여백 계산 (작은 경로일수록 더 많은 여백)
           let padding;
           if (routeSize < 500) {
             // 500m 미만: 100px 여백 (매우 작은 경로)
             padding = 100;
           } else if (routeSize < 1000) {
             // 500m-1km: 80px 여백 (작은 경로)
             padding = 80;
           } else if (routeSize < 2000) {
             // 1-2km: 60px 여백 (중간 경로)
             padding = 60;
           } else {
             // 2km 이상: 40px 여백 (큰 경로)
             padding = 40;
           }
           
           const paddingOptions = {
             top: padding,
             bottom: padding,
             left: padding,
             right: padding
           };
           
           // 경로를 클릭했을 때는 항상 해당 경로에 맞춰 확대
           map.fitBounds(bounds, paddingOptions);
         }
         
         // 생성 중인 경로인지 확인 (삭제 버튼을 표시하지 않음)
         const isTemporaryRoute = route.name === '생성 중인 경로';
         
         // 경로에 저장된 추가 정보 표시 (내용/링크)
         const routeExtra = (routeInfoData && route.id) ? (routeInfoData[route.id] || { content: '', link: '' }) : { content: '', link: '' };
         const hasLink = !!(routeExtra.link);
         const contentLabel = (routeExtra.content && routeExtra.content.trim()) || (hasLink ? routeExtra.link : '');
         const contentText = contentLabel
           ? (hasLink
               ? `<div style=\"margin-top:4px; font-size:18px; line-height:1.2;\"><a href=\"${routeExtra.link}\" target=\"_self\" style=\"color:#2563eb; text-decoration:underline;\">${contentLabel}</a></div>`
               : `<div style=\"margin-top:4px; color:#111827; font-size:18px; line-height:1.2;\">${contentLabel}</div>`)
           : '';
         const info = `
           <div class="route-info-container" style="padding: 8px; min-width: 160px; position: relative; display: flex; flex-direction: column;">
             <div class="route-info-content" style="display: flex; align-items: center; justify-content: flex-start; margin-bottom: 4px; width: 100%;">
               <p style="margin: 0; font-size: 18px; font-weight: bold; color: #3b82f6; padding: 4px 8px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${formattedDistance}</p>
             </div>
             ${!isTemporaryRoute ? `<button class="route-swipe-edit-btn" onclick="editRouteInfo('${route.id}', '${route.name}')" title="편집">편집</button>` : ''}
             ${contentText}
           </div>
         `;
         
         // 기존 정보창이 있으면 제거
         if (window.currentInfoWindow) {
           window.currentInfoWindow.close();
         }
         
         // 새 정보창 생성
         window.currentInfoWindow = new google.maps.InfoWindow({
           content: info,
           position: clickPosition,
           disableAutoPan: false,
           maxWidth: 200
         });
         
         // X 버튼 제거 및 스와이프 이벤트 설정
         google.maps.event.addListener(window.currentInfoWindow, 'domready', function() {
           const closeBtn = document.querySelector('.gm-ui-hover-effect');
           if (closeBtn) {
             closeBtn.style.display = 'none';
           }
           
           // 경로 정보창 스와이프 이벤트 설정
           setupRouteInfoSwipeEvents();
           
           // 정보창 외부 클릭으로 닫기 기능 추가
           setTimeout(() => {
             const infoWindowElement = document.querySelector('.gm-style-iw-c');
             if (infoWindowElement) {
               // 정보창 외부 클릭 감지를 위한 이벤트 리스너
               window.routeInfoOutsideClickHandler = function(event) {
                 if (!infoWindowElement.contains(event.target)) {
                   closeInfoWindow();
                 }
               };
               
               // 약간의 지연 후 이벤트 리스너 추가 (정보창이 완전히 렌더링된 후)
               setTimeout(() => {
                 document.addEventListener('click', window.routeInfoOutsideClickHandler);
               }, 100);
             }
           }, 200);
         });
         
         window.currentInfoWindow.open(map);
       }
      
      // 경로 정보창 스와이프 이벤트 설정 함수
      function setupRouteInfoSwipeEvents() {
        const routeInfoContainer = document.querySelector('.route-info-container');
        if (!routeInfoContainer) return;
        
        let startX = 0;
        let startY = 0;
        let startTime = 0;
        let hasSwiped = false;
        
        // 동적 내용 컨테이너 너비 계산 함수
        function calculateContentWidth() {
          const content = routeInfoContainer.querySelector('.route-info-content');
          const editBtn = routeInfoContainer.querySelector('.route-swipe-edit-btn');
          
          // 편집 버튼의 너비 (60px + padding + margin)
          const editBtnWidth = 80;
          
          // 컨테이너의 현재 너비
          const containerWidth = routeInfoContainer.offsetWidth;
          
          // 내용 컨테이너의 최대 너비 = 컨테이너 너비 - 편집 버튼 너비 - 여백
          const maxContentWidth = containerWidth - editBtnWidth - 16; // 16px 여백
          
          return maxContentWidth;
        }
        
        // 터치 시작 이벤트
        routeInfoContainer.addEventListener('touchstart', function(e) {
          // 편집 버튼을 터치한 경우에는 스와이프 방지
          if (e.target.classList.contains('route-swipe-edit-btn')) {
            return;
          }
          
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          startTime = Date.now();
          hasSwiped = false;
        }, { passive: true });
        
        // 터치 이동 이벤트
        routeInfoContainer.addEventListener('touchmove', function(e) {
          if (!startX || !startY) return;
          
          const currentX = e.touches[0].clientX;
          const currentY = e.touches[0].clientY;
          const diffX = startX - currentX;
          const diffY = Math.abs(startY - currentY);
          
          // 수직 스크롤보다 수평 스와이프가 더 큰 경우에만 처리
          if (Math.abs(diffX) > diffY && Math.abs(diffX) > 10) {
            e.preventDefault();
            hasSwiped = true;
            
            // 동적 내용 컨테이너 너비 계산
            const maxContentWidth = calculateContentWidth();
            
            // 스와이프 진행 중 시각적 피드백 - 내용 컨테이너 너비 조정
            const progress = Math.min(Math.abs(diffX) / 80, 1);
            const contentWidth = maxContentWidth * (1 - progress * 0.3); // 최대 30% 축소
            routeInfoContainer.querySelector('.route-info-content').style.width = `${contentWidth}px`;
          }
        }, { passive: false });
        
        // 터치 종료 이벤트
        routeInfoContainer.addEventListener('touchend', function(e) {
          if (!hasSwiped) return;
          
          const endTime = Date.now();
          const diffTime = endTime - startTime;
          const currentX = e.changedTouches[0].clientX;
          const diffX = startX - currentX;
          
          // 스와이프 완료 조건: 30px 이상 이동, 1초 이내, 수평 이동
          if (diffX > 30 && diffTime < 1000) {
            // 스와이프 완료 - 편집 버튼 표시
            routeInfoContainer.classList.add('swiped');
            const maxContentWidth = calculateContentWidth();
            routeInfoContainer.style.setProperty('--content-width', `${maxContentWidth}px`);
          } else {
            // 스와이프 취소 - 원래 위치로 복원
            routeInfoContainer.classList.remove('swiped');
            routeInfoContainer.querySelector('.route-info-content').style.width = '100%';
          }
          
          // 변수 초기화
          startX = 0;
          startY = 0;
          startTime = 0;
          hasSwiped = false;
        }, { passive: true });
        
        // 클릭 시 스와이프 상태 해제
        routeInfoContainer.addEventListener('click', function(e) {
          // 편집 버튼 클릭이 아닌 경우에만 스와이프 해제
          if (!e.target.classList.contains('route-swipe-edit-btn')) {
            routeInfoContainer.classList.remove('swiped');
            routeInfoContainer.querySelector('.route-info-content').style.width = '100%';
          }
          
          // 편집 버튼 클릭이 아닌 경우에만 이벤트 전파 방지
          if (!e.target.classList.contains('route-swipe-edit-btn')) {
            e.stopPropagation();
          }
        });
        
        // 모바일에서만 마우스 드래그 이벤트 활성화
        if (window.innerWidth <= 768) {
          let isDragging = false;
          let dragStartX = 0;
          
          routeInfoContainer.addEventListener('mousedown', function(e) {
            // 편집 버튼을 클릭한 경우에는 드래그 방지
            if (e.target.classList.contains('route-swipe-edit-btn')) {
              return;
            }
            
            if (e.button !== 0) return; // 왼쪽 버튼만
            
            isDragging = true;
            dragStartX = e.clientX;
          });
          
          routeInfoContainer.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            const diffX = dragStartX - e.clientX;
            
            if (Math.abs(diffX) > 3) {
              // 동적 내용 컨테이너 너비 계산
              const maxContentWidth = calculateContentWidth();
              
              // 드래그 진행 중 시각적 피드백 - 내용 컨테이너 너비 조정
              const progress = Math.min(Math.abs(diffX) / 80, 1);
              const contentWidth = maxContentWidth * (1 - progress * 0.3); // 최대 30% 축소
              routeInfoContainer.querySelector('.route-info-content').style.width = `${contentWidth}px`;
            }
          });
          
          routeInfoContainer.addEventListener('mouseup', function(e) {
            if (!isDragging) return;
            
            const diffX = dragStartX - e.clientX;
            
            if (diffX > 20) {
              // 드래그 완료 - 편집 버튼 표시
              routeInfoContainer.classList.add('swiped');
              const maxContentWidth = calculateContentWidth();
              routeInfoContainer.style.setProperty('--content-width', `${maxContentWidth}px`);
            } else {
              // 드래그 취소 - 원래 위치로 복원
              routeInfoContainer.classList.remove('swiped');
              routeInfoContainer.querySelector('.route-info-content').style.width = '100%';
            }
            
            isDragging = false;
            dragStartX = 0;
          });
          
          // 마우스가 컨테이너를 벗어날 때 드래그 상태 해제
          routeInfoContainer.addEventListener('mouseleave', function() {
            if (isDragging) {
              routeInfoContainer.classList.remove('swiped');
              routeInfoContainer.querySelector('.route-info-content').style.width = '100%';
              isDragging = false;
              dragStartX = 0;
            }
          });
        }
      }
      
      // Firestore 저장용으로 경로 배열을 정제 (UI 전용 필드 제거)
      function sanitizeRoutesForFirestore(routes) {
        try {
          return (routes || []).map(function(r) {
            if (!r) return r;
            var rest = {};
            for (var k in r) {
              if (k !== 'pathElement' && k !== 'dottedPathElement') rest[k] = r[k];
            }
            // path는 순수 lat/lng 배열만 유지
            var cleanPath = Array.isArray(rest.path)
              ? rest.path.map(function(p){ return { lat: Number(p.lat), lng: Number(p.lng) }; })
              : [];
            rest.path = cleanPath;
            return rest;
          });
        } catch (e) {
          console.error('sanitizeRoutesForFirestore 실패:', e);
          return [];
        }
      }
      
      // 정보창에서 경로 삭제 함수
      async function deleteRouteFromInfo(routeId, routeName) {
        if (!confirm(`"${routeName}" 경로를 삭제하시겠습니까?`)) {
          return;
        }
        

        
        try {
          // 정보창과 편집 다이얼로그 닫기
          if (window.currentInfoWindow) {
            window.currentInfoWindow.close();
            window.currentInfoWindow = null;
          }
          
          const editDialog = document.getElementById('routeEditDialog');
          if (editDialog) {
            editDialog.remove();
          }
          
          // 저장된 경로들에서 해당 경로 찾기
          const routeIndex = savedUserRoutes.findIndex(route => route.id === routeId);
          
          if (routeIndex === -1) {
            alert('경로를 찾을 수 없습니다.');
            return;
          }
          
          const route = savedUserRoutes[routeIndex];
          

          
          // 지도에서 경로 시각적 제거 (즉시 피드백을 위해)
          if (route.pathElement) {
            route.pathElement.setMap(null);
          }
          if (route.dottedPathElement) {
            route.dottedPathElement.setMap(null);
          }
          
          // Firebase 저장용 배열 생성 (로컬 배열은 실시간 동기화로만 업데이트)
          const updatedRoutes = [...savedUserRoutes];
          updatedRoutes.splice(routeIndex, 1);
          

          
          // Firebase에 업데이트
          if (window.db && window.firestore) {

            
            const userDocRef = window.firestore.doc(window.db, 'users', 'currentUser');
            const sanitizedRoutes = sanitizeRoutesForFirestore(updatedRoutes);
            await window.firestore.updateDoc(userDocRef, {
              savedUserRoutes: sanitizedRoutes,
              lastUpdated: window.firestore.serverTimestamp()
            });
            

            
            // UI 업데이트는 실시간 동기화를 통해 처리되므로 여기서는 하지 않음

          } else {
            console.warn('Firebase가 초기화되지 않았습니다 - 경로 삭제가 저장되지 않음');
            alert('Firebase 연결이 되지 않았습니다. 경로 삭제가 저장되지 않을 수 있습니다.');
          }
          
        } catch (error) {
          console.error('경로 삭제 실패:', error);
          console.error('Error details:', {
            code: error.code,
            message: error.message,
            stack: error.stack
          });
          alert(`경로 삭제에 실패했습니다: ${error.message}\n다시 시도해주세요.`);
        }
      }
      
      // Firebase 연결 상태 테스트 함수
      async function testFirebaseConnection() {
        try {

          
          if (window.db && window.firestore) {
            const testDoc = window.firestore.doc(window.db, 'users', 'currentUser');
            const docSnap = await window.firestore.getDoc(testDoc);

            return true;
          } else {
            console.error('Firebase 객체가 초기화되지 않았습니다');
            return false;
          }
        } catch (error) {
          console.error('Firebase 연결 테스트 실패:', error);
          return false;
        }
      }
      
      // 경로 정보 수정 다이얼로그
      function editRouteInfo(routeId, routeName) {
        // 현재 저장된 정보 가져오기
        const current = (routeInfoData && routeInfoData[routeId]) ? routeInfoData[routeId] : { content: '', link: '', color: '#3b82f6' };
        const isMobileView = window.innerWidth <= 768;
        const dialogWidth = isMobileView ? Math.min(320, window.innerWidth - 40) : 360;
        const maxWidth = isMobileView ? '90vw' : '440px';
        
        // 색상 옵션 정의
        const colorOptions = [
          { name: '파랑', value: '#3b82f6', label: '파' },
          { name: '빨강', value: '#ef4444', label: '빨' },
          { name: '주황', value: '#f97316', label: '주' },
          { name: '노랑', value: '#eab308', label: '노' },
          { name: '초록', value: '#22c55e', label: '초' },
          { name: '보라', value: '#8b5cf6', label: '보' }
        ];
        
        const html = `
          <div style="padding: 28px 24px 24px 24px; width: ${dialogWidth}px; max-width: ${maxWidth}; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
            <div style="text-align: center; margin-bottom: 24px; position: relative;">
              <h3 style="color: #000; margin: 0; font-size: 18px; font-weight: 500; letter-spacing: -0.01em;">${routeName} - 경로 수정</h3>
              <button type="button" onclick="cancelRouteEdit('${routeId}', '${routeName}')" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 20px; color: #666; cursor: pointer; padding: 5px; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(0,0,0,0.1)'" onmouseout="this.style.background='none'" title="취소">×</button>
            </div>
            <div style="margin-bottom: 16px;">
              <textarea id="route-edit-content" rows="${isMobileView ? '3':'4'}" placeholder="내용을 입력하세요" style="width:100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px); resize:vertical;" onfocus="this.style.background='rgba(255, 255, 255, 0.18)'" onblur="this.style.background='rgba(255, 255, 255, 0.12)'">${(current.content||'').replace(/"/g,'&quot;')}</textarea>
            </div>
            <div style="margin-bottom: 16px;">
              <input id="route-edit-link" type="text" placeholder="링크를 입력하세요 (https://...)" value="${(current.link||'').replace(/"/g,'&quot;')}" style="width:100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px);" onfocus="this.style.background='rgba(255, 255, 255, 0.18)'" onblur="this.style.background='rgba(255, 255, 255, 0.12)'" />
            </div>
            <div style="margin-bottom: 24px;">
              <div style="margin-bottom: 8px; color: #333; font-size: 14px; font-weight: 500;">경로 색상</div>
              <div style="display: flex; gap: ${isMobileView ? '4px' : '8px'}; flex-wrap: ${isMobileView ? 'nowrap' : 'wrap'}; justify-content: center;">
                ${colorOptions.map(color => `
                  <button type="button" onclick="selectRouteColor('${routeId}', '${color.value}')" 
                          style="width: ${isMobileView ? '32px' : '40px'}; height: ${isMobileView ? '32px' : '40px'}; border-radius: 8px; border: ${(current.color || '#3b82f6') === color.value ? '3px solid #000' : '2px solid rgba(255,255,255,0.3)'}; background: ${color.value}; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: ${isMobileView ? '10px' : '12px'}; flex-shrink: 0;"
                          title="${color.name}">
                    ${color.label}
                  </button>
                `).join('')}
              </div>
            </div>
            <div style="display:flex; gap:12px; flex-direction: row;">
              <button onclick="saveRouteInfo('${routeId}', '${routeName}')" style="flex: 1; background: rgba(255, 255, 255, 0.12); color: #000; border: none; border-radius: 12px; padding: 14px 16px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'">저장</button>
              <button onclick="deleteRouteFromInfo('${routeId}', '${routeName}')" style="flex: 1; background: rgba(255, 255, 255, 0.12); color: #000; border: none; border-radius: 12px; padding: 14px 16px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'">삭제</button>
            </div>
          </div>
        `;
        
        // 기존 정보창 닫기
        if (window.currentInfoWindow) {
          window.currentInfoWindow.close();
          window.currentInfoWindow = null;
        }
        
        // 기존 경로 편집 다이얼로그가 있으면 제거
        const existingDialog = document.getElementById('routeEditDialog');
        if (existingDialog) {
          existingDialog.remove();
        }
        
        // 화면 중앙에 편집 다이얼로그 생성
        const dialogDiv = document.createElement('div');
        dialogDiv.id = 'routeEditDialog';
        dialogDiv.style.cssText = `
          position: fixed;
          z-index: 1000;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: ${dialogWidth}px;
          max-width: ${maxWidth};
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.12);
          border-radius: 20px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.12);
          backdrop-filter: blur(24px);
          -webkit-backdrop-filter: blur(24px);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          overflow: hidden;
          transition: all 0.3s ease;
        `;
        
        dialogDiv.innerHTML = html;
        document.body.appendChild(dialogDiv);
        
        // 입력 필드에 포커스
        setTimeout(() => {
          const contentInput = document.getElementById('route-edit-content');
          if (contentInput) {
            contentInput.focus();
          }
        }, 150);
      }
      
      // 경로 색상 선택 함수
      function selectRouteColor(routeId, color) {
        // 선택된 색상을 전역 변수에 저장
        window.selectedRouteColor = window.selectedRouteColor || {};
        window.selectedRouteColor[routeId] = color;
        
        // UI 업데이트 - 모든 색상 버튼의 테두리를 리셋하고 선택된 것만 하이라이트
        const buttons = document.querySelectorAll(`button[onclick*="selectRouteColor('${routeId}'"]`);
        buttons.forEach(button => {
          if (button.onclick.toString().includes(`'${color}'`)) {
            button.style.border = '3px solid #000';
          } else {
            button.style.border = '2px solid rgba(255,255,255,0.3)';
          }
        });
        

      }
      
      // 경로 색상 업데이트 함수
      function updateRouteColor(routeId, color) {

        
        // 해당 경로 찾기
        const route = savedUserRoutes.find(r => r.id === routeId);
        if (route) {
          // 메인 경로 색상 업데이트
          if (route.pathElement) {
            route.pathElement.setOptions({
              strokeColor: color
            });
          }
          
          // 점선 효과 색상 업데이트
          if (route.dottedPathElement) {
            const icons = route.dottedPathElement.get('icons');
            if (icons && icons.length > 0) {
              icons[0].icon.fillColor = color;
              route.dottedPathElement.setOptions({
                icons: icons
              });
            }
          }
          

        } else {

        }
      }
      
      // 경로 정보 저장
      async function saveRouteInfo(routeId, routeName) {
        const contentInput = document.getElementById('route-edit-content');
        const linkInput = document.getElementById('route-edit-link');
        const newContent = (contentInput && contentInput.value) || '';
        const newLink = (linkInput && linkInput.value) || '';
        
        // 선택된 색상 가져오기
        const selectedColor = window.selectedRouteColor && window.selectedRouteColor[routeId] !== undefined ? 
                             window.selectedRouteColor[routeId] : 
                             (routeInfoData[routeId] && routeInfoData[routeId].color) || '#3b82f6';
        
        // 동시 수정 방지를 위한 락 획득
        const lockKey = `route_${routeId}`;
        if (!acquireLock(lockKey)) {
          alert('다른 작업이 진행 중입니다. 잠시 후 다시 시도해주세요.');
          return;
        }
        
        try {
          // Firebase에 먼저 저장 (로컬 캐시 로직 단순화)
          if (!window.db || !window.firestore) {
            throw new Error('Firebase 연결이 되지 않았습니다.');
          }
          
          // 임시로 업데이트된 routeInfoData 생성 (원본 수정 없음)
          // 기존 속성(isKmlRoute 등)을 유지하면서 업데이트
          const existingRouteInfo = routeInfoData[routeId] || {};
          const updatedRouteInfoData = { 
            ...routeInfoData, 
            [routeId]: { 
              ...existingRouteInfo,
              content: newContent, 
              link: newLink, 
              color: selectedColor 
            }
          };
          
          const userDocRef = window.firestore.doc(window.db, 'users', 'currentUser');
          await window.firestore.updateDoc(userDocRef, {
            routeInfoData: updatedRouteInfoData,
            lastUpdated: window.firestore.serverTimestamp()
          });
          
          // Firebase 저장 성공 시에만 로컬 캐시 업데이트
          // (즉시 UI 반영용 - 실시간 동기화 보완)
          routeInfoData = routeInfoData || {};
          routeInfoData[routeId] = { 
            ...existingRouteInfo,
            content: newContent, 
            link: newLink, 
            color: selectedColor 
          };
          
          // 편집 다이얼로그 닫기
          const editDialog = document.getElementById('routeEditDialog');
          if (editDialog) {
            editDialog.remove();
          }
          
          // 모든 경로를 다시 그려서 스타일 적용 (KML 경로의 실선 유지)
          drawAllSavedRoutes();
          
          // 저장 후 현재 정보창에 내용 표시로 갱신
          const route = savedUserRoutes.find(r => r.id === routeId) || { id: routeId, name: routeName, path: [] };
          showRouteInfo(route, null);
          
          // 성공 알림

          
        } catch (error) {
          console.error('경로 정보 저장 실패:', error);
          
          // 오프라인 지원 - 실패한 작업을 대기 큐에 추가
          const operationId = addPendingOperation({
            type: OPERATION_TYPES.ROUTE_INFO,
            data: updatedRouteInfoData,
            routeId: routeId,
            routeName: routeName
          });
          
          // 로컬 캐시에는 즉시 반영 (사용자 경험 향상)
          routeInfoData = routeInfoData || {};
          routeInfoData[routeId] = { content: newContent, link: newLink, color: selectedColor };
          
          // 편집 다이얼로그 닫기
          const editDialog = document.getElementById('routeEditDialog');
          if (editDialog) {
            editDialog.remove();
          }
          
          // 경로 색상 즉시 업데이트
          updateRouteColor(routeId, selectedColor);
          
          // 저장 후 현재 정보창에 내용 표시로 갱신
          const route = savedUserRoutes.find(r => r.id === routeId) || { id: routeId, name: routeName, path: [] };
          showRouteInfo(route, null);
          
          // 구체적인 오류 메시지
          let errorMessage = '경로 정보가 임시 저장되었습니다.';
          if (error.message.includes('Firebase') || error.code === 'unavailable') {
            errorMessage = '네트워크 연결 문제로 임시 저장되었습니다. 연결 시 자동으로 동기화됩니다.';
          } else if (error.code === 'permission-denied') {
            errorMessage = '권한 문제로 임시 저장되었습니다. 로그인을 확인해주세요.';
          }
          
          // 성공적인 저장처럼 보이도록 처리

          alert(errorMessage);
          
        } finally {
          // 락 해제
          releaseLock(lockKey);
        }
      }
      // 마커 정보 수정 함수
      function editMarkerInfo(markerGroupName, index) {
        // group id 우선 키 사용 (하위 호환으로 name-index 유지)
        const savedMarkers = window.savedUserMarkers || [];
        const group = savedMarkers.find(g => g && (g.id === markerGroupName || g.name === markerGroupName));
        const idKey = (group && group.id) ? `${group.id}-${index}` : null;
        const nameKey = `${markerGroupName}-${index}`;
        const markerId = idKey || nameKey;
        
        // 현재 저장된 정보 가져오기 또는 기본값 설정 (id 우선, name 대체)
        const baseInfo = (idKey && markerInfoData[idKey]) || markerInfoData[nameKey] || null;
        
        // markerData에서 title 추출 (KML 포인트명 우선)
        const markerData = (group && group.markers && group.markers[index]) ? group.markers[index] : null;
        const defaultTitle = (markerData && markerData.title) || group?.location || markerGroupName;
        
        const currentInfo = baseInfo || {
          title: defaultTitle,
          content: '',
          link: ''
        };
        const currentEmoji = (baseInfo && baseInfo.emoji) ? baseInfo.emoji : '';
        
        // 화면 크기에 따른 다이얼로그 크기 조정
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const isMobileView = viewportWidth <= 768;
        
        // 모바일에서는 더 작은 크기로, 데스크톱에서는 적절한 크기로 조정
        const dialogWidth = isMobileView ? Math.min(280, viewportWidth - 40) : 320;
        const maxWidth = isMobileView ? '90vw' : '400px';
        
        const editInfo = `
          <div style="
            padding: 28px 24px 24px 24px; 
            width: ${dialogWidth}px; 
            max-width: ${maxWidth};
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          ">
            <div style="text-align: center; margin-bottom: 24px; position: relative;">
              <h3 style="color: #000; margin: 0; font-size: 18px; font-weight: 500; letter-spacing: -0.01em;">${group?.location || markerGroupName} - 마커 수정</h3>
              <button type="button" onclick="cancelMarkerEdit('${markerGroupName}', ${index})" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 20px; color: #666; cursor: pointer; padding: 5px; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(0,0,0,0.1)'" onmouseout="this.style.background='none'" title="취소">×</button>
            </div>
            <div style="margin-bottom: 16px;">
              <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center; justify-content: center;">
                <button type="button" onclick="selectEmoji('${markerId}', '')" style="padding:8px 12px; background: ${!currentEmoji ? 'rgba(100, 100, 100, 0.4)' : 'rgba(255, 255, 255, 0.12)'}; border: ${!currentEmoji ? '2px solid rgba(50, 50, 50, 0.6)' : 'none'}; border-radius:8px; cursor:pointer; transition: all 0.2s ease; font-size: 14px; color:#000;">번호</button>
                <button type="button" onclick="selectEmoji('${markerId}', '📍')" style="padding:8px 12px; background: ${currentEmoji === '📍' ? 'rgba(100, 100, 100, 0.4)' : 'rgba(255, 255, 255, 0.12)'}; border: ${currentEmoji === '📍' ? '2px solid rgba(50, 50, 50, 0.6)' : 'none'}; border-radius:8px; cursor:pointer; transition: all 0.2s ease; font-size: 18px;">📍</button>
                <button type="button" onclick="selectEmoji('${markerId}', '📷')" style="padding:8px 12px; background: ${currentEmoji === '📷' ? 'rgba(100, 100, 100, 0.4)' : 'rgba(255, 255, 255, 0.12)'}; border: ${currentEmoji === '📷' ? '2px solid rgba(50, 50, 50, 0.6)' : 'none'}; border-radius:8px; cursor:pointer; transition: all 0.2s ease; font-size: 18px;">📷</button>
                <button type="button" onclick="selectEmoji('${markerId}', '❓')" style="padding:8px 12px; background: ${currentEmoji === '❓' ? 'rgba(100, 100, 100, 0.4)' : 'rgba(255, 255, 255, 0.12)'}; border: ${currentEmoji === '❓' ? '2px solid rgba(50, 50, 50, 0.6)' : 'none'}; border-radius:8px; cursor:pointer; transition: all 0.2s ease; font-size: 18px;">❓</button>
              </div>
            </div>

            <div style="margin-bottom: 16px;">
              <input type="text" id="edit-title-${markerId}" value="${currentInfo.title}" placeholder="제목을 입력하세요"
                     style="width: 100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px);"
                     onfocus="this.style.background='rgba(255, 255, 255, 0.18)'"
                     onblur="this.style.background='rgba(255, 255, 255, 0.12)'"
                     onkeydown="if(event.key === 'Enter') { event.preventDefault(); saveMarkerInfo('${markerGroupName}', ${index}); }">
            </div>

            <div style="margin-bottom: 16px;">
              <input type="text" id="edit-link-${markerId}" value="${currentInfo.link}" placeholder="링크를 입력하세요 (https://...)"
                     style="width: 100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px);"
                     onfocus="this.style.background='rgba(255, 255, 255, 0.18)'"
                     onblur="this.style.background='rgba(255, 255, 255, 0.12)'"
                     onkeydown="if(event.key === 'Enter') { event.preventDefault(); saveMarkerInfo('${markerGroupName}', ${index}); }">
            </div>
            <div style="display: flex; gap: 12px; flex-direction: row;">
              <button onclick="saveMarkerInfo('${markerGroupName}', ${index})" 
                      style="flex: 1; background: rgba(255, 255, 255, 0.12); color: #000; border: none; border-radius: 12px; padding: 14px 16px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px);"
                      onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'"
                      onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'">
                저장
              </button>
              <button onclick="deleteMarkerFromEdit('${markerGroupName}', ${index})" 
                      style="flex: 1; background: rgba(255, 255, 255, 0.12); color: #000; border: none; border-radius: 12px; padding: 14px 16px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px);"
                      onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'"
                      onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'">
                삭제
              </button>
            </div>
          </div>
        `;
        
        // 기존 정보창 닫기
        if (window.currentInfoWindow) {
          window.currentInfoWindow.close();
          window.currentInfoWindow = null;
        }
        
        // 기존 편집 다이얼로그가 있으면 제거
        const existingDialog = document.getElementById('markerEditDialog');
        if (existingDialog) {
          existingDialog.remove();
        }
        
        // 화면 중앙에 편집 다이얼로그 생성
        const dialogDiv = document.createElement('div');
        dialogDiv.id = 'markerEditDialog';
        dialogDiv.style.cssText = `
          position: fixed;
          z-index: 1000;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: ${dialogWidth}px;
          max-width: ${maxWidth};
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.12);
          border-radius: 20px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.12);
          backdrop-filter: blur(24px);
          -webkit-backdrop-filter: blur(24px);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          overflow: hidden;
          transition: all 0.3s ease;
        `;
        
        dialogDiv.innerHTML = editInfo;
        document.body.appendChild(dialogDiv);
        
        // 입력 필드에 포커스
          setTimeout(() => {
            const titleInput = document.getElementById(`edit-title-${markerId}`);
            if (titleInput) {
              titleInput.focus();
              titleInput.select();
            }
          }, 150);
      }
      // 마커 정보 저장 함수
      // 이모지 선택 함수
      function selectEmoji(markerId, emoji) {
        // 선택된 이모지를 전역 변수에 저장
        window.selectedEmoji = window.selectedEmoji || {};
        window.selectedEmoji[markerId] = emoji;
        
        // UI 업데이트 - 모든 이모지 버튼의 배경을 리셋하고 선택된 것만 하이라이트
        const buttons = document.querySelectorAll(`button[onclick*="selectEmoji('${markerId}'"]`);
        buttons.forEach(button => {
          const buttonText = button.textContent.trim();
          const isNumberButton = buttonText === '번호';
          const isSelected = (isNumberButton && emoji === '') || (!isNumberButton && button.onclick.toString().includes(`'${emoji}'`));
          
          if (isSelected) {
            button.style.background = 'rgba(100, 100, 100, 0.4)';
            button.style.border = '2px solid rgba(50, 50, 50, 0.6)';
          } else {
            button.style.background = 'rgba(255, 255, 255, 0.12)';
            button.style.border = 'none';
          }
        });
        
        // 마커 아이콘을 즉시 업데이트
        updateMarkerIcon(markerId, emoji);
      }
      
      // 마커 아이콘 업데이트 함수
      function updateMarkerIcon(markerId, emoji) {
        const savedMarkers = window.savedUserMarkers || [];
        
        // markerId로 해당 마커 찾기
        for (let group of savedMarkers) {
          if (group && group.markerElements) {
            for (let i = 0; i < group.markerElements.length; i++) {
              const currentMarkerId = group.id ? `${group.id}-${i}` : `${group.name}-${i}`;
              if (currentMarkerId === markerId) {
                const marker = group.markerElements[i];
                if (marker) {
                  // 새 아이콘 설정
                  const iconUrl = emoji ? 
                    `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><text x="12" y="20" font-family="Arial, sans-serif" font-size="20" text-anchor="middle">${emoji}</text></svg>`)}` :
                    `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><circle cx="12" cy="12" r="8" fill="#8b5cf6"/><text x="12" y="17" font-family="Arial, sans-serif" font-size="12" fill="white" text-anchor="middle">${i + 1}</text></svg>`)}`;
                  
                  marker.setIcon({
                    url: iconUrl,
                    scaledSize: new google.maps.Size(32, 32),
                    anchor: new google.maps.Point(16, 16)
                  });
                  return;
                }
              }
            }
          }
        }
      }

      async function saveMarkerInfo(markerGroupName, index) {
        // group id 우선 키 사용 (하위 호환으로 name-index 유지)
        const savedMarkers = window.savedUserMarkers || [];
        const group = savedMarkers.find(g => g && (g.id === markerGroupName || g.name === markerGroupName));
        const markerId = (group && group.id) ? `${group.id}-${index}` : `${markerGroupName}-${index}`;
        
        // 입력값 가져오기
        const titleInput = document.getElementById(`edit-title-${markerId}`);
        const linkInput = document.getElementById(`edit-link-${markerId}`);
        
        if (!titleInput || !linkInput) {
          alert('입력 필드를 찾을 수 없습니다.');
          return;
        }
        
        // 선택된 이모지 가져오기
        const selectedEmoji = window.selectedEmoji && window.selectedEmoji[markerId] !== undefined ? 
                             window.selectedEmoji[markerId] : 
                             (markerInfoData[markerId] && markerInfoData[markerId].emoji) || '';
        
        const newInfo = {
          title: titleInput.value.trim() || group?.location || markerGroupName,
          content: '',
          link: linkInput.value.trim(),
          emoji: selectedEmoji
        };
        
        // 동시 수정 방지를 위한 락 획득
        const lockKey = `marker_${markerId}`;
        if (!acquireLock(lockKey)) {
          alert('다른 작업이 진행 중입니다. 잠시 후 다시 시도해주세요.');
          return;
        }
        
        try {
          // Firebase에 먼저 저장 (로컬 캐시 로직 단순화)
          if (!window.db || !window.firestore) {
            throw new Error('Firebase가 초기화되지 않았습니다.');
          }
          
          // 임시로 업데이트된 markerInfoData 생성 (원본 수정 없음)
          const updatedMarkerInfoData = { ...markerInfoData, [markerId]: newInfo };
          

          const userDocRef = window.firestore.doc(window.db, 'users', 'currentUser');
          await window.firestore.updateDoc(userDocRef, {
            markerInfoData: updatedMarkerInfoData,
            lastUpdated: window.firestore.serverTimestamp()
          });
          
          // Firebase 저장 성공 시에만 로컬 캐시 업데이트
          // (즉시 UI 반영용 - 실시간 동기화 보완)
          markerInfoData[markerId] = newInfo;

          
          // 성공 메시지

          onFirebaseUploadSuccess('마커 정보');
          
          // 편집 다이얼로그 닫기
          const editDialog = document.getElementById('markerEditDialog');
          if (editDialog) {
            editDialog.remove();
          }
          
          // 정보창을 일반 보기 모드로 되돌리기
          showMarkerInfoWithData(markerGroupName, index);

          // 저장 직후 지도상의 마커 라벨/아이콘 즉시 갱신
          try {
            const savedMarkers = window.savedUserMarkers || [];
            const group = savedMarkers.find(g => g && (g.id === markerGroupName || g.name === markerGroupName));
            if (group && group.markerElements && group.markerElements[index]) {
              const markerEl = group.markerElements[index];
              
              // 마커 타이틀 라벨 업데이트
              if (markerEl.updateTitleLabel) {
                markerEl.updateTitleLabel(newInfo.title);
              }
              
              if (newInfo.emoji) {
                markerEl.setIcon({
                  path: google.maps.SymbolPath.CIRCLE,
                  fillColor: 'transparent',
                  fillOpacity: 0,
                  strokeColor: 'transparent',
                  strokeWeight: 0,
                  scale: 12
                });
                markerEl.setLabel({
                  text: newInfo.emoji,
                  fontSize: '20px',
                  fontWeight: 'bold'
                });
              } else {
                markerEl.setIcon({
                  path: google.maps.SymbolPath.CIRCLE,
                  fillColor: '#8b5cf6',
                  fillOpacity: 1,
                  strokeColor: '#ffffff',
                  strokeWeight: 1,
                  scale: 12
                });
                markerEl.setLabel({
                  text: (index + 1).toString(),
                  fontSize: '18px',
                  fontWeight: 'bold',
                  color: '#ffffff'
                });
              }
            }
          } catch (_) {}
          
        } catch (error) {
          console.error('마커 정보 저장 실패:', error);
          console.error('Error details:', {
            code: error.code,
            message: error.message,
            stack: error.stack
          });
          
          // 오프라인 지원 - 실패한 작업을 대기 큐에 추가
          const operationId = addPendingOperation({
            type: OPERATION_TYPES.MARKER_INFO,
            data: updatedMarkerInfoData,
            markerId: markerId,
            markerGroupName: markerGroupName,
            index: index
          });
          
          // 로컬 캐시에는 즉시 반영 (사용자 경험 향상)
          markerInfoData[markerId] = newInfo;
          
          // 편집 다이얼로그 닫기
          const editDialog = document.getElementById('markerEditDialog');
          if (editDialog) {
            editDialog.remove();
          }
          
          // 정보창을 일반 보기 모드로 되돌리기 (로컬 데이터로)
          showMarkerInfoWithData(markerGroupName, index);
          
          // 구체적인 오류 메시지
          let errorMessage = '마커 정보가 임시 저장되었습니다.';
          if (error.message.includes('Firebase') || error.code === 'unavailable') {
            errorMessage = '네트워크 연결 문제로 임시 저장되었습니다. 연결 시 자동으로 동기화됩니다.';
          } else if (error.code === 'permission-denied') {
            errorMessage = '권한 문제로 임시 저장되었습니다. 로그인을 확인해주세요.';
          } else if (error.code === 'quota-exceeded') {
            errorMessage = 'Firebase 사용량 초과로 임시 저장되었습니다. 관리자에게 문의해주세요.';
          }
          
          // 성공적인 저장처럼 보이도록 처리
          alert(errorMessage);
          
        } finally {
          // 락 해제
          releaseLock(lockKey);
        }
      }
      
      // 마커 수정 취소 함수
      function cancelMarkerEdit(markerGroupName, index) {
        // 편집 다이얼로그 닫기
        const editDialog = document.getElementById('markerEditDialog');
        if (editDialog) {
          editDialog.remove();
        }
        
        // 정보창을 일반 보기 모드로 되돌리기
        showMarkerInfoWithData(markerGroupName, index);
      }
      
      // 경로 수정 취소 함수
      function cancelRouteEdit(routeId, routeName) {
        // 편집 다이얼로그 닫기
        const editDialog = document.getElementById('routeEditDialog');
        if (editDialog) {
          editDialog.remove();
        }
        
        // 정보창을 일반 보기 모드로 되돌리기
        const route = savedUserRoutes.find(r => r.id === routeId) || { id: routeId, name: routeName, path: [] };
        showRouteInfo(route, null);
      }
      // 편집 모드에서 마커 삭제 함수
      async function deleteMarkerFromEdit(markerGroupName, index) {
        if (!confirm('이 마커를 삭제하시겠습니까?')) {
          return;
        }
        
        
        try {
          // 정보창과 편집 다이얼로그 닫기
          if (window.currentInfoWindow) {
            window.currentInfoWindow.close();
            window.currentInfoWindow = null;
          }
          
          const editDialog = document.getElementById('markerEditDialog');
          if (editDialog) {
            editDialog.remove();
          }
          
          // 저장된 마커들에서 해당 마커 그룹 찾기
          const savedMarkers = window.savedUserMarkers || [];
          const markerGroupIndex = savedMarkers.findIndex(group => (group.id === markerGroupName || group.name === markerGroupName));
          
          if (markerGroupIndex === -1) {
            alert('마커를 찾을 수 없습니다.');
            return;
          }
          
          const markerGroup = savedMarkers[markerGroupIndex];
          
          // 해당 인덱스의 마커만 삭제
          if (markerGroup.markerElements && markerGroup.markerElements[index]) {
            
            // 지도에서 마커 제거 (즉시 피드백을 위해)
            markerGroup.markerElements[index].setMap(null);
            
            
            // Firebase 저장용 데이터 생성 (로컬 데이터는 실시간 동기화로만 업데이트)
            const updatedMarkers = [...savedMarkers];
            const updatedMarkerGroup = { ...updatedMarkers[markerGroupIndex] };
            
            // 마커 그룹 복사본에서 삭제 처리
            if (updatedMarkerGroup.markerElements) {
              updatedMarkerGroup.markerElements = [...updatedMarkerGroup.markerElements];
              updatedMarkerGroup.markerElements.splice(index, 1);
            }
            if (updatedMarkerGroup.locations) {
              updatedMarkerGroup.locations = [...updatedMarkerGroup.locations];
              updatedMarkerGroup.locations.splice(index, 1);
            }
            if (updatedMarkerGroup.markers) {
              updatedMarkerGroup.markers = [...updatedMarkerGroup.markers];
              updatedMarkerGroup.markers.splice(index, 1);
            }
            
            // 마커 정보 데이터 복사본 생성
            const updatedMarkerInfoData = { ...markerInfoData };
            const groupForId = (window.savedUserMarkers || []).find(g => g && (g.id === markerGroupName || g.name === markerGroupName));
            const markerId = (groupForId && groupForId.id) ? `${groupForId.id}-${index}` : `${markerGroupName}-${index}`;
            delete updatedMarkerInfoData[markerId];
            
            // 인덱스 재정렬
            const remainingCount = updatedMarkerGroup.markers?.length || updatedMarkerGroup.locations?.length || 0;
            for (let i = index; i < remainingCount; i++) {
              const oldKey = (groupForId && groupForId.id) ? `${groupForId.id}-${i + 1}` : `${markerGroupName}-${i + 1}`;
              const newKey = (groupForId && groupForId.id) ? `${groupForId.id}-${i}` : `${markerGroupName}-${i}`;
              if (updatedMarkerInfoData[oldKey]) {
                updatedMarkerInfoData[newKey] = updatedMarkerInfoData[oldKey];
                delete updatedMarkerInfoData[oldKey];
              }
            }
            
            // 마커 그룹이 비어있으면 전체 삭제
            const isEmpty = (updatedMarkerGroup.markers?.length || 0) === 0 && 
                           (updatedMarkerGroup.locations?.length || 0) === 0;
            if (isEmpty) {
              updatedMarkers.splice(markerGroupIndex, 1);
            } else {
              updatedMarkers[markerGroupIndex] = updatedMarkerGroup;
            }
            
            // Firebase에 업데이트 (직렬화 가능한 데이터만 전송)
            if (window.db && window.firestore) {
              
              const userDocRef = window.firestore.doc(window.db, 'users', 'currentUser');
              const sanitizedSavedUserMarkers = sanitizeSavedUserMarkersForFirestore(updatedMarkers);
              await window.firestore.updateDoc(userDocRef, {
                savedUserMarkers: sanitizedSavedUserMarkers,
                markerInfoData: updatedMarkerInfoData,
                lastUpdated: window.firestore.serverTimestamp()
              });
              
            
            // UI 업데이트는 실시간 동기화를 통해 처리되므로 여기서는 하지 않음

            } else {
              console.warn('Firebase가 초기화되지 않았습니다 - 마커 삭제가 저장되지 않음');
              alert('Firebase 연결이 되지 않았습니다. 마커 삭제가 저장되지 않을 수 있습니다.');
            }
            
          } else {
            alert('삭제할 마커를 찾을 수 없습니다.');
          }
          
        } catch (error) {
          console.error('마커 삭제 실패:', error);
          alert('마커 삭제에 실패했습니다. 다시 시도해주세요.');
        }
      }
      
      // 정보창 닫기 함수
      function closeInfoWindow() {
        if (window.currentInfoWindow) {
          window.currentInfoWindow.close();
          window.currentInfoWindow = null;
          // 추적 변수 초기화
          window.currentOpenMarkerGroup = null;
          window.currentOpenMarkerIndex = null;
          window.currentOpenRouteId = null;
        }
        
        // 마커 정보창 스와이프 상태 초기화
        const markerInfoContainer = document.querySelector('.marker-info-container');
        if (markerInfoContainer) {
          markerInfoContainer.classList.remove('swiped');
          const content = markerInfoContainer.querySelector('.marker-info-content');
          if (content) {
            content.style.width = '100%';
          }
        }
        
        // 외부 클릭 이벤트 리스너 정리
        if (window.markerInfoOutsideClickHandler) {
          document.removeEventListener('click', window.markerInfoOutsideClickHandler);
          window.markerInfoOutsideClickHandler = null;
        }
        
        if (window.routeInfoOutsideClickHandler) {
          document.removeEventListener('click', window.routeInfoOutsideClickHandler);
          window.routeInfoOutsideClickHandler = null;
        }
        
        // 경로 정보창 스와이프 상태 초기화
        const routeInfoContainer = document.querySelector('.route-info-container');
        if (routeInfoContainer) {
          routeInfoContainer.classList.remove('swiped');
          const content = routeInfoContainer.querySelector('.route-info-content');
          if (content) {
            content.style.width = '100%';
          }
        }
      }
      
      // 저장된 정보로 마커 정보창 표시
      function showMarkerInfoWithData(markerGroupName, index) {
        // 현재 열린 마커 정보 추적
        window.currentOpenMarkerGroup = markerGroupName;
        window.currentOpenMarkerIndex = index;
        
        // group id 우선 키 사용 (id 또는 name으로 탐색)
        const savedMarkers = window.savedUserMarkers || [];
        const group = savedMarkers.find(g => g && (g.id === markerGroupName || g.name === markerGroupName));
        const markerId = (group && group.id) ? `${group.id}-${index}` : `${markerGroupName}-${index}`;
        
        // markerData에서 title 추출 (KML 포인트명 우선)
        const markerData = (group && group.markers && group.markers[index]) ? group.markers[index] : null;
        const defaultTitle = (markerData && markerData.title) || group?.location || markerGroupName;
        
        const savedInfo = markerInfoData[markerId] || {
          title: defaultTitle,
          content: '',
          link: ''
        };
        
        // 제목과 링크 처리
        let titleDisplay = savedInfo.title;
          if (savedInfo.link && savedInfo.link.trim()) {
          // 링크가 있으면 제목에 링크 연결
            const validLink = savedInfo.link.startsWith('http') ? savedInfo.link : `https://${savedInfo.link}`;
          titleDisplay = `<span onclick="openUserItemLink('${validLink}')" 
                    style="color: #8b5cf6; text-decoration: none; cursor: pointer; border-bottom: 1px dotted #3b82f6;"
                    onmouseover="this.style.color='#3b82f6'; this.style.textDecoration='underline';"
                    onmouseout="this.style.color='#8b5cf6'; this.style.textDecoration='none';">${savedInfo.title}</span>`;
        }
        
        const info = `
          <div class="marker-info-container" style="padding: 8px; min-width: 160px; position: relative;">
            <div class="marker-info-content" style="display: flex; align-items: center; justify-content: flex-start; width: 100%;">
              <h4 style="margin: 0; font-size: 14px; font-weight: bold; flex: 1; padding: 4px 8px; border-radius: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${titleDisplay}</h4>
            </div>
            <button class="marker-swipe-edit-btn" onclick="editMarkerInfo('${markerGroupName}', ${index})" title="편집">편집</button>
          </div>
        `;
        
        if (window.currentInfoWindow) {
          window.currentInfoWindow.setContent(info);
        } else {
          // 새 정보창 생성
          window.currentInfoWindow = new google.maps.InfoWindow({
            content: info,
            disableAutoPan: false,
            maxWidth: 200,
            pixelOffset: new google.maps.Size(0, 0) // 마커 상단에 더 명확하게 표시
          });
        }
        
        // X 버튼 제거를 위한 스타일 추가 및 스와이프 이벤트 설정
        google.maps.event.addListener(window.currentInfoWindow, 'domready', function() {
          const closeBtn = document.querySelector('.gm-ui-hover-effect');
          if (closeBtn) {
            closeBtn.style.display = 'none';
          }
          
          // 마커 정보창 스와이프 이벤트 설정
          setupMarkerInfoSwipeEvents();
          
          // 정보창 외부 클릭으로 닫기 기능 추가
          setTimeout(() => {
            const infoWindowElement = document.querySelector('.gm-style-iw-c');
            if (infoWindowElement) {
              // 정보창 외부 클릭 감지를 위한 이벤트 리스너
              window.markerInfoOutsideClickHandler = function(event) {
                if (!infoWindowElement.contains(event.target)) {
                  closeInfoWindow();
                }
              };
              
              // 약간의 지연 후 이벤트 리스너 추가 (정보창이 완전히 렌더링된 후)
              setTimeout(() => {
                document.addEventListener('click', window.markerInfoOutsideClickHandler);
              }, 100);
            }
          }, 200);
        });
        

      }
      
      // 마커 정보창 스와이프 이벤트 설정 함수
      function setupMarkerInfoSwipeEvents() {
        const markerInfoContainer = document.querySelector('.marker-info-container');
        if (!markerInfoContainer) return;
        
        let startX = 0;
        let startY = 0;
        let startTime = 0;
        let hasSwiped = false;
        
        // 동적 내용 컨테이너 너비 계산 함수
        function calculateContentWidth() {
          const content = markerInfoContainer.querySelector('.marker-info-content');
          const title = content.querySelector('h4');
          const editBtn = markerInfoContainer.querySelector('.marker-swipe-edit-btn');
          
          // 편집 버튼의 너비 (60px + padding + margin)
          const editBtnWidth = 80;
          
          // 컨테이너의 현재 너비
          const containerWidth = markerInfoContainer.offsetWidth;
          
          // 내용 컨테이너의 최대 너비 = 컨테이너 너비 - 편집 버튼 너비 - 여백
          const maxContentWidth = containerWidth - editBtnWidth - 16; // 16px 여백
          
          return maxContentWidth;
        }
        
        // 터치 시작 이벤트
        markerInfoContainer.addEventListener('touchstart', function(e) {
          // 편집 버튼이나 닫기 버튼을 터치한 경우에는 스와이프 방지
          if (e.target.classList.contains('marker-swipe-edit-btn') ||
              e.target.tagName === 'BUTTON') {
            return;
          }
          
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          startTime = Date.now();
          hasSwiped = false;
        }, { passive: true });
        
        // 터치 이동 이벤트
        markerInfoContainer.addEventListener('touchmove', function(e) {
          if (!startX || !startY) return;
          
          const currentX = e.touches[0].clientX;
          const currentY = e.touches[0].clientY;
          const diffX = startX - currentX;
          const diffY = Math.abs(startY - currentY);
          
          // 수직 스크롤보다 수평 스와이프가 더 큰 경우에만 처리
          if (Math.abs(diffX) > diffY && Math.abs(diffX) > 10) {
            e.preventDefault();
            hasSwiped = true;
            
            // 동적 내용 컨테이너 너비 계산
            const maxContentWidth = calculateContentWidth();
            
            // 스와이프 진행 중 시각적 피드백 - 내용 컨테이너 너비 조정
            const progress = Math.min(Math.abs(diffX) / 80, 1);
            const contentWidth = maxContentWidth * (1 - progress * 0.3); // 최대 30% 축소
            markerInfoContainer.querySelector('.marker-info-content').style.width = `${contentWidth}px`;
          }
        }, { passive: false });
        
        // 터치 종료 이벤트
        markerInfoContainer.addEventListener('touchend', function(e) {
          if (!hasSwiped) return;
          
          const endTime = Date.now();
          const diffTime = endTime - startTime;
          const currentX = e.changedTouches[0].clientX;
          const diffX = startX - currentX;
          
          // 스와이프 완료 조건: 30px 이상 이동, 1초 이내, 수평 이동
          if (diffX > 30 && diffTime < 1000) {
            // 스와이프 완료 - 편집 버튼 표시
            markerInfoContainer.classList.add('swiped');
            const maxContentWidth = calculateContentWidth();
            markerInfoContainer.style.setProperty('--content-width', `${maxContentWidth}px`);
          } else {
            // 스와이프 취소 - 원래 위치로 복원
            markerInfoContainer.classList.remove('swiped');
            markerInfoContainer.querySelector('.marker-info-content').style.width = '100%';
          }
          
          // 변수 초기화
          startX = 0;
          startY = 0;
          startTime = 0;
          hasSwiped = false;
        }, { passive: true });
        
        // 클릭 시 스와이프 상태 해제
        markerInfoContainer.addEventListener('click', function(e) {
          // 편집 버튼 클릭이 아닌 경우에만 스와이프 해제
          if (!e.target.classList.contains('marker-swipe-edit-btn')) {
            markerInfoContainer.classList.remove('swiped');
            markerInfoContainer.querySelector('.marker-info-content').style.width = '100%';
          }
          
          // 편집 버튼 클릭이 아닌 경우에만 이벤트 전파 방지
          // 편집 버튼 클릭 시에는 이벤트가 전파되어야 함
          if (!e.target.classList.contains('marker-swipe-edit-btn')) {
            e.stopPropagation();
          }
        });
        
        // 모바일에서만 마우스 드래그 이벤트 활성화
        if (window.innerWidth <= 768) {
          let isDragging = false;
          let dragStartX = 0;
          
          markerInfoContainer.addEventListener('mousedown', function(e) {
            // 편집 버튼이나 닫기 버튼을 클릭한 경우에는 드래그 방지
            if (e.target.classList.contains('marker-swipe-edit-btn') ||
                e.target.tagName === 'BUTTON') {
              return;
            }
            
            if (e.button !== 0) return; // 왼쪽 버튼만
            
            isDragging = true;
            dragStartX = e.clientX;
          });
          
          markerInfoContainer.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            const diffX = dragStartX - e.clientX;
            
            if (Math.abs(diffX) > 3) {
              // 동적 내용 컨테이너 너비 계산
              const maxContentWidth = calculateContentWidth();
              
              // 드래그 진행 중 시각적 피드백 - 내용 컨테이너 너비 조정
              const progress = Math.min(Math.abs(diffX) / 80, 1);
              const contentWidth = maxContentWidth * (1 - progress * 0.3); // 최대 30% 축소
              markerInfoContainer.querySelector('.marker-info-content').style.width = `${contentWidth}px`;
            }
          });
          
          markerInfoContainer.addEventListener('mouseup', function(e) {
            if (!isDragging) return;
            
            const diffX = dragStartX - e.clientX;
            
            if (diffX > 20) {
              // 드래그 완료 - 편집 버튼 표시
              markerInfoContainer.classList.add('swiped');
              const maxContentWidth = calculateContentWidth();
              markerInfoContainer.style.setProperty('--content-width', `${maxContentWidth}px`);
            } else {
              // 드래그 취소 - 원래 위치로 복원
              markerInfoContainer.classList.remove('swiped');
              markerInfoContainer.querySelector('.marker-info-content').style.width = '100%';
            }
            
            isDragging = false;
            dragStartX = 0;
          });
          
          // 마우스가 컨테이너를 벗어날 때 드래그 상태 해제
          markerInfoContainer.addEventListener('mouseleave', function() {
            if (isDragging) {
              markerInfoContainer.classList.remove('swiped');
              markerInfoContainer.querySelector('.marker-info-content').style.width = '100%';
              isDragging = false;
              dragStartX = 0;
            }
          });
        }
      }
      
      // 저장된 모든 경로 그리기
      function drawAllSavedRoutes() {
        // 기존 경로들 제거
        savedUserRoutes.forEach(route => {
          if (route.pathElement) {
            route.pathElement.setMap(null);
          }
          if (route.dottedPathElement) {
            route.dottedPathElement.setMap(null);
          }
        });
        
        // 디버깅: routeInfoData 상태 확인
        console.log('[drawAllSavedRoutes] routeInfoData:', routeInfoData);
        console.log('[drawAllSavedRoutes] savedUserRoutes count:', savedUserRoutes.length);
        
        // 저장된 경로들 다시 그리기
        savedUserRoutes.forEach(route => {
          if (route.path && route.path.length >= 2) {
            const path = route.path.map(point => new google.maps.LatLng(point.lat, point.lng));
            
            // 저장된 경로 정보 가져오기
            const routeInfo = (routeInfoData && routeInfoData[route.id]) || {};
            const routeColor = routeInfo.color || '#3b82f6';
            const isKmlRoute = routeInfo.isKmlRoute || false;
            
            // 디버깅: 각 경로의 스타일 정보 출력
            console.log(`[Route ${route.id}] isKmlRoute:`, isKmlRoute, 'routeInfo:', routeInfo);
            
            // KML 경로는 저장된 스타일 사용, 일반 경로는 기존 스타일 유지
            const strokeWeight = isKmlRoute ? (routeInfo.strokeWeight || 2.0) : 2;
            const strokeOpacity = isKmlRoute ? (routeInfo.strokeOpacity || 0.8) : 0.1;
            
            // 메인 경로
            route.pathElement = new google.maps.Polyline({
              path: path,
              geodesic: true,
              strokeColor: routeColor,
              strokeOpacity: strokeOpacity,
              strokeWeight: strokeWeight,
              zIndex: 10 // 라벨 아래에 표시
            });
            route.pathElement.setMap(map);
            
            // 경로 클릭 이벤트 추가
            route.pathElement.addListener('click', function(event) {
              // 메뉴창 닫기
              const customMapMenu = getElement('customMapMenu');
              const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
              
              if (!customMapMenu.classList.contains('hide')) {
                hideMenu();
              }
              if (rightPanelOpen) {
                hideRightMenu();
              }
              
              if (isRouteMode) { addUserRoutePoint(event.latLng); return; }
              if (isMarkerMode) { addCustomMarker(event.latLng); return; }
              showRouteInfo(route, event.latLng);
            });
            
            // KML 경로가 아닌 경우에만 점선 효과 추가
            if (!isKmlRoute) {
              route.dottedPathElement = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: '#ffffff',
                strokeOpacity: 0.1,
                strokeWeight: 1,
                zIndex: 15, // 메인 경로보다는 위에, 라벨보다는 아래
                icons: [{
                  icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: routeColor,
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 1,
                    scale: 6
                  },
                  offset: '0',
                  repeat: '15px'
                }]
              });
              route.dottedPathElement.setMap(map);
              
              // 점선 경로에도 클릭 이벤트 추가
              route.dottedPathElement.addListener('click', function(event) {
                // 메뉴창 닫기
                const customMapMenu = getElement('customMapMenu');
                const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
                
                if (!customMapMenu.classList.contains('hide')) {
                  hideMenu();
                }
                if (rightPanelOpen) {
                  hideRightMenu();
                }
                
                if (isRouteMode) { addUserRoutePoint(event.latLng); return; }
                if (isMarkerMode) { addCustomMarker(event.latLng); return; }
                showRouteInfo(route, event.latLng);
              });
            }
          }
        });
      }

      // 현재 지도에 그려진 모든 경로 요소를 제거 (실시간 동기화용)
      function clearAllRenderedRoutes() {
        try {
          (savedUserRoutes || []).forEach(function(route) {
            if (route && route.pathElement) {
              route.pathElement.setMap(null);
            }
            if (route && route.dottedPathElement) {
              route.dottedPathElement.setMap(null);
            }
          });
        } catch (e) {
          console.warn('경로 요소 제거 중 경고:', e);
        }
      }
             // 저장된 사용자 경로들 복원
       async function restoreSavedUserRoutes() {
         try {
           // Firebase에서 복원 시도
           const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
           if (docSnap.exists()) {
             const data = docSnap.data();
             
             // routeInfoData 먼저 복원 (경로 스타일 정보 포함)
             if (data.routeInfoData) {
               routeInfoData = data.routeInfoData;
             }
             
             if (data.savedUserRoutes && data.savedUserRoutes.length > 0) {
               savedUserRoutes = data.savedUserRoutes;
               drawAllSavedRoutes();
               // 경로제거 버튼 상태 업데이트
               updateRouteRemoveButtons();
               // 마커제거 버튼 상태 업데이트
               updateMarkerRemoveButtons();
               return;
             }
           }
         } catch (error) {
           handleError(error, 'Firebase 로드');
         }
       }
       
       // 저장된 사용자 마커들 복원
       async function restoreSavedUserMarkers() {
         try {
           // Firebase에서 복원 시도
           const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
           if (docSnap.exists()) {
             const data = docSnap.data();
             // 마커 정보 데이터(이모지 포함)를 먼저 복원한 뒤 마커를 그린다
             if (data.markerInfoData) {
               markerInfoData = data.markerInfoData;
             }
             if (data.savedUserMarkers && data.savedUserMarkers.length > 0) {
               window.savedUserMarkers = data.savedUserMarkers;
               drawAllSavedMarkers();
             }
             
             if (data.savedUserMarkers && data.savedUserMarkers.length > 0) {
               return;
             }
           }
         } catch (error) {
           console.error('Firebase 마커 로드 실패:', error);
         }
       }
       
       // 특정 위치의 경로를 제거하는 함수
       async function removeRoutesByLocation(location) {
         // 동기화 중이면 무시
         if (isSyncing) {
           updateSyncStatus('동기화 중입니다. 잠시 후 다시 시도해주세요', 'warning');
           return;
         }
         
         // 해당 위치의 경로가 있는지 확인
         const locationRoutes = savedUserRoutes.filter(route => route.location === location);
         
         if (locationRoutes.length === 0) {
           alert(`${location}에 저장된 경로가 없습니다.`);
           return;
         }
         
         // 사용자 확인
         if (!confirm(`${location}에 저장된 경로 ${locationRoutes.length}개를 모두 제거하시겠습니까?`)) {
           return;
         }
         
         try {
           // 동기화 상태 설정
           isSyncing = true;
           updateSyncStatus('경로 제거 중...', 'info');
           
           // 해당 위치의 경로들만 제거
           locationRoutes.forEach(route => {
             if (route.pathElement) {
               route.pathElement.setMap(null);
             }
             if (route.dottedPathElement) {
               route.dottedPathElement.setMap(null);
             }
           });
           
           // 배열에서 해당 위치 경로들 제거
           const updatedRoutes = savedUserRoutes.filter(route => route.location !== location);
           
           // routeInfoData에서 해당 위치의 경로 정보 키 제거
           const updatedRouteInfoData = { ...routeInfoData };
           locationRoutes.forEach(function(route) {
             if (route && route.id && updatedRouteInfoData[route.id]) {
               delete updatedRouteInfoData[route.id];
             }
           });
           
           // Firestore에 저장하기 전에 UI 전용 필드 제거
           const sanitizedRoutes = sanitizeRoutesForFirestore(updatedRoutes);
           
           // Firebase에서 해당 위치 경로들 제거
           await window.firestore.updateDoc(window.firestore.doc(window.db, 'users', 'currentUser'), {
             savedUserRoutes: sanitizedRoutes,
             routeInfoData: updatedRouteInfoData,
             lastUpdated: window.firestore.serverTimestamp()
           });
           
           // 전역 변수 업데이트
           savedUserRoutes = updatedRoutes;
           routeInfoData = updatedRouteInfoData;
           
           // UI 즉시 업데이트
           drawAllSavedRoutes();
           updateRouteRemoveButtons();
           
           updateSyncStatus('경로 제거 완료', 'success');
           
           // 성공 메시지
           alert(`${location} 경로 ${locationRoutes.length}개가 제거되었습니다.`);
           
           // 정보창 닫기
           closePreparationInfo();
           
         } catch (error) {
           console.error('Firebase 업데이트 실패:', error);
           updateSyncStatus('경로 제거 실패', 'error');
           
           // Firebase 실패 시 UI만 업데이트
           const updatedRoutes = savedUserRoutes.filter(route => route.location !== location);
           
           // routeInfoData에서도 해당 키들을 제거
           const fallbackRouteInfoData = { ...routeInfoData };
           locationRoutes.forEach(function(route) {
             if (route && route.id && fallbackRouteInfoData[route.id]) {
               delete fallbackRouteInfoData[route.id];
             }
           });
           
           savedUserRoutes = updatedRoutes;
           routeInfoData = fallbackRouteInfoData;
           drawAllSavedRoutes();
           updateRouteRemoveButtons();
           
           setTimeout(() => {
             updateSyncStatus('Firebase 연결 실패', 'error');
           }, 2000);
           
           alert('Firebase 업데이트에 실패했습니다. 로컬에만 반영되었습니다.');
         } finally {
           // 동기화 상태 해제 (즉시 해제하여 실시간 동기화 허용)
           isSyncing = false;
         }
       }
       
       // 특정 위치의 마커를 제거하는 함수
       async function removeMarkersByLocation(location) {
         // 동기화 중이면 무시
         if (isSyncing) {
           updateSyncStatus('동기화 중입니다. 잠시 후 다시 시도해주세요', 'warning');
           return;
         }
         
         // 해당 위치의 마커가 있는지 확인
         const locationMarkers = (window.savedUserMarkers || []).filter(marker => marker.location === location);
         
         if (locationMarkers.length === 0) {
           alert(`${location}에 저장된 마커가 없습니다.`);
           return;
         }
         
         // 사용자 확인
         if (!confirm(`${location}에 저장된 마커 ${locationMarkers.length}개를 모두 제거하시겠습니까?`)) {
           return;
         }
         
         try {
           // 동기화 상태 설정
           isSyncing = true;
           updateSyncStatus('마커 제거 중...', 'info');
           
           // 해당 위치의 마커들만 제거
           locationMarkers.forEach(markerGroup => {
             if (markerGroup.markerElements) {
               markerGroup.markerElements.forEach(marker => {
                 marker.setMap(null);
               });
             }
           });
           
           // 배열에서 해당 위치 마커들 제거
           const updatedMarkers = (window.savedUserMarkers || []).filter(marker => marker.location !== location);
           
           // markerInfoData에서 해당 위치의 마커 정보 키 제거
           const updatedMarkerInfoData = { ...markerInfoData };
           locationMarkers.forEach(function(group) {
             const groupName = (group && group.name) ? group.name : ((group && group.location) ? (group.location + ' 마커') : '');
             const count = Array.isArray(group && group.markers) ? group.markers.length : 0;
             for (let i = 0; i < count; i++) {
               const key = (group && group.id) ? `${group.id}-${i}` : `${groupName}-${i}`;
               if (updatedMarkerInfoData[key]) {
                 delete updatedMarkerInfoData[key];
               }
             }
           });
           
           // Firebase에서 해당 위치 마커들 제거 (직렬화 가능한 데이터만 전송)
           const sanitizedForDeleteByLocation = sanitizeSavedUserMarkersForFirestore(updatedMarkers);
           await window.firestore.updateDoc(window.firestore.doc(window.db, 'users', 'currentUser'), {
             savedUserMarkers: sanitizedForDeleteByLocation,
             markerInfoData: updatedMarkerInfoData,
             lastUpdated: window.firestore.serverTimestamp()
           });
           
           // 전역 변수 업데이트
           window.savedUserMarkers = updatedMarkers;
           markerInfoData = updatedMarkerInfoData;
           
           // UI 즉시 업데이트
           clearAllRenderedMarkers();
           drawAllSavedMarkers();
           updateRouteRemoveButtons();
           
           updateSyncStatus('마커 제거 완료', 'success');
           
           // 성공 메시지
           alert(`${location} 마커 ${locationMarkers.length}개가 제거되었습니다.`);
           
           // 정보창 닫기
           closePreparationInfo();
           
         } catch (error) {
           console.error('Firebase 업데이트 실패:', error);
           updateSyncStatus('마커 제거 실패', 'error');
           
           // Firebase 실패 시 UI만 업데이트
           const updatedMarkers = (window.savedUserMarkers || []).filter(marker => marker.location !== location);
           // markerInfoData에서도 해당 키들을 제거
           const fallbackMarkerInfoData = { ...markerInfoData };
           locationMarkers.forEach(function(group) {
             const groupName = (group && group.name) ? group.name : ((group && group.location) ? (group.location + ' 마커') : '');
             const count = Array.isArray(group && group.markers) ? group.markers.length : 0;
             for (let i = 0; i < count; i++) {
               const key = (group && group.id) ? `${group.id}-${i}` : `${groupName}-${i}`;
               if (fallbackMarkerInfoData[key]) {
                 delete fallbackMarkerInfoData[key];
               }
             }
           });
           window.savedUserMarkers = updatedMarkers;
           markerInfoData = fallbackMarkerInfoData;
           clearAllRenderedMarkers();
           drawAllSavedMarkers();
           updateRouteRemoveButtons();
           
           setTimeout(() => {
             updateSyncStatus('Firebase 연결 실패', 'error');
           }, 2000);
           
           alert('Firebase 업데이트에 실패했습니다. 로컬에만 반영되었습니다.');
         } finally {
           // 동기화 상태 해제 (즉시 해제하여 실시간 동기화 허용)
           isSyncing = false;
         }
       }
       
       // 경로/마커 제거 버튼들을 동적으로 표시/숨김하는 함수
       function updateRouteRemoveButtons() {
         // 현재 활성 섹션의 경로/마커 제거 버튼 업데이트
         const currentSection = window.currentActiveSection || '';
         if (currentSection) {
           const currentRoutes = savedUserRoutes.filter(route => route.location === currentSection);
           const currentMarkers = (window.savedUserMarkers || []).filter(marker => marker.location === currentSection);
           
           // 현재 섹션의 removeButtons 요소 찾기 (동적으로 생성된 일정들)
           const removeButtonsId = currentSection.replace(/[^a-zA-Z0-9가-힣]/g, '') + 'RemoveButtons';
           const removeButtons = document.getElementById(removeButtonsId);
           if (removeButtons) {
             const hasRoutes = currentRoutes.length > 0;
             const hasMarkers = currentMarkers.length > 0;
             
             // 현재 섹션의 removeButtons 요소 찾기 (동적으로 생성된 일정들)
             const removeButtonsId = currentSection.replace(/[^a-zA-Z0-9가-힣]/g, '') + 'RemoveButtons';
             const removeButtons = document.getElementById(removeButtonsId);
             if (removeButtons) {
               const hasRoutes = currentRoutes.length > 0;
               const hasMarkers = currentMarkers.length > 0;
               
               // 경로나 마커가 하나라도 있으면 버튼 컨테이너 표시
               removeButtons.style.display = (hasRoutes || hasMarkers) ? 'block' : 'none';
               
               // 각 버튼의 상태에 따라 투명도 조정
               const routeBtn = removeButtons.querySelector('button[onclick*="removeRoutesByLocation"]');
               const markerBtn = removeButtons.querySelector('button[onclick*="removeMarkersByLocation"]');
               
               if (routeBtn) {
                 if (hasRoutes) {
                   // 경로가 있으면 정상 표시
                   routeBtn.style.opacity = '1';
                   routeBtn.style.cursor = 'pointer';
                   routeBtn.disabled = false;
                 } else {
                   // 경로가 없으면 희미하게 표시
                   routeBtn.style.opacity = '0.3';
                   routeBtn.style.cursor = 'not-allowed';
                   routeBtn.disabled = true;
                 }
               }
               
               if (markerBtn) {
                 if (hasMarkers) {
                   // 마커가 있으면 정상 표시
                   markerBtn.style.opacity = '1';
                   markerBtn.style.cursor = 'pointer';
                   markerBtn.disabled = false;
                 } else {
                   // 마커가 없으면 희미하게 표시
                   markerBtn.style.opacity = '0.3';
                   markerBtn.style.cursor = 'not-allowed';
                   markerBtn.disabled = true;
                 }
               }
             }
           }
         }
       }
       
       // 마커제거 버튼들을 동적으로 표시/숨김하는 함수 (하위 호환성을 위해 유지)
       function updateMarkerRemoveButtons() {
         // 이 함수는 더 이상 사용되지 않으며, updateRouteRemoveButtons에서 통합 처리됩니다.
         updateRouteRemoveButtons();
       }
       
       // 포괄적인 장소 검색 함수 - 부분 검색어 지원
       function searchAddress() {
         const searchQuery = document.getElementById('addressInput').value.trim();
         if (!searchQuery) {
           alert('검색어를 입력하세요.');
           return;
         }
         if (!map) {
           alert('지도가 아직 준비되지 않았습니다.');
           return;
         }
         
         // 모바일에서 검색 중 표시
         let searchBtn = null;
         let originalText = '';
         if (isMobile) {
           searchBtn = document.querySelector('#addressInput + button') || document.getElementById('addressInput');
           originalText = searchBtn.textContent || searchBtn.placeholder || '위치검색';
           if (searchBtn.tagName === 'INPUT') {
             searchBtn.placeholder = '검색중...';
           } else {
           searchBtn.textContent = '검색중...';
           }
           searchBtn.disabled = true;
         }
         
         // 기존 마커 제거
         if (addressMarker) {
           addressMarker.setMap(null);
           addressMarker = null;
         }
         
         // 포괄적 검색 실행
         performComprehensiveSearch(searchQuery, searchBtn, originalText);
       }
       
       // 포괄적 검색 실행 함수
       function performComprehensiveSearch(query, searchBtn, originalText) {
         
         // 검색 결과를 수집할 배열
         let allResults = [];
         let searchesCompleted = 0;
         const totalSearches = 2; // Geocoding + Places Text Search
         
         // 검색 완료 후 처리 함수
         function handleSearchComplete() {
           searchesCompleted++;
           if (searchesCompleted >= totalSearches) {
             processAllSearchResults(allResults, query, searchBtn, originalText);
           }
         }
         
         // 1. 기존 Geocoding API 검색
         if (geocoder) {
         const boundsForQuery = map.getBounds ? map.getBounds() : null;
         geocoder.geocode({ 
             address: query, 
           bounds: boundsForQuery,
             region: 'JP', // 일본 지역 우선 검색
             language: 'ko' // 한국어 결과 요청
         }, function(results, status) {
             if (status === 'OK' && results && results.length) {
               results.forEach(result => {
                 allResults.push({
                   ...result,
                   source: 'geocoding',
                   name: result.formatted_address,
                   place_id: result.place_id
                 });
               });
             }
             handleSearchComplete();
           });
         } else {
           handleSearchComplete();
         }
         
         // 2. Places Text Search API 검색
         if (google.maps.places && google.maps.places.PlacesService) {
           const service = new google.maps.places.PlacesService(map);
           const bounds = map.getBounds();
           
           const request = {
             query: query,
             bounds: bounds,
             region: 'jp',
             language: 'ko' // 한국어 결과 요청
           };
           
           service.textSearch(request, function(results, status) {
             if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length) {
               results.forEach(result => {
                 allResults.push({
                   geometry: { location: result.geometry.location },
                   formatted_address: result.formatted_address || result.name,
                   name: result.name,
                   place_id: result.place_id,
                   source: 'places_text',
                   types: result.types,
                   rating: result.rating,
                   vicinity: result.vicinity
                 });
               });
             }
             handleSearchComplete();
           });
         } else {
           handleSearchComplete();
         }
       }
       
       // 모든 검색 결과 처리 함수
       function processAllSearchResults(allResults, query, searchBtn, originalText) {
           // 모바일에서 검색 완료 표시 복원
         if (isMobile && searchBtn) {
           if (searchBtn.tagName === 'INPUT') {
             searchBtn.placeholder = originalText;
           } else {
             searchBtn.textContent = originalText;
           }
             searchBtn.disabled = false;
           }
           
         
         if (!allResults.length) {
           alert('검색 결과가 없습니다. 다른 검색어를 시도해보세요.');
             return;
           }

         // 중복 제거 (place_id 기준)
         const uniqueResults = [];
         const seenPlaceIds = new Set();
         const seenLocations = new Set();
         
         allResults.forEach(result => {
           const locationKey = `${result.geometry.location.lat().toFixed(6)},${result.geometry.location.lng().toFixed(6)}`;
           
           if (result.place_id && !seenPlaceIds.has(result.place_id)) {
             seenPlaceIds.add(result.place_id);
             uniqueResults.push(result);
           } else if (!result.place_id && !seenLocations.has(locationKey)) {
             seenLocations.add(locationKey);
             uniqueResults.push(result);
           }
         });
         
         
         // 현재 지도 범위 내 결과만 필터링
         const bounds = map.getBounds();
         const filteredResults = bounds ? 
           uniqueResults.filter(result => bounds.contains(result.geometry.location)) : 
           uniqueResults;
         
         if (!filteredResults.length) {
           alert('현재 화면 범위 내에서 검색 결과를 찾을 수 없습니다. 지도를 이동/확대 후 다시 시도하세요.');
             return;
           }
         
         
         // 관련성 점수 계산 및 정렬
         const scoredResults = filteredResults.map(result => {
           let score = 0;
           const name = (result.name || result.formatted_address || '').toLowerCase();
           const queryLower = query.toLowerCase();
           
           // 완전 일치
           if (name === queryLower) score += 100;
           // 시작 일치
           else if (name.startsWith(queryLower)) score += 80;
           // 포함 일치
           else if (name.includes(queryLower)) score += 60;
           // 부분 일치 (각 단어별)
           else {
             const queryWords = queryLower.split(/\s+/);
             queryWords.forEach(word => {
               if (name.includes(word)) score += 30;
             });
           }
           
           // Places API 결과에 추가 점수
           if (result.source === 'places_text') score += 10;
           
           // 평점이 있는 경우 추가 점수
           if (result.rating) score += Math.min(result.rating, 5);
           
           return { ...result, relevanceScore: score };
         });
         
         // 관련성 점수로 정렬
         scoredResults.sort((a, b) => b.relevanceScore - a.relevanceScore);

                    // 모든 결과를 마커로 표시
         createMultipleAddressMarkers(scoredResults, query);
       }
       
       // 개선된 주소 선택 다이얼로그
       function showEnhancedAddressSelection(results, queryText) {
         // 기존 선택창 제거
         const existing = document.getElementById('addressSelectDialog');
         if (existing) existing.remove();

         const dialog = document.createElement('div');
         dialog.id = 'addressSelectDialog';
         dialog.style.cssText = `
           position: fixed;
           z-index: 1000;
           width: 400px;
           max-width: 90vw;
           max-height: 70vh;
           background: white;
           border: 1px solid #e5e7eb;
           border-radius: 16px;
           box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
           overflow: hidden;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
         `;

         dialog.innerHTML = `
           <div style="background: linear-gradient(135deg, #1d4ed8, #2563eb); color: white; padding: 16px; display: flex; justify-content: space-between; align-items: center;">
             <div style="font-weight: 700; font-size: 16px;">검색 결과 (${results.length}개)</div>
             <button style="background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background 0.2s;" onclick="closeAddressSelection()" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'">×</button>
           </div>
           <div style="padding: 16px; max-height: 50vh; overflow: auto;">
             <div style="margin-bottom: 12px; color: #6b7280; font-size: 14px;">
               '<strong>${queryText}</strong>' 검색 결과입니다. 원하는 장소를 선택하세요.
             </div>
             <div id="addressSelectList"></div>
           </div>
         `;

         document.body.appendChild(dialog);

         // 결과 목록 생성
         const list = document.getElementById('addressSelectList');
         let html = '';
         results.forEach((result, index) => {
           const name = result.name || '이름 없음';
           const address = result.formatted_address || result.vicinity || '주소 정보 없음';
           const source = result.source === 'places_text' ? '장소' : '주소';
           const rating = result.rating ? ` ⭐ ${result.rating}` : '';
           
           html += `
             <button onclick="chooseAddressResult(${index})" style="
               width: 100%;
               text-align: left;
               padding: 12px;
               margin-bottom: 8px;
               border: 1px solid #e5e7eb;
               border-radius: 8px;
               background: white;
               cursor: pointer;
               transition: all 0.2s ease;
               display: block;
             " onmouseover="this.style.background='#f8fafc'; this.style.borderColor='#3b82f6';" onmouseout="this.style.background='white'; this.style.borderColor='#e5e7eb';">
               <div style="font-weight: 600; color: #1f2937; margin-bottom: 4px;">${name}${rating}</div>
               <div style="font-size: 13px; color: #6b7280; margin-bottom: 4px;">${address}</div>
               <div style="font-size: 12px; color: #9ca3af;">
                 <span style="background: #e0e7ff; color: #3730a3; padding: 2px 6px; border-radius: 4px; margin-right: 4px;">${source}</span>
                 관련성: ${result.relevanceScore || 0}점
               </div>
             </button>
           `;
         });
         list.innerHTML = html;
       }
       // 주소 마커 생성 함수
       function createAddressMarker(result, originalQuery) {
         const location = result.geometry.location;
         const name = result.name || originalQuery;
         const address = result.formatted_address || result.vicinity || '';
           
           // 현재 줌 레벨 유지하면서 중심만 이동
           const currentZoom = map.getZoom();
           map.setCenter(location);
         map.setZoom(Math.max(currentZoom, 14)); // 최소 줌 레벨 14

         // 새로운 마커 생성 및 표시
           addressMarker = new google.maps.Marker({
             position: location,
             map: map,
           title: name,
             zIndex: 1000, // 경로와 라벨 위에 표시
             icon: {
               url: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
             scaledSize: new google.maps.Size(isMobile ? 32 : 36, isMobile ? 32 : 36)
           },
           animation: isMobile ? google.maps.Animation.NONE : google.maps.Animation.DROP,
           optimized: false
         });

                  // 마커 클릭 시 정보창 표시 (한국어)
         const infoContent = `
           <div style="padding: 16px; max-width: 320px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
             <div style="font-weight: 700; font-size: 16px; color: #1f2937; margin-bottom: 8px; line-height: 1.4;">
               ${name}
               <span style="background: #ef4444; color: white; font-size: 12px; padding: 2px 6px; border-radius: 12px; margin-left: 8px;">추천</span>
             </div>
             ${address ? `<div style="font-size: 14px; color: #6b7280; margin-bottom: 8px; line-height: 1.3;">${address}</div>` : ''}
             ${result.rating ? `<div style="font-size: 14px; color: #f59e0b; margin-bottom: 8px;">⭐ ${result.rating}점 (평점)</div>` : ''}
             <div style="font-size: 12px; color: #9ca3af; margin-bottom: 12px;">
               <span style="background: ${result.source === 'places_text' ? '#e0e7ff' : '#f3f4f6'}; color: ${result.source === 'places_text' ? '#3730a3' : '#6b7280'}; padding: 2px 6px; border-radius: 4px; margin-right: 4px;">
                 ${result.source === 'places_text' ? '장소 정보' : '주소 정보'}
               </span>
               연관도: ${result.relevanceScore || 0}점
             </div>
             <div style="border-top: 1px solid #e5e7eb; padding-top: 12px;">
               <button onclick="openInGoogleMaps('${location.lat()}', '${location.lng()}', '${name.replace(/'/g, "\\'")}', '${encodeURIComponent(address || name)}')" 
                       style="
                         width: 100%;
                         background: rgba(255, 255, 255, 0.12);
                         color: #000;
                         border: none;
                         border-radius: 12px;
                         padding: 14px 32px;
                         font-size: 15px;
                         font-weight: 500;
                         cursor: pointer;
                         transition: all 0.2s ease;
                         backdrop-filter: blur(10px);
                         min-width: 120px;
                         display: flex;
                         align-items: center;
                         justify-content: center;
                         gap: 8px;
                       "
                       onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'; this.style.transform='translateY(-1px)';"
                       onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'; this.style.transform='translateY(0)';">
                 상세보기
               </button>
             </div>
           </div>
         `;
         
         const infoWindow = new google.maps.InfoWindow({
           content: infoContent,
           disableAutoPan: false,
           maxWidth: isMobile ? 300 : 350
         });
         
         // 정보창 열린 후 X 버튼 제거
         google.maps.event.addListener(infoWindow, 'domready', function() {
           const closeBtn = document.querySelector('.gm-ui-hover-effect');
           if (closeBtn) {
             closeBtn.style.display = 'none';
           }
         });
         
           addressMarker.addListener('click', function() {
             // 메뉴창 닫기
             const customMapMenu = getElement('customMapMenu');
             const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
             
             if (!customMapMenu.classList.contains('hide')) {
               hideMenu();
             }
             if (rightPanelOpen) {
               hideRightMenu();
             }
             
             // 기존 정보창 닫기
             if (currentInfoWindow) {
               currentInfoWindow.close();
             }
             
             // Places API에서 상세 정보를 가져와서 한국어 이름 확인
             if (result.place_id && google.maps.places && google.maps.places.PlacesService) {
               const service = new google.maps.places.PlacesService(map);
               const detailRequest = {
                 placeId: result.place_id,
                 fields: ['name', 'formatted_address', 'rating', 'types'],
                 language: 'ko'
               };
               
               service.getDetails(detailRequest, function(placeResult, status) {
                 if (status === google.maps.places.PlacesServiceStatus.OK && placeResult) {
                   // 한국어 이름이 있으면 업데이트, 없으면 번역 시도
                   const koreanName = placeResult.name || name;
                   const koreanAddress = placeResult.formatted_address || address;
                   
                   // 한국어 정보로 정보창 내용 업데이트
                   const updatedInfoContent = `
                     <div style="padding: 16px; max-width: 320px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                       <div style="font-weight: 700; font-size: 16px; color: #1f2937; margin-bottom: 8px; line-height: 1.4;">
                         ${koreanName}
                         <span style="background: #ef4444; color: white; font-size: 12px; padding: 2px 6px; border-radius: 12px; margin-left: 8px;">추천</span>
                       </div>
                       ${koreanAddress ? `<div style="font-size: 14px; color: #6b7280; margin-bottom: 8px; line-height: 1.3;">${koreanAddress}</div>` : ''}
                       ${(placeResult.rating || result.rating) ? `<div style="font-size: 14px; color: #f59e0b; margin-bottom: 8px;">⭐ ${(placeResult.rating || result.rating)}점 (평점)</div>` : ''}
                       <div style="font-size: 12px; color: #9ca3af; margin-bottom: 12px;">
                         <span style="background: ${result.source === 'places_text' ? '#e0e7ff' : '#f3f4f6'}; color: ${result.source === 'places_text' ? '#3730a3' : '#6b7280'}; padding: 2px 6px; border-radius: 4px; margin-right: 4px;">
                           ${result.source === 'places_text' ? '장소 정보' : '주소 정보'}
                         </span>
                         연관도: ${result.relevanceScore || 0}점
                       </div>
                       <div style="border-top: 1px solid #e5e7eb; padding-top: 12px;">
                         <button onclick="openInGoogleMaps('${location.lat()}', '${location.lng()}', '${koreanName.replace(/'/g, "\\'")}', '${encodeURIComponent(koreanAddress || koreanName)}')" 
                                 style="
                                   width: 100%;
                                   background: rgba(255, 255, 255, 0.12);
                                   color: #000;
                                   border: none;
                                   border-radius: 12px;
                                   padding: 14px 32px;
                                   font-size: 15px;
                                   font-weight: 500;
                                   cursor: pointer;
                                   transition: all 0.2s ease;
                                   backdrop-filter: blur(10px);
                                   min-width: 120px;
                                   display: flex;
                                   align-items: center;
                                   justify-content: center;
                                   gap: 8px;
                                 "
                                 onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(66, 133, 244, 0.3)';"
                                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                           상세보기
                         </button>
                       </div>
                     </div>
                   `;
                   
                   infoWindow.setContent(updatedInfoContent);
                 }
                 
                 // 정보창 표시
                 infoWindow.open(map, addressMarker);
                 currentInfoWindow = infoWindow;
                 
                 // 마커 주위로 줌 레벨 15로 조정
                 map.setCenter(location);
                 map.setZoom(15);
               });
             } else {
               // place_id가 없는 경우 기본 정보창 표시
               infoWindow.open(map, addressMarker);
               currentInfoWindow = infoWindow;
               
               // 마커 주위로 줌 레벨 15로 조정
               map.setCenter(location);
               map.setZoom(15);
             }
           });

                    // 주소 입력창 초기화
         document.getElementById('addressInput').value = '';
         
         // 사이드패널 닫기
         closeSidePanel();
         
       }
       // 여러 주소 마커 생성 함수
       function createMultipleAddressMarkers(results, originalQuery) {
         
         // 기존 검색 마커들 모두 제거
         clearAllAddressMarkers();
         
         if (!results.length) {
           alert('검색 결과가 없습니다.');
           return;
         }
         
         // 지도 영역을 모든 마커를 포함하도록 조정할 bounds 생성
         const bounds = new google.maps.LatLngBounds();
         let markersCreated = 0;
         
         results.forEach((result, index) => {
           const location = result.geometry.location;
           const name = result.name || result.formatted_address || `검색 결과 ${index + 1}`;
           const address = result.formatted_address || result.vicinity || '';
           
           // 마커 아이콘 색상 - 관련성에 따라 다른 색상
           let iconUrl;
           if (index === 0) {
             // 가장 관련성 높은 결과는 빨간색
             iconUrl = 'https://maps.google.com/mapfiles/ms/icons/red-dot.png';
           } else if (index < 3) {
             // 상위 3개는 주황색
             iconUrl = 'https://maps.google.com/mapfiles/ms/icons/orange-dot.png';
           } else {
             // 나머지는 노란색
             iconUrl = 'https://maps.google.com/mapfiles/ms/icons/yellow-dot.png';
           }
           
           // 마커 생성
           const marker = new google.maps.Marker({
             position: location,
             map: map,
             title: name,
             zIndex: 1000, // 경로와 라벨 위에 표시
             icon: {
               url: iconUrl,
               scaledSize: new google.maps.Size(isMobile ? 28 : 32, isMobile ? 28 : 32)
             },
             animation: google.maps.Animation.DROP,
             optimized: false,
             zIndex: 1000 - index // 관련성 높은 순으로 위에 표시
           });
           
           // 마커 배열에 추가
           addressMarkers.push(marker);
           bounds.extend(location);
           markersCreated++;
           
           // 정보창 내용 구성 (한국어)
           const infoContent = `
             <div style="padding: 16px; max-width: 320px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
               <div style="font-weight: 700; font-size: 16px; color: #1f2937; margin-bottom: 8px; line-height: 1.4;">
                 ${name}
                 ${index < 3 ? '<span style="background: #ef4444; color: white; font-size: 12px; padding: 2px 6px; border-radius: 12px; margin-left: 8px;">추천</span>' : ''}
               </div>
               ${address ? `<div style="font-size: 14px; color: #6b7280; margin-bottom: 8px; line-height: 1.3;">${address}</div>` : ''}
               ${result.rating ? `<div style="font-size: 14px; color: #f59e0b; margin-bottom: 8px;">⭐ ${result.rating}점 (평점)</div>` : ''}
               <div style="font-size: 12px; color: #9ca3af; margin-bottom: 12px;">
                 <span style="background: ${result.source === 'places_text' ? '#e0e7ff' : '#f3f4f6'}; color: ${result.source === 'places_text' ? '#3730a3' : '#6b7280'}; padding: 2px 6px; border-radius: 4px; margin-right: 4px;">
                   ${result.source === 'places_text' ? '장소 정보' : '주소 정보'}
                 </span>
                 연관도: ${result.relevanceScore || 0}점
               </div>
               <div style="border-top: 1px solid #e5e7eb; padding-top: 12px;">
                 <button onclick="openInGoogleMaps('${location.lat()}', '${location.lng()}', '${name.replace(/'/g, "\\'")}', '${encodeURIComponent(address || name)}')" 
                         style="
                           width: 100%;
                           background: linear-gradient(135deg, #4285f4, #34a853);
                           color: white;
                           border: none;
                           border-radius: 8px;
                           padding: 12px 16px;
                           font-size: 14px;
                           font-weight: 600;
                           cursor: pointer;
                           transition: all 0.2s ease;
                           display: flex;
                           align-items: center;
                           justify-content: center;
                           gap: 8px;
                         "
                         onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'; this.style.transform='translateY(-1px)';"
                         onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'; this.style.transform='translateY(0)';">
                   상세보기
                 </button>
               </div>
             </div>
           `;
           
           // 정보창 생성 (X 버튼 제거)
           const infoWindow = new google.maps.InfoWindow({
             content: infoContent,
             disableAutoPan: false,
             maxWidth: isMobile ? 300 : 350
           });
           
           // 정보창 열린 후 X 버튼 제거
           google.maps.event.addListener(infoWindow, 'domready', function() {
             const closeBtn = document.querySelector('.gm-ui-hover-effect');
             if (closeBtn) {
               closeBtn.style.display = 'none';
             }
           });
           
           // 마커 클릭 이벤트
           marker.addListener('click', function() {
             // 메뉴창 닫기
             const customMapMenu = getElement('customMapMenu');
             const rightPanelOpen = !getElement('mapTypeSelector').classList.contains('hide');
             
             if (!customMapMenu.classList.contains('hide')) {
               hideMenu();
             }
             if (rightPanelOpen) {
               hideRightMenu();
             }
             

             
             // 기존 정보창 닫기
             if (currentInfoWindow) {
               currentInfoWindow.close();
             }
             
             // Places API에서 상세 정보를 가져와서 한국어 이름 확인
             if (result.place_id && google.maps.places && google.maps.places.PlacesService) {
               const service = new google.maps.places.PlacesService(map);
               const detailRequest = {
                 placeId: result.place_id,
                 fields: ['name', 'formatted_address', 'rating', 'types'],
                 language: 'ko'
               };
               
               service.getDetails(detailRequest, function(placeResult, status) {
                 if (status === google.maps.places.PlacesServiceStatus.OK && placeResult) {
                   // 한국어 이름이 있으면 업데이트, 없으면 번역 시도
                   const koreanName = placeResult.name || name;
                   const koreanAddress = placeResult.formatted_address || address;
                   
                   // 한국어 정보로 정보창 내용 업데이트
                   const updatedInfoContent = `
                     <div style="padding: 16px; max-width: 320px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                       <div style="font-weight: 700; font-size: 16px; color: #1f2937; margin-bottom: 8px; line-height: 1.4;">
                         ${koreanName}
                         ${index < 3 ? '<span style="background: #ef4444; color: white; font-size: 12px; padding: 2px 6px; border-radius: 12px; margin-left: 8px;">추천</span>' : ''}
                       </div>
                       ${koreanAddress ? `<div style="font-size: 14px; color: #6b7280; margin-bottom: 8px; line-height: 1.3;">${koreanAddress}</div>` : ''}
                       ${(placeResult.rating || result.rating) ? `<div style="font-size: 14px; color: #f59e0b; margin-bottom: 8px;">⭐ ${(placeResult.rating || result.rating)}점 (평점)</div>` : ''}
                       <div style="font-size: 12px; color: #9ca3af; margin-bottom: 12px;">
                         <span style="background: ${result.source === 'places_text' ? '#e0e7ff' : '#f3f4f6'}; color: ${result.source === 'places_text' ? '#3730a3' : '#6b7280'}; padding: 2px 6px; border-radius: 4px; margin-right: 4px;">
                           ${result.source === 'places_text' ? '장소 정보' : '주소 정보'}
                         </span>
                         연관도: ${result.relevanceScore || 0}점
                       </div>
                       <div style="border-top: 1px solid #e5e7eb; padding-top: 12px;">
                         <button onclick="openInGoogleMaps('${location.lat()}', '${location.lng()}', '${koreanName.replace(/'/g, "\\'")}', '${encodeURIComponent(koreanAddress || koreanName)}')" 
                                 style="
                                   width: 100%;
                                   background: rgba(255, 255, 255, 0.12);
                                   color: #000;
                                   border: none;
                                   border-radius: 12px;
                                   padding: 14px 32px;
                                   font-size: 15px;
                                   font-weight: 500;
                                   cursor: pointer;
                                   transition: all 0.2s ease;
                                   backdrop-filter: blur(10px);
                                   min-width: 120px;
                                   display: flex;
                                   align-items: center;
                                   justify-content: center;
                                   gap: 8px;
                                 "
                                 onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(66, 133, 244, 0.3)';"
                                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                           상세보기
                         </button>
                       </div>
                     </div>
                   `;
                   
                   infoWindow.setContent(updatedInfoContent);
                 }
                 
                 // 정보창 표시
                 infoWindow.open(map, marker);
                 currentInfoWindow = infoWindow;
                 
                                 // 마커 중심으로 부드럽게 이동하고 필요시 줌레벨 15로 확대
                const currentZoom = map.getZoom();
                map.panTo(location);
                // 현재 줌레벨이 15 미만일 때만 줌레벨 15로 확대
                if (currentZoom < 15) {
                  map.setZoom(15);
                }
               });
             } else {
               // place_id가 없는 경우 기본 정보창 표시
               infoWindow.open(map, marker);
               currentInfoWindow = infoWindow;
               
                               // 마커 중심으로 부드럽게 이동하고 필요시 줌레벨 15로 확대
                const currentZoom = map.getZoom();
                map.panTo(location);
                // 현재 줌레벨이 15 미만일 때만 줌레벨 15로 확대
                if (currentZoom < 15) {
                  map.setZoom(15);
                }
             }
           });
         });
         
         // 첫 번째 마커를 addressMarker로도 설정 (기존 호환성)
         if (addressMarkers.length > 0) {
           addressMarker = addressMarkers[0];
         }
         
         // 모든 마커가 보이도록 지도 범위 조정
         if (markersCreated > 1) {
           map.fitBounds(bounds);
           // 너무 확대되지 않도록 최대 줌 레벨 제한
           google.maps.event.addListenerOnce(map, 'bounds_changed', function() {
             if (map.getZoom() > 16) {
               map.setZoom(16);
             }
           });
         } else if (markersCreated === 1) {
           // 마커가 하나만 있으면 해당 위치로 이동
           map.setCenter(results[0].geometry.location);
           map.setZoom(15);
         }
         
         // 주소 입력창 초기화
         document.getElementById('addressInput').value = '';
         
         
         // 사이드패널 닫기
         closeSidePanel();
         
         // 사용자에게 알림
         const message = `"${originalQuery}" 검색 결과 ${markersCreated}개 장소가 지도에 표시되었습니다.`;
         showSearchResultNotification(message);
       }
       
       // 모든 주소 검색 마커 제거 함수
       function clearAllAddressMarkers() {
         // 기존 단일 마커 제거
         if (addressMarker) {
           addressMarker.setMap(null);
           addressMarker = null;
         }
         
         // 모든 검색 마커들 제거
         addressMarkers.forEach(marker => {
           marker.setMap(null);
         });
         addressMarkers = [];
         
         // 현재 열린 정보창 닫기
         if (currentInfoWindow) {
           currentInfoWindow.close();
           currentInfoWindow = null;
         }
       }
       
       // 검색 결과 알림 표시 함수
       function showSearchResultNotification(message) {
         // 기존 알림 제거
         const existingNotification = document.getElementById('searchResultNotification');
         if (existingNotification) {
           existingNotification.remove();
         }
         
         // 알림 생성
         const notification = document.createElement('div');
         notification.id = 'searchResultNotification';
         notification.style.cssText = `
           position: fixed;
           top: 20px;
           left: 50%;
           transform: translateX(-50%);
           z-index: 10000;
           background: linear-gradient(135deg, #10b981, #059669);
           color: white;
           padding: 16px 24px;
           border-radius: 12px;
           box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
           font-size: 14px;
           font-weight: 600;
           max-width: 90vw;
           text-align: center;
           animation: slideInFromTop 0.3s ease-out;
         `;
         
         notification.textContent = message;
         document.body.appendChild(notification);
         
         // 3초 후 자동 제거
         setTimeout(() => {
           if (notification && notification.parentNode) {
             notification.style.animation = 'fadeOut 0.3s ease-out';
             setTimeout(() => {
               if (notification && notification.parentNode) {
                 notification.remove();
               }
             }, 300);
           }
         }, 3000);
       }
       

       
       // 구글맵에서 장소 열기 함수
       function openInGoogleMaps(lat, lng, placeName, encodedAddress) {
         try {
           // 모바일 기기인지 확인
           // 전역 isMobile 변수 사용 (isMobileDevice → isMobile)
           const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
           const isAndroid = /Android/i.test(navigator.userAgent);
           
           if (isMobile) {
             // 모바일: 구글맵 앱으로 직접 연결
             let appUrl;
             
             if (isIOS) {
               // iOS: 구글맵 앱 직접 스킴 사용
               appUrl = `comgooglemaps://?center=${lat},${lng}&zoom=16&q=${lat},${lng}`;
             } else if (isAndroid) {
               // Android: 구글맵 앱 직접 인텐트 사용
               appUrl = `geo:${lat},${lng}?q=${lat},${lng}(${placeName || ''})?z=16`;
             } else {
               // 기타 모바일: 구글맵 앱 스킴 시도
               appUrl = `comgooglemaps://?center=${lat},${lng}&zoom=16&q=${lat},${lng}`;
             }
             
             // 앱으로 바로 이동
             window.location.href = appUrl;
             
           } else {
             // 데스크톱: 웹 브라우저로 구글맵 열기
             const googleMapsUrl = `https://www.google.com/maps/search/?api=1&query=${lat},${lng}&zoom=16`;
             window.open(googleMapsUrl, '_blank', 'noopener,noreferrer');
           }
           
           // 사용자에게 피드백 제공
           showSearchResultNotification(`"${decodeURIComponent(encodedAddress)}" 구글맵에서 열기`);
           
         } catch (error) {
           console.error('구글맵 열기 실패:', error);
           alert('구글맵을 열 수 없습니다. 잠시 후 다시 시도해주세요.');
         }
       }
       
       // 주소 마커 가시성 확인 및 자동 제거 함수
       function checkAddressMarkerVisibility() {
         if (map) {
           const bounds = map.getBounds();
           if (!bounds) return;
           
           // 여러 마커들 중 뷰에서 벗어난 것들 확인
           let removedCount = 0;
           for (let i = addressMarkers.length - 1; i >= 0; i--) {
             const marker = addressMarkers[i];
             const markerPosition = marker.getPosition();
             if (!bounds.contains(markerPosition)) {
               marker.setMap(null);
               addressMarkers.splice(i, 1);
               removedCount++;
             }
           }
           
           if (removedCount > 0) {
           }
           
           // 기존 단일 마커도 확인 (호환성)
           if (addressMarker && !bounds.contains(addressMarker.getPosition())) {
             // 열린 정보창 닫기
             if (currentInfoWindow) {
               currentInfoWindow.close();
               currentInfoWindow = null;
             }
             // 마커가 뷰에서 벗어나면 자동으로 제거
             addressMarker.setMap(null);
             addressMarker = null;
             document.getElementById('addressInput').value = '';
           }
         }
       }
       
       // 현재 위치 마커 가시성 확인 및 자동 제거 함수
       function checkCurrentLocationMarkerVisibility() {
         if (currentLocationMarker && map) {
           const bounds = map.getBounds();
           const markerPosition = currentLocationMarker.getPosition();
           
           // 마커가 현재 지도 뷰의 경계 밖에 있는지 확인
           if (bounds && !bounds.contains(markerPosition)) {
             // 열린 정보창 닫기
             if (currentInfoWindow) {
               currentInfoWindow.close();
               currentInfoWindow = null;
             }
             // 마커가 뷰에서 벗어나면 자동으로 제거
             currentLocationMarker.setMap(null);
             currentLocationMarker = null;
           }
         }
       }
       
       // 주소 마커 제거 함수 (수동 제거용)
       function clearAddressMarker() {
         // 새로운 여러 마커 제거 함수 호출
         clearAllAddressMarkers();
       }
       
       // 현재 위치 마커 제거 함수 (수동 제거용)
       function clearCurrentLocationMarker() {
         if (currentLocationMarker) {
           // 열린 정보창 닫기
           if (currentInfoWindow) {
             currentInfoWindow.close();
             currentInfoWindow = null;
           }
           currentLocationMarker.setMap(null);
           currentLocationMarker = null;
         }
       }

      function showAddressSelection(results, queryText) {
        // 호환성을 위해 새로운 개선된 함수로 리디렉션
        showEnhancedAddressSelection(results, queryText);
      }

      function closeAddressSelection() {
        var dialog = document.getElementById('addressSelectDialog');
        if (dialog) dialog.remove();
      }

      function chooseAddressResult(index) {
        try {
          var candidates = addressSearchCandidates || [];
          if (!candidates.length || !candidates[index]) {
            closeAddressSelection();
            alert('선택할 수 있는 주소가 없습니다.');
            return;
          }
          var result = candidates[index];
          
          // 새로운 마커 생성 함수 사용
          createAddressMarker(result, result.name || result.formatted_address || '선택된 위치');
        } finally {
          closeAddressSelection();
          addressSearchCandidates = [];
        }
      }
      // 기존 스와이프 기능은 제거됨 - 새로운 스와이프 기능 사용
      function initializeSwipeDelete() {
        // 이 함수는 더 이상 사용되지 않음
              return;
      }
      
      // 드래그 앤 드롭 관련 전역 변수
      let dragElement = null;
      let dragPlaceholder = null;
      let dragOffset = { x: 0, y: 0 };
      let isDraggingGlobal = false;
      let draggedItemType = 'user'; // 드래그된 항목 타입
      let currentLongPressTimer = null;
      let currentDragItem = null;
      
      // 드래그 모드 시작
      function startDragMode(element, event) {
        isDraggingGlobal = true;
        dragElement = element;
        
        // 드래그된 항목 타입 설정
        draggedItemType = element.getAttribute('data-item-type') || 'user';
        
        // 스와이프 상태 초기화
        element.classList.remove('swiped');
        if (element.querySelector('.item-content')) {
          element.querySelector('.item-content').style.transform = 'translateX(0)';
        }
        
        // 텍스트 선택 방지
        element.style.userSelect = 'none';
        element.style.webkitUserSelect = 'none';
        element.style.mozUserSelect = 'none';
        element.style.msUserSelect = 'none';
        
        // 전체 문서에서 텍스트 선택 방지
        document.body.style.userSelect = 'none';
        document.body.style.webkitUserSelect = 'none';
        document.body.style.mozUserSelect = 'none';
        document.body.style.msUserSelect = 'none';
        
        // 햅틱 피드백 (지원하는 기기에서)
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
        
        // 원래 위치와 크기 저장
        const rect = element.getBoundingClientRect();
        const computedStyle = getComputedStyle(element);
        
        // 플레이스홀더 생성 (더 자연스러운 디자인)
        dragPlaceholder = document.createElement('div');
        dragPlaceholder.className = 'drag-placeholder';
        dragPlaceholder.style.height = rect.height + 'px';
        dragPlaceholder.style.margin = computedStyle.margin;
        dragPlaceholder.style.backgroundColor = '#f3f4f6';
        dragPlaceholder.style.border = '2px dashed #3b82f6';
        dragPlaceholder.style.borderRadius = '12px';
        dragPlaceholder.style.opacity = '0.8';
        dragPlaceholder.style.transition = 'all 0.2s ease';
        dragPlaceholder.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280; font-size: 14px;">여기에 놓기</div>';
        
        // 플레이스홀더를 원래 위치에 삽입
        element.parentNode.insertBefore(dragPlaceholder, element);
        
        // 드래그 요소를 body로 이동 (정확한 위치 계산)
        document.body.appendChild(element);
        
        // 터치 위치에 따른 오프셋 계산
        const touch = event.touches ? event.touches[0] : event;
        dragOffset.x = touch.clientX - rect.left;
        dragOffset.y = touch.clientY - rect.top;
        
        // 드래그 요소 스타일 설정 (부드러운 애니메이션)
        element.style.position = 'fixed';
        element.style.left = (touch.clientX - dragOffset.x) + 'px';
        element.style.top = (touch.clientY - dragOffset.y) + 'px';
        element.style.width = rect.width + 'px';
        element.style.height = rect.height + 'px';
        element.style.zIndex = '10000';
        element.style.opacity = '0.9';
        element.style.transform = 'scale(1.02) rotate(2deg)';
        element.style.boxShadow = '0 12px 30px rgba(0,0,0,0.25), 0 4px 15px rgba(0,0,0,0.1)';
        element.style.transition = 'transform 0.1s ease-out';
        element.style.pointerEvents = 'none';
        element.style.borderRadius = '12px';
        element.style.backgroundColor = '#ffffff';
        
        // 드래그 시작 애니메이션
        requestAnimationFrame(() => {
          element.style.transform = 'scale(1.05) rotate(3deg)';
        });
      }
      
      // 드래그 이동 처리 (개선된 버전)
      function handleDragMove(element, event) {
        if (!isDraggingGlobal || !dragElement) return;
        
        const pointer = event.touches ? event.touches[0] : event;
        
        // 드래그 요소 위치 업데이트 (부드러운 이동)
        const newX = pointer.clientX - dragOffset.x;
        const newY = pointer.clientY - dragOffset.y;
        
        dragElement.style.left = newX + 'px';
        dragElement.style.top = newY + 'px';
        
        // 드래그 중 미묘한 애니메이션 효과
        dragElement.style.transform = 'scale(1.05) rotate(3deg)';
        
        // 드롭 대상 찾기 (더 정확한 감지)
        dragElement.style.pointerEvents = 'none'; // 드래그 요소 무시
        const elementBelow = document.elementFromPoint(pointer.clientX, pointer.clientY);
        dragElement.style.pointerEvents = 'auto';
        
        // 드래그 중인 항목의 타입에 따라 대상 결정
        const dragItemType = dragElement.getAttribute('data-item-type');
        const targetSelector = dragItemType === 'schedule' 
          ? '.user-added-item[data-item-type="schedule"]' 
          : '.user-added-item[data-item-type="user"]';
        const targetItem = elementBelow ? elementBelow.closest(targetSelector) : null;
        
        if (targetItem && targetItem !== dragElement && targetItem !== dragPlaceholder) {
          const container = targetItem.parentNode;
          const targetRect = targetItem.getBoundingClientRect();
          const targetCenter = targetRect.top + targetRect.height / 2;
          
          // 스크롤 영역 감지 및 자동 스크롤
          const scrollContainer = container.closest('.scrollable-area') || container.closest('.user-items-container');
          if (scrollContainer) {
            const scrollRect = scrollContainer.getBoundingClientRect();
            const scrollThreshold = 50;
            
            if (pointer.clientY < scrollRect.top + scrollThreshold) {
              // 위로 스크롤
              scrollContainer.scrollTop -= 5;
            } else if (pointer.clientY > scrollRect.bottom - scrollThreshold) {
              // 아래로 스크롤
              scrollContainer.scrollTop += 5;
            }
          }
          
          // 플레이스홀더 위치 결정 (더 자연스러운 감지)
          const insertBefore = pointer.clientY < targetCenter;
          const newPosition = insertBefore ? targetItem : targetItem.nextSibling;
          
          // 플레이스홀더가 이미 올바른 위치에 있는지 확인
          if (dragPlaceholder.nextSibling !== newPosition) {
            // 플레이스홀더 이동 애니메이션
            dragPlaceholder.style.transform = 'scale(0.95)';
            
            requestAnimationFrame(() => {
              container.insertBefore(dragPlaceholder, newPosition);
              dragPlaceholder.style.transform = 'scale(1)';
              
              // 플레이스홀더 강조 효과
              dragPlaceholder.style.backgroundColor = '#dbeafe';
              dragPlaceholder.style.borderColor = '#2563eb';
              
              setTimeout(() => {
                dragPlaceholder.style.backgroundColor = '#f3f4f6';
                dragPlaceholder.style.borderColor = '#3b82f6';
              }, 150);
            });
          }
        }
      }
      
      // 드래그 종료 처리 (개선된 버전)
      function handleDragEnd(element, event) {
        if (!isDraggingGlobal || !dragElement) return;
        
        
        // 드롭 애니메이션 효과
        dragElement.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
        dragElement.style.transform = 'scale(1) rotate(0deg)';
        dragElement.style.opacity = '1';
        
        // 최종 위치 계산
        let finalContainer;
        if (dragPlaceholder && dragPlaceholder.parentNode) {
          finalContainer = dragPlaceholder.parentNode;
          const placeholderRect = dragPlaceholder.getBoundingClientRect();
          
          // 최종 위치로 애니메이션
          dragElement.style.left = placeholderRect.left + 'px';
          dragElement.style.top = placeholderRect.top + 'px';
          
          // 애니메이션 완료 후 정리
          setTimeout(() => {
            // 드래그 요소를 올바른 위치에 삽입
            finalContainer.insertBefore(dragElement, dragPlaceholder);
            
            // 드래그 요소 스타일 완전 복원
            dragElement.style.position = '';
            dragElement.style.zIndex = '';
            dragElement.style.opacity = '';
            dragElement.style.transform = '';
            dragElement.style.boxShadow = '';
            dragElement.style.transition = '';
            dragElement.style.pointerEvents = '';
            dragElement.style.left = '';
            dragElement.style.top = '';
            dragElement.style.width = '';
            dragElement.style.height = '';
            dragElement.style.borderRadius = '';
            dragElement.style.backgroundColor = '';
            
            // 텍스트 선택 복원
            dragElement.style.userSelect = '';
            dragElement.style.webkitUserSelect = '';
            dragElement.style.mozUserSelect = '';
            dragElement.style.msUserSelect = '';
            
            // pointer-events 복원
            dragElement.style.pointerEvents = '';
            
            // 전체 문서 텍스트 선택 복원
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
            document.body.style.mozUserSelect = '';
            document.body.style.msUserSelect = '';
            
            // 플레이스홀더 제거
            if (dragPlaceholder) {
              dragPlaceholder.remove();
            }
            
            // 성공 햅틱 피드백
            if (navigator.vibrate) {
              navigator.vibrate([30, 10, 30]);
            }
            
            // Firebase에만 저장 (단일 함수로 간소화)
            saveItemOrderToFirebaseOnly();
            
            // 정리
            dragElement = null;
            dragPlaceholder = null;
            isDraggingGlobal = false;
            currentDragItem = null;
            if (currentLongPressTimer) {
              clearTimeout(currentLongPressTimer);
              currentLongPressTimer = null;
            }
            
          }, 300);
          
        } else {
          // 플레이스홀더가 없는 경우 즉시 정리
          resetDragState();
        }
      }
      
      // 드래그 상태 리셋 함수
      function resetDragState() {
        if (dragElement) {
          // 드래그 요소 스타일 복원
          dragElement.style.position = '';
          dragElement.style.zIndex = '';
          dragElement.style.opacity = '';
          dragElement.style.transform = '';
          dragElement.style.boxShadow = '';
          dragElement.style.transition = '';
          dragElement.style.pointerEvents = '';
          dragElement.style.left = '';
          dragElement.style.top = '';
          dragElement.style.width = '';
          dragElement.style.height = '';
          dragElement.style.borderRadius = '';
          dragElement.style.backgroundColor = '';
          
          // 텍스트 선택 복원
          dragElement.style.userSelect = '';
          dragElement.style.webkitUserSelect = '';
          dragElement.style.mozUserSelect = '';
          dragElement.style.msUserSelect = '';
          
          // pointer-events 복원
          dragElement.style.pointerEvents = '';
        }
        
        // 전체 문서 텍스트 선택 복원
        document.body.style.userSelect = '';
        document.body.style.webkitUserSelect = '';
        document.body.style.mozUserSelect = '';
        document.body.style.msUserSelect = '';
        
        if (dragPlaceholder) {
          dragPlaceholder.remove();
        }
        
        dragElement = null;
        dragPlaceholder = null;
        isDraggingGlobal = false;
        currentDragItem = null;
        if (currentLongPressTimer) {
          clearTimeout(currentLongPressTimer);
          currentLongPressTimer = null;
        }
      }
      
      // Firebase 전용 간소화된 항목 순서 저장
      async function saveItemOrderToFirebaseOnly() {
        try {
          
          // 동기화 중이면 무시 (무한 루프 방지)
          if (isSyncing) {
            return;
          }
          
          // 드래그된 항목 타입에 따라 컨테이너 선택
          let container;
          if (draggedItemType === 'schedule') {
            container = document.getElementById('additionalDays');
          } else {
            container = document.getElementById('userAddedItems');
          }
          if (!container) {
            console.error('컨테이너를 찾을 수 없습니다.', { draggedItemType, currentActiveSection: window.currentActiveSection });
            return;
          }
          
          // 동기화 상태 설정
          isSyncing = true;
          
          // 드래그된 항목의 타입에 따라 구분하여 처리
          const items = Array.from(container.querySelectorAll('.user-added-item[data-item-id], .user-added-item[data-schedule-id]'));
          const newOrder = items.map((item, index) => {
            const itemId = item.getAttribute('data-item-id') || item.getAttribute('data-schedule-id');
            const itemType = item.getAttribute('data-item-type');
            const title = item.querySelector('.item-content .item-title')?.textContent || 
                         item.querySelector('.item-content span')?.textContent || 
                         item.querySelector('button')?.textContent || 
                         'Unknown';
            
            return {
              id: itemId,
              title: title,
              order: index,
              type: itemType
            };
          });
          
          
          if (draggedItemType === 'schedule') {
            // 일정 항목 순서 저장
            await saveScheduleOrderDirect(newOrder);
          } else {
            // 사용자 추가 항목 순서 저장  
            await saveUserItemOrderDirect(newOrder);
          }
          
        } catch (error) {
          console.error('드래그앤드롭 순서 저장 실패:', error);
          updateSyncStatus('순서 저장 실패', 'error');
          
          // 사용자에게 알림
          setTimeout(() => {
            updateSyncStatus('Firebase 연결 실패', 'error');
          }, 2000);
        } finally {
          // 동기화 상태 해제 (즉시 해제하여 실시간 동기화 허용)
          isSyncing = false;
        }
      }
      
      // 사용자 항목 순서 직접 Firebase 저장
      async function saveUserItemOrderDirect(newOrder) {
        try {
          
          if (!window.db || !window.firestore) {
            console.error('Firebase가 초기화되지 않았습니다.');
            return;
          }
          
          // 현재 전역 상태에서 항목들 가져오기
          const currentItems = window.firebaseUserItems || [];
          const currentSection = window.currentActiveSection || '';
          
          // 사용자 항목만 필터링
          const userItems = newOrder.filter(item => item.type === 'user');
          
          // 순서 업데이트
          userItems.forEach((orderInfo, index) => {
            const item = currentItems.find(item => item.id === orderInfo.id && item.section === currentSection);
            if (item) {
              item.order = index;
            }
          });
          
          // Firebase에 저장
          await window.firestore.setDoc(window.firestore.doc(window.db, 'users', 'currentUser'), {
            userAddedItems: currentItems,
            lastUpdated: window.firestore.serverTimestamp()
          }, { merge: true });
          
          // 전역 변수 업데이트
          window.firebaseUserItems = currentItems;
          
          console.log('사용자 항목 순서 Firebase 저장 완료');
          onFirebaseUploadSuccess('항목 순서');
          
        } catch (error) {
          console.error('사용자 항목 순서 저장 실패:', error);
          throw error;
        }
      }
      
      // 일정 순서 직접 Firebase 저장
      async function saveScheduleOrderDirect(newOrder) {
        try {
          console.log('일정 순서 Firebase 저장 시작');
          
          if (!window.db || !window.firestore) {
            console.error('Firebase가 초기화되지 않았습니다.');
            return;
          }
          
          // Firebase에서 현재 일정들을 가져오기
          const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
          if (docSnap.exists() && docSnap.data().customSchedules) {
            const customSchedules = docSnap.data().customSchedules;
            
            // 일정 항목만 필터링
            const scheduleItems = newOrder.filter(item => item.type === 'schedule');
            
            // 새로운 순서로 재정렬
            const reorderedSchedules = [];
            scheduleItems.forEach(orderInfo => {
              const schedule = customSchedules.find(s => s.id === orderInfo.id);
              if (schedule) {
                reorderedSchedules.push(schedule);
              }
            });
            
            // Firebase에 저장
            await window.firestore.updateDoc(
              window.firestore.doc(window.db, 'users', 'currentUser'),
              {
                customSchedules: reorderedSchedules,
                lastUpdated: window.firestore.serverTimestamp()
              }
            );
            
            console.log('일정 순서 Firebase 저장 완료');
            onFirebaseUploadSuccess('일정 순서');
          }
        } catch (error) {
          console.error('일정 순서 저장 실패:', error);
          throw error;
        }
      }
      

      

      

      
      // 개선된 동기화 상태 관리 및 충돌 방지
      let isSyncing = false;
      let lastSyncTimestamp = 0;
      let syncRetryCount = 0;
      const MAX_SYNC_RETRIES = 3;
              const SYNC_COOLDOWN = 50; // 0.05초 쿨다운 (더 빠른 실시간 동기화)
      
      // 오프라인 지원 - 실패한 작업 큐
      const PENDING_OPERATIONS_KEY = 'pendingFirebaseOperations';
      const MAX_PENDING_OPERATIONS = 50; // 최대 대기 작업 수
      
      // 대기 중인 작업 타입
      const OPERATION_TYPES = {
        MARKER_INFO: 'markerInfo',
        ROUTE_INFO: 'routeInfo', 
        USER_ITEM: 'userItem',
        USER_ITEM_UPDATE: 'userItemUpdate',
        USER_ITEM_DELETE: 'userItemDelete',
        USER_ITEM_ORDER: 'userItemOrder',
        CHECKBOX_STATE: 'checkboxState',
        MARKER_SAVE: 'markerSave',
        ROUTE_SAVE: 'routeSave',
        MARKER_DELETE: 'markerDelete',
        ROUTE_DELETE: 'routeDelete',
        SCHEDULE_ADD: 'scheduleAdd',
        SCHEDULE_UPDATE: 'scheduleUpdate',
        SCHEDULE_DELETE: 'scheduleDelete',
        SCHEDULE_ORDER: 'scheduleOrder'
      };
      
      // 동시 수정 방지를 위한 락 맵
      const syncLocks = new Map(); // { key: timestamp }
      const LOCK_TIMEOUT = 5000; // 5초 후 락 자동 해제
      
      // 락 획득 함수
      function acquireLock(key) {
        const now = Date.now();
        const existing = syncLocks.get(key);
        
        // 기존 락이 만료되었거나 없으면 새 락 획득
        if (!existing || (now - existing) > LOCK_TIMEOUT) {
          syncLocks.set(key, now);
          return true;
        }
        
        return false; // 락 획득 실패
      }
      
      // 락 해제 함수
      function releaseLock(key) {
        syncLocks.delete(key);
      }
      
      // 만료된 락 정리 (주기적 실행)
      setInterval(() => {
        const now = Date.now();
        for (const [key, timestamp] of syncLocks.entries()) {
          if ((now - timestamp) > LOCK_TIMEOUT) {
            syncLocks.delete(key);
            console.log(`만료된 락 해제: ${key}`);
          }
        }
      }, LOCK_TIMEOUT);
      
      // 대기 중인 작업 관리 함수들
      function getPendingOperations() {
        try {
          const pending = localStorage.getItem(PENDING_OPERATIONS_KEY);
          return pending ? JSON.parse(pending) : [];
        } catch (error) {
          console.error('대기 작업 로드 실패:', error);
          return [];
        }
      }
      
      function savePendingOperations(operations) {
        try {
          // 최대 개수 제한
          const limitedOps = operations.slice(-MAX_PENDING_OPERATIONS);
          localStorage.setItem(PENDING_OPERATIONS_KEY, JSON.stringify(limitedOps));
          updatePendingOperationsStatus(limitedOps.length);
        } catch (error) {
          console.error('대기 작업 저장 실패:', error);
        }
      }
      
      function addPendingOperation(operation) {
        const pending = getPendingOperations();
        const newOperation = {
          id: `${operation.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          timestamp: Date.now(),
          retryCount: 0,
          ...operation
        };
        
        pending.push(newOperation);
        savePendingOperations(pending);
        
        console.log('오프라인 작업 추가됨:', newOperation);
        return newOperation.id;
      }
      
      function removePendingOperation(operationId) {
        const pending = getPendingOperations();
        const filtered = pending.filter(op => op.id !== operationId);
        savePendingOperations(filtered);
        console.log('대기 작업 제거됨:', operationId);
      }
      
      function updatePendingOperationsStatus(count) {
        const statusIndicator = document.getElementById('pendingOpsStatus');
        if (statusIndicator) {
          if (count > 0) {
            statusIndicator.textContent = `대기 중: ${count}`;
            statusIndicator.style.display = 'block';
            
            // 대기 작업이 많으면 경고 색상으로 변경
            if (count > 5) {
              statusIndicator.style.background = 'rgba(239, 68, 68, 0.9)';
            } else if (count > 2) {
              statusIndicator.style.background = 'rgba(245, 158, 11, 0.9)';
            } else {
              statusIndicator.style.background = 'rgba(59, 130, 246, 0.9)';
            }
          } else {
            statusIndicator.style.display = 'none';
          }
        }
      }
      
      // 대기 작업 자동 재시도 시스템 (안전 장치 추가)
      async function processPendingOperations() {
        if (!navigator.onLine || !window.db || !window.firestore) {
          console.log('오프라인 상태 또는 Firebase 미초기화로 대기 작업 처리 건너뜀');
          return;
        }
        
        const pending = getPendingOperations();
        if (pending.length === 0) return;
        
        // 대기 작업 자동 처리 (CRUD 작업이므로 안전함)
        console.log(`대기 중인 작업 ${pending.length}개 자동 처리 시작`);
        
        for (const operation of pending) {
          try {
            await retryPendingOperation(operation);
            removePendingOperation(operation.id);
          } catch (error) {
            console.error('대기 작업 재시도 실패:', operation.id, error);
            
            // 재시도 횟수 증가
            operation.retryCount = (operation.retryCount || 0) + 1;
            
            // 최대 재시도 횟수 초과 시 제거
            if (operation.retryCount >= MAX_SYNC_RETRIES) {
              console.warn('최대 재시도 횟수 초과로 작업 제거:', operation.id);
              removePendingOperation(operation.id);
            } else {
              // 재시도 카운트 업데이트
              const pending = getPendingOperations();
              const index = pending.findIndex(op => op.id === operation.id);
              if (index !== -1) {
                pending[index] = operation;
                savePendingOperations(pending);
              }
            }
          }
        }
      }
      
      async function retryPendingOperation(operation) {
        const userDocRef = window.firestore.doc(window.db, 'users', 'currentUser');
        
        switch (operation.type) {
          case OPERATION_TYPES.MARKER_INFO:
            await window.firestore.updateDoc(userDocRef, {
              markerInfoData: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('마커 정보 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.ROUTE_INFO:
            await window.firestore.updateDoc(userDocRef, {
              routeInfoData: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('경로 정보 대기 작업 완료:', operation.id);
            break;
            
          
            
          case OPERATION_TYPES.USER_ITEM:
            await window.firestore.updateDoc(userDocRef, {
              userAddedItems: window.firestore.arrayUnion(operation.data),
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('사용자 항목 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.CHECKBOX_STATE:
            await window.firestore.setDoc(userDocRef, {
              preparationCheckboxes: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            }, { merge: true });
            console.log('체크박스 상태 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.MARKER_SAVE:
            await window.firestore.updateDoc(userDocRef, {
              savedUserMarkers: window.firestore.arrayUnion(operation.data),
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('마커 저장 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.ROUTE_SAVE:
            await window.firestore.updateDoc(userDocRef, {
              savedUserRoutes: window.firestore.arrayUnion(operation.data),
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('경로 저장 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.USER_ITEM_UPDATE:
            await window.firestore.setDoc(userDocRef, {
              userAddedItems: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            }, { merge: true });
            console.log('사용자 항목 수정 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.USER_ITEM_DELETE:
            await window.firestore.updateDoc(userDocRef, {
              userAddedItems: window.firestore.arrayRemove(operation.data)
            });
            console.log('사용자 항목 삭제 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.USER_ITEM_ORDER:
            await window.firestore.setDoc(userDocRef, {
              userAddedItems: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            }, { merge: true });
            console.log('사용자 항목 순서 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.MARKER_DELETE:
            await window.firestore.updateDoc(userDocRef, {
              savedUserMarkers: operation.data.markers,
              markerInfoData: operation.data.markerInfo,
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('마커 삭제 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.ROUTE_DELETE:
            await window.firestore.updateDoc(userDocRef, {
              savedUserRoutes: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('경로 삭제 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.SCHEDULE_ADD:
            await window.firestore.updateDoc(userDocRef, {
              customSchedules: window.firestore.arrayUnion(operation.data),
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('일정 추가 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.SCHEDULE_UPDATE:
            await window.firestore.updateDoc(userDocRef, {
              customSchedules: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('일정 수정 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.SCHEDULE_DELETE:
            await window.firestore.updateDoc(userDocRef, {
              customSchedules: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('일정 삭제 대기 작업 완료:', operation.id);
            break;
            
          case OPERATION_TYPES.SCHEDULE_ORDER:
            await window.firestore.updateDoc(userDocRef, {
              customSchedules: operation.data,
              lastUpdated: window.firestore.serverTimestamp()
            });
            console.log('일정 순서 대기 작업 완료:', operation.id);
            break;
            
          default:
            throw new Error(`알 수 없는 작업 타입: ${operation.type}`);
        }
      }
      
      // Firebase 초기화 완료 대기 및 동기화 시작
      function waitForFirebaseAndStartSync() {
        // 동기화 상태 표시기 추가
        addSyncStatusIndicator();
        updateSyncStatus('Firebase 초기화 대기 중...', 'info');
        
        // Firebase가 이미 초기화된 경우
        if (window.db && window.firestore) {
          console.log('Firebase 이미 초기화됨 - 동기화 시작');
          updateSyncStatus('Firebase 연결됨 - 동기화 시작', 'success');
          setupFirebaseSync();
          return;
        }
        
        // Firebase 초기화 완료 이벤트 대기
        const maxWaitTime = 10000; // 최대 10초 대기
        let timeoutId;
        
        const firebaseReadyHandler = () => {
          console.log('Firebase 초기화 완료 이벤트 수신 - 동기화 시작');
          clearTimeout(timeoutId);
          window.removeEventListener('firebaseReady', firebaseReadyHandler);
          updateSyncStatus('Firebase 초기화 완료 - 동기화 시작', 'success');
          setupFirebaseSync();
        };
        
        // 타임아웃 설정
        timeoutId = setTimeout(() => {
          console.warn('Firebase 초기화 시간 초과 - 오프라인 모드로 전환');
          window.removeEventListener('firebaseReady', firebaseReadyHandler);
          updateSyncStatus('Firebase 초기화 실패 - 오프라인 모드', 'error');
          enableOfflineMode();
        }, maxWaitTime);
        
        // Firebase 초기화 완료 이벤트 리스너 등록
        window.addEventListener('firebaseReady', firebaseReadyHandler);
      }
      // Firebase 실시간 동기화 설정
      function setupFirebaseSync() {
        try {
          // Firebase 연결 상태 확인
          if (!window.db || !window.firestore) {
            console.error('Firebase가 초기화되지 않음');
            updateSyncStatus('Firebase 초기화 실패', 'error');
            enableOfflineMode();
            return;
          }
          
          // 동기화 상태 표시기 추가
          addSyncStatusIndicator();
          
          const unsubscribe = window.firestore.onSnapshot(
            window.firestore.doc(window.db, 'users', 'currentUser'), 
            (doc) => {
              if (doc.exists()) {
                const data = doc.data();
                const currentTime = Date.now();
                
                // 마지막 동기화 후 쿨다운 시간 확인 (세부항목 수정은 쿨다운 무시)
                const isDetailItemUpdate = data.existingItemOverrides && 
                  Object.keys(data.existingItemOverrides).length > 0 &&
                  JSON.stringify(window.existingItemOverrides || {}) !== JSON.stringify(data.existingItemOverrides);
                
                if (currentTime - lastSyncTimestamp < SYNC_COOLDOWN && !isDetailItemUpdate) {
                  console.log(`쿨다운 시간으로 인해 동기화 건너뜀 (${currentTime - lastSyncTimestamp}ms < ${SYNC_COOLDOWN}ms)`);
                  return;
                }
                
                console.log('Firebase에서 데이터 수신:', Object.keys(data));
                console.log('실시간 동기화 처리 시작 - lastUpdated:', data.lastUpdated);
                
                // 체크박스 상태 동기화 (Firebase에서 직접 - 현재 섹션만)
                if (data.preparationCheckboxes) {
                  console.log('체크박스 상태 동기화 중...');
                  const currentSection = window.currentActiveSection || '';
                  Object.keys(data.preparationCheckboxes).forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox && checkbox.checked !== data.preparationCheckboxes[id]) {
                      // 현재 섹션의 항목인지 확인
                      const item = window.firebaseUserItems?.find(item => item.id === id);
                      if (item && item.section === currentSection) {
                        checkbox.checked = data.preparationCheckboxes[id];
                      }
                    }
                  });
                  updateSyncStatus('체크박스 동기화 완료', 'success');
                }
                
                // 사용자 추가 항목 동기화 (Firebase에서 직접)
                if (data.userAddedItems) {
                  console.log('사용자 항목 동기화 중...');
                  
                  // 기존 항목과 비교하여 변경사항이 있는지 확인
                  const currentItems = window.firebaseUserItems || [];
                  const newItems = data.userAddedItems;
                  
                  // 항목 개수, ID, 또는 순서가 다르면 업데이트
                  const currentItemsJson = JSON.stringify(currentItems.map(item => ({id: item.id, order: item.order})));
                  const newItemsJson = JSON.stringify(newItems.map(item => ({id: item.id, order: item.order})));
                  
                  if (currentItems.length !== newItems.length || 
                      JSON.stringify(currentItems.map(item => item.id).sort()) !== 
                      JSON.stringify(newItems.map(item => item.id).sort()) ||
                      currentItemsJson !== newItemsJson) {
                    
                    console.log('사용자 항목 변경 감지 - UI 업데이트');
                    console.log('기존 항목 수:', currentItems.length, '새 항목 수:', newItems.length);
                    console.log('순서 변경 감지:', currentItemsJson !== newItemsJson);
                    
                    // 전역 변수 업데이트
                    window.firebaseUserItems = newItems;
                    
                    // 현재 활성 섹션에 맞는 항목만 필터링하여 UI 업데이트
                    const currentSection = window.currentActiveSection || '';
                    const filteredItems = newItems.filter(item => item.section === currentSection);
                    
                    console.log('현재 섹션:', currentSection, '필터링된 항목 수:', filteredItems.length);
                    
                    // UI 즉시 업데이트 (실시간 동기화만으로 처리)
                    displayUserAddedItemsFromFirebase(filteredItems);
                    updateSyncStatus('사용자 항목 동기화 완료', 'success');
                  } else {
                    console.log('사용자 항목 변경 없음 - UI 업데이트 건너뜀');
                  }
                }
                // 기존 항목 숨김/오버라이드 실시간 동기화
                const newHiddenItems = data.hiddenExistingItems || [];
                const newOverrides = data.existingItemOverrides || {};
                
                // 숨김 항목이나 오버라이드가 변경되었는지 확인
                const hiddenChanged = JSON.stringify(window.hiddenExistingItems || []) !== JSON.stringify(newHiddenItems);
                const overridesChanged = JSON.stringify(window.existingItemOverrides || {}) !== JSON.stringify(newOverrides);
                
                if (hiddenChanged || overridesChanged) {
                  console.log('기존 항목 숨김/오버라이드 변경 감지:', {
                    hiddenChanged,
                    overridesChanged,
                    이전숨김수: (window.hiddenExistingItems || []).length,
                    새숨김수: newHiddenItems.length,
                    이전오버라이드수: Object.keys(window.existingItemOverrides || {}).length,
                    새오버라이드수: Object.keys(newOverrides).length
                  });
                  
                  window.hiddenExistingItems = newHiddenItems;
                  window.existingItemOverrides = newOverrides;
                  
                  if (typeof applyOverridesAndHides === 'function') {
                    applyOverridesAndHides();
                  }
                  
                  updateSyncStatus('세부항목 동기화 완료', 'success');
                } else {
                  console.log('기존 항목 숨김/오버라이드 변경 없음');
                }
                
                // 경로 동기화 (Firebase에서 직접)
                if (data.savedUserRoutes) {
                  console.log('경로 동기화 중...');
                  
                  // 기존 경로와 비교하여 변경사항이 있는지 확인
                  const currentRoutes = savedUserRoutes || [];
                  const newRoutes = data.savedUserRoutes;
                  
                  // 경로 개수나 ID가 다르면 업데이트 (강제 업데이트 옵션 추가)
                  const routesChanged = currentRoutes.length !== newRoutes.length || 
                      JSON.stringify(currentRoutes.map(route => route.id).sort()) !== 
                      JSON.stringify(newRoutes.map(route => route.id).sort());
                  
                  // 실시간 동기화 강제 실행 (삭제 감지를 위해)
                  console.log('경로 동기화 강제 실행 - 삭제 감지를 위해');
                  if (true) {  // 항상 업데이트하여 삭제 반영
                    
                    console.log('경로 변경 감지 - UI 업데이트', {
                      이전개수: currentRoutes.length,
                      새개수: newRoutes.length,
                      이전IDs: currentRoutes.map(route => route.id),
                      새IDs: newRoutes.map(route => route.id)
                    });
                    
                    // 기존 렌더 요소를 먼저 제거하고 새 데이터로 갱신
                    clearAllRenderedRoutes();
                    savedUserRoutes = newRoutes;
                    drawAllSavedRoutes();
                    updateRouteRemoveButtons();
                    updateSyncStatus('경로 동기화 완료', 'success');
                  } else {
                    console.log('경로 변경 없음 - UI 업데이트 건너뜀', {
                      routesChanged,
                      lastUpdated: !!data.lastUpdated,
                      현재경로수: currentRoutes.length,
                      새경로수: newRoutes.length
                    });
                  }
                }
                
                // 마커 동기화 (Firebase에서 직접)
                if (data.savedUserMarkers) {
                  console.log('마커 동기화 중...');
                  
                  // 기존 마커와 비교하여 변경사항이 있는지 확인
                  const currentMarkers = window.savedUserMarkers || [];
                  const newMarkers = data.savedUserMarkers;
                  
                  // 마커 개수나 ID가 다르면 업데이트 (강제 업데이트 옵션 추가)
                  const markersChanged = currentMarkers.length !== newMarkers.length || 
                      JSON.stringify(currentMarkers.map(marker => marker.id).sort()) !== 
                      JSON.stringify(newMarkers.map(marker => marker.id).sort());
                  
                  // 실시간 동기화 강제 실행 (삭제 감지를 위해)
                  console.log('마커 동기화 강제 실행 - 삭제 감지를 위해');
                  if (true) {  // 항상 업데이트하여 삭제 반영
                    
                    console.log('마커 변경 감지 - UI 업데이트', {
                      이전개수: currentMarkers.length,
                      새개수: newMarkers.length,
                      이전IDs: currentMarkers.map(marker => marker.id),
                      새IDs: newMarkers.map(marker => marker.id)
                    });
                    
                    // 기존 렌더 요소를 먼저 제거하고 새 데이터로 갱신
                    clearAllRenderedMarkers();
                    window.savedUserMarkers = newMarkers;
                    drawAllSavedMarkers();
                    updateMarkerRemoveButtons();
                    updateSyncStatus('마커 동기화 완료', 'success');
                  } else {
                    console.log('마커 변경 없음 - UI 업데이트 건너뜀', {
                      markersChanged,
                      lastUpdated: !!data.lastUpdated,
                      현재마커수: currentMarkers.length,
                      새마커수: newMarkers.length
                    });
                  }
                }
                
                // 마커 정보 데이터 동기화 (Firebase에서 직접)
                if (data.markerInfoData) {
                  console.log('마커 정보 데이터 동기화 중...');
                  
                  // 기존 마커 정보와 비교하여 변경사항이 있는지 확인
                  const currentMarkerInfo = markerInfoData || {};
                  const newMarkerInfo = data.markerInfoData;
                  
                  // 마커 정보가 다르면 업데이트
                  if (JSON.stringify(currentMarkerInfo) !== JSON.stringify(newMarkerInfo)) {
                    console.log('마커 정보 변경 감지 - 데이터 업데이트');
                    markerInfoData = newMarkerInfo;
                    
                    // 마커 표시 즉시 재렌더링 (이모지 반영)
                    clearAllRenderedMarkers();
                    drawAllSavedMarkers();
                    
                    // 현재 열린 정보창이 마커 정보창이면 갱신
                    try {
                      if (window.currentInfoWindow && window.currentInfoWindow.getContent && window.currentOpenMarkerGroup && window.currentOpenMarkerIndex !== undefined) {
                        console.log('현재 열린 마커 정보창 실시간 갱신:', window.currentOpenMarkerGroup, window.currentOpenMarkerIndex);
                        showMarkerInfoWithData(window.currentOpenMarkerGroup, window.currentOpenMarkerIndex);
                      }
                    } catch (e) {
                      console.log('마커 정보창 갱신 중 오류:', e);
                    }
                    
                    updateSyncStatus('마커 정보 동기화 완료', 'success');
                  } else {
                    console.log('마커 정보 변경 없음 - 업데이트 건너뜀');
                  }
                }

                // 경로 정보 데이터 동기화 (내용/링크)
                if (data.routeInfoData) {
                  console.log('경로 정보 데이터 동기화 중...');
                  const currentRouteInfo = routeInfoData || {};
                  const newRouteInfo = data.routeInfoData;
                  if (JSON.stringify(currentRouteInfo) !== JSON.stringify(newRouteInfo)) {
                    routeInfoData = newRouteInfo;
                    console.log('경로 정보 동기화 완료 (isKmlRoute 포함)', newRouteInfo);
                    
                    // 경로 표시 즉시 재렌더링 (KML 경로의 실선 스타일 반영)
                    clearAllRenderedRoutes();
                    drawAllSavedRoutes();
                    
                    updateSyncStatus('경로 정보 동기화 완료', 'success');
                    
                    // 현재 열린 정보창이 경로 정보창이면 갱신
                    try {
                      if (window.currentInfoWindow && window.currentInfoWindow.getContent && window.currentOpenRouteId) {
                        const route = savedUserRoutes.find(r => r.id === window.currentOpenRouteId);
                        if (route) {
                          console.log('현재 열린 경로 정보창 실시간 갱신:', route.id);
                          showRouteInfo(route, null);
                        }
                      }
                    } catch (e) {
                      console.log('경로 정보창 갱신 중 오류:', e);
                    }
                  }
                }
                
                // 사용자 정의 일정 동기화
                if (data.customSchedules) {
                  console.log('사용자 정의 일정 동기화 중...');
                  restoreCustomSchedules();
                  updateSyncStatus('일정 동기화 완료', 'success');
                }
                
                lastSyncTimestamp = currentTime;
                syncRetryCount = 0;
                updateSyncStatus('동기화 완료', 'success');
                
              } else {
                // 문서가 존재하지 않는 경우 - 기존 데이터 보존
                console.log('Firebase 문서가 존재하지 않음 - 기존 데이터 보존');
                // clearAllData(); // 자동 초기화 비활성화 - 기존 데이터 보호
                updateSyncStatus('새 사용자 - 데이터 준비 완료', 'info');
              }
            }, 
            (error) => {
              console.error('Firebase 실시간 동기화 오류:', error);
              syncRetryCount++;
              
              if (syncRetryCount <= MAX_SYNC_RETRIES) {
                updateSyncStatus(`동기화 오류 (${syncRetryCount}/${MAX_SYNC_RETRIES})`, 'error');
                // 자동 재시도
                setTimeout(() => {
                  console.log('동기화 재시도 중...');
                  setupFirebaseSync();
                }, 2000 * syncRetryCount);
              } else {
                updateSyncStatus('동기화 실패 - 오프라인 모드', 'error');
                // 오프라인 모드로 전환
                enableOfflineMode();
              }
            }
          );
          
          // 구독 해제 함수를 전역으로 저장
          window.unsubscribeFirebase = unsubscribe;
          
          console.log('Firebase 실시간 동기화 설정 완료');
          updateSyncStatus('동기화 연결됨', 'success');
          
        } catch (error) {
          console.error('Firebase 동기화 설정 실패:', error);
          updateSyncStatus('동기화 설정 실패', 'error');
          enableOfflineMode();
        }
      }
      
      // Firebase 데이터 초기화 함수 (안전 장치 추가)
      function clearAllData() {
        // 안전 장치: 사용자 확인 없이는 실행하지 않음
        if (!confirm('⚠️ 경고: 모든 데이터가 삭제됩니다.\n정말로 모든 데이터를 초기화하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.')) {
          console.log('사용자가 데이터 초기화를 취소했습니다.');
          return;
        }
        
        // 이중 확인
        if (!confirm('마지막 확인: 정말로 모든 데이터를 삭제하시겠습니까?')) {
          console.log('사용자가 데이터 초기화를 최종 취소했습니다.');
          return;
        }
        
        console.log('사용자 확인 완료 - 데이터 초기화 시작');
        
        // UI 초기화
        document.querySelectorAll('.prep-checkbox').forEach(cb => cb.checked = false);
        
        // 전역 변수 초기화
        savedUserRoutes = [];
        window.savedUserMarkers = [];
        window.firebaseUserItems = [];
        markerInfoData = {}; // 마커 정보 데이터 초기화
        
        // UI 업데이트
        displayUserAddedItemsFromFirebase([]);
        drawAllSavedRoutes();
        drawAllSavedMarkers();
        updateRouteRemoveButtons();
        
        console.log('데이터 초기화 완료');
        alert('모든 데이터가 초기화되었습니다.');
      }
      
      // Firebase에서 사용자 항목 표시
      function displayUserAddedItemsFromFirebase(userItems) {
        const container = document.getElementById('userAddedItems');
        if (!container) return;
        
        if (!userItems || userItems.length === 0) {
          container.innerHTML = '';
          return;
        }
        
        // 현재 활성 섹션에 맞는 항목만 필터링하고 순서대로 정렬
        const currentSection = window.currentActiveSection || '';
        const filteredItems = userItems
          .filter(item => item.section === currentSection)
          .sort((a, b) => (a.order || 0) - (b.order || 0)); // order 속성으로 정렬
        
        if (filteredItems.length === 0) {
          container.innerHTML = '';
          return;
        }
        
        console.log('순서대로 정렬된 항목들:', filteredItems.map(item => `${item.title}(order:${item.order})`));
        
        let html = '';
        filteredItems.forEach(item => {
          const titleElement = item.link 
            ? `<span onclick="openUserItemLink('${item.link}')" style="cursor: pointer;">${item.title}</span>`
            : `${item.title}`;
          
          html += `
            <div class="user-added-item" data-item-id="${item.id}" data-item-type="user">
              <div class="item-content">
                <input type="checkbox" id="${item.id}" class="prep-checkbox" onchange="saveCheckboxStates()" ${item.checked ? 'checked' : ''}>
                <span>${titleElement}</span>
              </div>
            </div>
          `;
        });
        
        container.innerHTML = html;
        
        // 클릭 가능한 텍스트 끝에 ❗ 표시 추가
        if (typeof appendExclamationToLinks === 'function') {
          appendExclamationToLinks(container);
        }
        
        // 스와이프 기능 활성화
        setTimeout(() => {
          addSwipeToChecklistItems();
        }, 100);
        
        // 항목 터치 시 즉시 스크롤 활성화
        if (isMobile) {
          const scrollableItems = container.querySelectorAll('.user-added-item, .checklist-item');
          scrollableItems.forEach(item => {
            item.addEventListener('touchstart', function(e) {
              // 터치 시작 시 즉시 스크롤 활성화
              const scrollContainer = this.closest('.info-content') || this.closest('#customMapMenu');
              if (scrollContainer) {
                scrollContainer.style.touchAction = 'pan-y';
                scrollContainer.style.webkitOverflowScrolling = 'touch';
              }
            }, { passive: true });
          });
        }
        
        // 사이드패널 터치 이벤트 설정
        setupSidePanelTouchEvents();
        
        // 기존 스와이프 버튼은 제거됨 - 새로운 스와이프 기능 사용
      }
      
      // 클릭 가능한 텍스트(링크 역할) 끝에 ❗ 표시를 위첨자처럼 덧붙이는 함수
      function appendExclamationToLinks(rootEl) {
        try {
          if (!rootEl) return;
          const clickableSelectors = [
            'span[onclick]',
            'button.ticket-btn',
            'a[href]'
          ];
          const nodes = rootEl.querySelectorAll(clickableSelectors.join(','));
          nodes.forEach(node => {
            // 이미 표시가 붙어 있다면 중복 방지
            if (node.querySelector('.link-indicator')) return;
            const text = (node.textContent || '').trim();
            if (!text) return;
            if (text.endsWith('❗')) return;
            const indicator = document.createElement('span');
            indicator.className = 'link-indicator';
            indicator.textContent = '❗';
            indicator.setAttribute('aria-hidden', 'true');
            indicator.style.cssText = [
              'display:inline-block',
              'font-size:0.6em',
              'line-height:1',
              'vertical-align:super',
              'margin-left:4px',
              'position:relative',
              'top:-0.1em'
            ].join(';');
            node.appendChild(indicator);
          });
        } catch (e) {
          console.warn('링크 강조 처리 중 오류:', e);
        }
      }
      
      // 오프라인 모드 활성화
      function enableOfflineMode() {
        console.log('오프라인 모드 활성화');
        updateSyncStatus('오프라인 모드', 'warning');
      }
      
      // 동기화 상태 표시기 추가
      function addSyncStatusIndicator() {
        if (document.getElementById('syncStatusIndicator')) return;
        
        const statusDiv = document.createElement('div');
        statusDiv.id = 'syncStatusIndicator';
        statusDiv.style.cssText = `
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
          padding: 8px 12px;
          border-radius: 20px;
          font-size: 12px;
          font-weight: 600;
          color: white;
          background: rgba(0, 0, 0, 0.7);
          backdrop-filter: blur(10px);
          transition: all 0.3s ease;
          opacity: 0;
          transform: translateX(-50%) translateY(-20px);
        `;
        statusDiv.textContent = '동기화 준비 중...';
        document.body.appendChild(statusDiv);
        
        // 대기 작업 상태 표시기 추가
        if (!document.getElementById('pendingOpsStatus')) {
          const pendingDiv = document.createElement('div');
          pendingDiv.id = 'pendingOpsStatus';
          pendingDiv.style.cssText = `
            position: fixed;
            top: 60px;
            right: 10px;
            z-index: 1000;
            padding: 6px 12px;
            border-radius: 15px;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            font-size: 12px;
            font-weight: 500;
            display: none;
            backdrop-filter: blur(10px);
            cursor: pointer;
          `;
          
          pendingDiv.onclick = () => {
            showPendingOperationsDialog();
          };
          
          document.body.appendChild(pendingDiv);
          
          // 초기 대기 작업 상태 업데이트
          const pendingOps = getPendingOperations();
          updatePendingOperationsStatus(pendingOps.length);
        }
        
        // 애니메이션으로 표시
        setTimeout(() => {
          statusDiv.style.opacity = '1';
          statusDiv.style.transform = 'translateX(-50%) translateY(0)';
        }, 100);
      }
      
      // 동기화 상태 업데이트
      function updateSyncStatus(message, type = 'info') {
        // indicator가 없으면 생성
        let indicator = document.getElementById('syncStatusIndicator');
        if (!indicator) {
          addSyncStatusIndicator();
          indicator = document.getElementById('syncStatusIndicator');
        }
        
        if (!indicator) return; // 여전히 없으면 종료
        
        const colors = {
          success: '#10b981',
          error: '#ef4444',
          warning: '#f59e0b',
          info: '#3b82f6'
        };
        
        indicator.textContent = message;
        indicator.style.background = colors[type] || colors.info;
        
        // 표시하기
        indicator.style.opacity = '1';
        indicator.style.transform = 'translateX(-50%) translateY(0)';
        
        // 동기화 완료 시 1.5초, 그 외엔 3초 후 자동 숨김
        const hideDelay = (type === 'success' && message.includes('동기화 완료')) ? 1500 : 3000;
        
        setTimeout(() => {
          indicator.style.opacity = '0';
          indicator.style.transform = 'translateX(-50%) translateY(-20px)';
          setTimeout(() => {
            if (indicator.parentNode) {
              indicator.parentNode.removeChild(indicator);
            }
          }, 300);
        }, hideDelay);
      }
      
      // 동기화 완료 배지 표시 (기존 중앙 상단 스타일 활용)
      function showSyncBadge() {
        // 기존 updateSyncStatus 시스템을 활용하여 간단하게 처리
        // 별도 배지 생성하지 않고 기존 시스템 사용
        console.log('동기화 완료 - 기존 상태 표시기 활용');
      }
      
      // Firebase 업로드 성공 시 호출되는 함수
      function onFirebaseUploadSuccess(operationType = '데이터') {
        const message = `${operationType} 동기화 완료`;
        
        // 즉시 동기화 완료 배지 표시
        console.log(`Firebase 업로드 성공: ${operationType} - 배지 표시`);
        updateSyncStatus(message, 'success');
        
        // 추가 로깅으로 확인
        setTimeout(() => {
          const indicator = document.getElementById('syncStatusIndicator');
          console.log('배지 표시 상태:', indicator ? '표시됨' : '없음');
        }, 100);
      }
      
      // 대기 작업 상세 다이얼로그 표시 함수
      function showPendingOperationsDialog() {
        const pendingOps = getPendingOperations();
        if (pendingOps.length === 0) {
          alert('대기 중인 작업이 없습니다.');
          return;
        }
        
        // 기존 다이얼로그가 있으면 제거
        const existingDialog = document.getElementById('pendingOpsDialog');
        const existingOverlay = document.getElementById('dialogOverlay');
        if (existingDialog) existingDialog.remove();
        if (existingOverlay) existingOverlay.remove();
        
        // 오버레이 생성
        const overlay = document.createElement('div');
        overlay.id = 'dialogOverlay';
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          z-index: 1000;
          display: flex;
          align-items: center;
          justify-content: center;
        `;
        
        // 다이얼로그 생성
        const dialog = document.createElement('div');
        dialog.id = 'pendingOpsDialog';
        dialog.style.cssText = `
          background: white;
          border-radius: 16px;
          padding: 0;
          max-width: 90vw;
          max-height: 80vh;
          width: ${window.innerWidth < 768 ? '95vw' : '500px'};
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
          overflow: hidden;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;
        
        // 작업 타입별 한글 이름 매핑
        const operationTypeNames = {
          'USER_ITEM_ADD': '항목 추가',
          'USER_ITEM_UPDATE': '항목 수정',
          'USER_ITEM_DELETE': '항목 삭제',
          'ROUTE_SAVE': '경로 저장',
          'ROUTE_DELETE': '경로 삭제',
          'ROUTE_INFO_UPDATE': '경로 정보 수정',
          'MARKER_SAVE': '마커 저장',
          'MARKER_DELETE': '마커 삭제',
          'MARKER_INFO_UPDATE': '마커 정보 수정',
          'CHECKBOX_STATE_SAVE': '체크박스 상태 저장',
          'EXISTING_ITEM_OVERRIDE': '기존 항목 수정'
        };
        
        // 작업 목록 HTML 생성
        let operationsHtml = '';
        pendingOps.forEach((op, index) => {
          const typeName = operationTypeNames[op.type] || op.type;
          const timestamp = new Date(op.timestamp).toLocaleString('ko-KR');
          const retryCount = op.retryCount || 0;
          
          operationsHtml += `
            <div style="
              padding: 12px 16px;
              border-bottom: 1px solid #f0f0f0;
              display: flex;
              justify-content: space-between;
              align-items: center;
            ">
              <div style="flex: 1;">
                <div style="font-weight: 600; color: #333; margin-bottom: 4px;">
                  ${typeName}
                </div>
                <div style="font-size: 12px; color: #666;">
                  ${op.data?.title || op.data?.name || '데이터 없음'}
                </div>
                <div style="font-size: 11px; color: #999; margin-top: 2px;">
                  ${timestamp} ${retryCount > 0 ? `(재시도 ${retryCount}회)` : ''}
                </div>
              </div>
              <div style="
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: ${retryCount > 2 ? '#ef4444' : retryCount > 0 ? '#f59e0b' : '#3b82f6'};
                margin-left: 12px;
              "></div>
            </div>
          `;
        });
        
        dialog.innerHTML = `
          <div style="
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
          ">
            <h3 style="margin: 0; font-size: 18px; font-weight: 600;">
              대기 중인 작업 (${pendingOps.length}개)
            </h3>
            <button onclick="closePendingOperationsDialog()" style="
              background: none;
              border: none;
              color: white;
              font-size: 24px;
              cursor: pointer;
              padding: 0;
              width: 30px;
              height: 30px;
              display: flex;
              align-items: center;
              justify-content: center;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.2)'" 
               onmouseout="this.style.backgroundColor='transparent'">
              ×
            </button>
          </div>
          <div style="max-height: 400px; overflow-y: auto;">
            ${operationsHtml}
          </div>
          <div style="
            padding: 16px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
          ">
            <div style="font-size: 12px; color: #666;">
              네트워크 연결 시 자동으로 동기화됩니다
            </div>
            <div style="display: flex; gap: 8px;">
              <button onclick="retryAllPendingOperations()" style="
                background: #3b82f6;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 500;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='#2563eb'" 
                 onmouseout="this.style.backgroundColor='#3b82f6'">
                지금 동기화
              </button>
              <button onclick="clearAllPendingOperations()" style="
                background: #ef4444;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 500;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='#dc2626'" 
                 onmouseout="this.style.backgroundColor='#ef4444'">
                모두 삭제
              </button>
            </div>
          </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // 오버레이 클릭 시 닫기
        overlay.onclick = (e) => {
          if (e.target === overlay) {
            closePendingOperationsDialog();
          }
        };
        
        // ESC 키로 닫기
        const handleEsc = (e) => {
          if (e.key === 'Escape') {
            closePendingOperationsDialog();
            document.removeEventListener('keydown', handleEsc);
          }
        };
        document.addEventListener('keydown', handleEsc);
      }
      
      // 대기 작업 다이얼로그 닫기
      function closePendingOperationsDialog() {
        removeElements('pendingOpsDialog', 'dialogOverlay');
      }
      
      // 모든 대기 작업 재시도
      async function retryAllPendingOperations() {
        if (!navigator.onLine) {
          alert('네트워크에 연결되어 있지 않습니다.');
          return;
        }
        
        try {
          await processPendingOperations();
          closePendingOperationsDialog();
          alert('대기 작업 동기화를 시작했습니다.');
        } catch (error) {
          console.error('대기 작업 재시도 실패:', error);
          alert('동기화 중 오류가 발생했습니다.');
        }
      }
      
      // 모든 대기 작업 삭제
      function clearAllPendingOperations() {
        if (!confirm('모든 대기 작업을 삭제하시겠습니까?\n삭제된 작업은 복구할 수 없습니다.')) {
          return;
        }
        
        localStorage.removeItem(PENDING_OPERATIONS_KEY);
        updatePendingOperationsStatus(0);
        closePendingOperationsDialog();
        alert('모든 대기 작업이 삭제되었습니다.');
      }
      
      // 일정 추가 다이얼로그 표시 함수
      function showAddScheduleDialog() {
        // 기존 다이얼로그가 있으면 제거
        const existingDialog = document.getElementById('addScheduleDialog');
        const existingOverlay = document.getElementById('dialogOverlay');
        if (existingDialog) {
          existingDialog.remove();
        }
        if (existingOverlay) {
          existingOverlay.remove();
        }
        
        // 배경 오버레이 생성
        const overlay = document.createElement('div');
        overlay.id = 'dialogOverlay';
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 999;
          background: transparent;
        `;
        overlay.onclick = function() {
          closeAddScheduleDialog();
        };
        overlay.ontouchstart = function(e) {
          e.preventDefault();
          closeAddScheduleDialog();
        };
        overlay.ontouchend = function(e) {
          e.preventDefault();
          closeAddScheduleDialog();
        };
        
        // 다이얼로그 생성
        const dialog = document.createElement('div');
        dialog.id = 'addScheduleDialog';
        dialog.style.cssText = `
          position: fixed;
          top: 120px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
          width: 380px;
          max-width: 90vw;
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.12);
          border-radius: 20px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.12);
          backdrop-filter: blur(24px);
          -webkit-backdrop-filter: blur(24px);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          overflow: hidden;
          transition: all 0.3s ease;
        `;
        
        // 다이얼로그 내부 클릭/터치 시 이벤트 버블링 방지
        dialog.onclick = function(e) {
          e.stopPropagation();
        };
        dialog.ontouchstart = function(e) {
          e.stopPropagation();
        };
        dialog.ontouchend = function(e) {
          e.stopPropagation();
        };
        
        dialog.innerHTML = `
          <style>
            #scheduleTitle::placeholder {
              color: rgba(0, 0, 0, 0.5);
            }
          </style>
          <div class="edit-form-header">
            <h4>새 일정 추가</h4>
            <button type="button" onclick="closeAddScheduleDialog()" class="close-btn">×</button>
          </div>
          <div style="padding: 20px 24px 24px 24px;">
            <div style="margin-bottom: 24px;">
              <input type="text" id="scheduleTitle" placeholder="일정 제목을 입력하세요" 
                     style="width: 100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px);" 
                     onfocus="this.style.background='rgba(255, 255, 255, 0.18)'; this.style.boxShadow='0 0 0 2px rgba(16, 185, 129, 0.3)'"
                     onblur="this.style.background='rgba(255, 255, 255, 0.12)'; this.style.boxShadow='none'"
                     onkeypress="if(event.key==='Enter') addNewSchedule()">
            </div>

            <div style="text-align: center;">
              <button onclick="addNewSchedule()" style="background: rgba(255, 255, 255, 0.12); color: #000; border: none; border-radius: 12px; padding: 14px 32px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px); min-width: 120px;" onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'; this.style.transform='translateY(0)'">
                추가
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
        document.body.appendChild(dialog);
        
        // 제목 입력란에 포커스
        setTimeout(() => {
          document.getElementById('scheduleTitle').focus();
        }, 100);
      }
      
      // 일정 추가 다이얼로그 닫기 함수
      function closeAddScheduleDialog() {
        removeElements('addScheduleDialog', 'dialogOverlay');
      }
      
      // 추가 폼 표시 함수
      function showAddForm() {
        const form = document.getElementById('addItemForm');
        const toggleBtn = document.getElementById('toggleAddBtn');
        
        // 폼을 보여줄 때
        form.style.display = 'block';
        toggleBtn.style.display = 'none'; // 버튼 숨기기
        
        // 제목 입력란에 포커스
        setTimeout(() => {
          document.getElementById('newItemTitle').focus();
        }, 100);
      }
      
      // 추가 폼 숨기기 함수
      function hideAddForm() {
        const form = document.getElementById('addItemForm');
        const toggleBtn = document.getElementById('toggleAddBtn');
        
        // 폼을 숨기고 버튼을 다시 표시
        form.style.display = 'none';
        toggleBtn.style.display = 'block';
        
        // 폼 내용 초기화
        document.getElementById('newItemTitle').value = '';
        document.getElementById('newItemLink').value = '';
      }
      
      // 폼 지우기 함수
      function clearForm() {
        document.getElementById('newItemTitle').value = '';
        document.getElementById('newItemLink').value = '';
        document.getElementById('newItemTitle').focus();
      }
      
      // 새 항목 추가 함수
      async function addNewItem() {
        const titleInput = document.getElementById('newItemTitle');
        const linkInput = document.getElementById('newItemLink');
        
        const title = titleInput.value.trim();
        const link = linkInput.value.trim();
        
        if (!title) {
          alert('항목 제목을 입력해주세요.');
          titleInput.focus();
          return;
        }
        
        try {
          // 현재 섹션의 기존 항목들에서 최대 order 값 찾기
          const currentSection = window.currentActiveSection || '';
          const currentItems = window.firebaseUserItems || [];
          const sectionItems = currentItems.filter(item => item.section === currentSection);
          const maxOrder = sectionItems.length > 0 ? Math.max(...sectionItems.map(item => item.order || 0)) : -1;
          
          // 새 항목 생성
          const itemId = 'user_' + Date.now();
          const newItem = {
            id: itemId,
            title: title,
            description: '', // 빈 설명으로 설정하여 기존 항목과 동일한 스타일 유지
            link: link || null,
            checked: false,
            timestamp: new Date().toISOString(),
            section: window.currentActiveSection || '', // 현재 활성 섹션 정보 추가
            type: 'user_item',
            order: maxOrder + 1 // 맨 아래에 배치되도록 order 설정
          };
          
          // Firebase에 저장
          if (window.db && window.firestore) {
            await window.firestore.updateDoc(
              window.firestore.doc(window.db, 'users', 'currentUser'),
              {
                userAddedItems: window.firestore.arrayUnion(newItem),
                lastUpdated: window.firestore.serverTimestamp()
              }
            );
            
            onFirebaseUploadSuccess('새 항목');
          }
          
          // 폼 초기화 및 숨기기
          clearForm();
          hideAddForm();
          
        } catch (error) {
          console.error('항목 추가 실패:', error);
          
          // 오프라인 지원 - 실패한 작업을 대기 큐에 추가
          const itemData = {
            id: itemId,
            title: title,
            description: '',
            link: link || null,
            checked: false,
            timestamp: new Date().toISOString(),
            section: window.currentActiveSection || '',
            type: 'user_item'
          };
          
          const operationId = addPendingOperation({
            type: OPERATION_TYPES.USER_ITEM,
            data: itemData
          });
          
          // 구체적인 오류 메시지
          let errorMessage = '항목이 임시 저장되었습니다.';
          if (error.message.includes('Firebase') || error.code === 'unavailable') {
            errorMessage = '네트워크 연결 문제로 임시 저장되었습니다. 연결 시 자동으로 동기화됩니다.';
          } else if (error.code === 'permission-denied') {
            errorMessage = '권한 문제로 임시 저장되었습니다. 로그인을 확인해주세요.';
          }
          
          console.log(`항목 추가 오프라인 저장 완료 (작업 ID: ${operationId})`);
          alert(errorMessage);
          
          // 폼 초기화 및 숨기기
          clearForm();
          hideAddForm();
        }
      }
      
      // ============================================================================
      // 📅 SCHEDULE MODULE - 일정(현장) 관리
      // ============================================================================
      
      // 새 일정 추가 함수
      async function addNewSchedule() {
        const titleInput = document.getElementById('scheduleTitle');
        
        const title = titleInput.value.trim();
        
        if (!title) {
          alert('일정 제목을 입력해주세요.');
          titleInput.focus();
          return;
        }
        
        try {
          // 새 일정 버튼 생성 (HTML 문자열 방식)
          const scheduleId = 'schedule_' + Date.now();
          
          const scheduleHtml = `
            <div class="user-added-item" data-item-id="${scheduleId}" data-item-type="schedule" data-schedule-id="${scheduleId}" data-schedule-title="${title}">
              <div class="item-content">
                <button class="toggle-btn" onclick="showScheduleInfo('${title}')" data-schedule-id="${scheduleId}" data-schedule-title="${title}">${title}</button>
              </div>
            </div>
          `;
          
          // additionalDays 컨테이너에 추가
          const additionalDaysContainer = document.getElementById('additionalDays');
          additionalDaysContainer.innerHTML += scheduleHtml;
          
          // 스와이프 기능 활성화
          setTimeout(() => {
            addSwipeToScheduleItems();
          }, 100);
          
          // Firebase에 저장
          if (window.db && window.firestore) {
            const scheduleData = {
              id: scheduleId,
              title: title,
              timestamp: new Date().toISOString(),
              type: 'custom_schedule'
            };
            
            await window.firestore.updateDoc(
              window.firestore.doc(window.db, 'users', 'currentUser'),
              {
                customSchedules: window.firestore.arrayUnion(scheduleData),
                lastUpdated: window.firestore.serverTimestamp()
              }
            );
            
            onFirebaseUploadSuccess('일정 추가');
          }
          
          // 다이얼로그 닫기
          closeAddScheduleDialog();
          
        } catch (error) {
          console.error('일정 추가 실패:', error);
          
          // 오프라인 지원 - 실패한 작업을 대기 큐에 추가
          const scheduleData = {
            id: scheduleId,
            title: title,
            timestamp: new Date().toISOString(),
            type: 'custom_schedule'
          };
          
          const operationId = addPendingOperation({
            type: OPERATION_TYPES.SCHEDULE_ADD,
            data: scheduleData
          });
          
          // 구체적인 오류 메시지
          let errorMessage = '일정이 임시 저장되었습니다.';
          if (error.message.includes('Firebase') || error.code === 'unavailable') {
            errorMessage = '네트워크 연결 문제로 임시 저장되었습니다. 연결 시 자동으로 동기화됩니다.';
          } else if (error.code === 'permission-denied') {
            errorMessage = '권한 문제로 임시 저장되었습니다. 로그인을 확인해주세요.';
          }
          
          console.log(`일정 추가 오프라인 저장 완료 (작업 ID: ${operationId})`);
          alert(errorMessage);
          
          // 다이얼로그 닫기
          closeAddScheduleDialog();
        }
      }
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      // 해당 일정의 마커와 경로를 화면에 맞추는 함수
      function fitScheduleItemsToScreen(scheduleTitle) {
        console.log('해당 일정의 마커와 경로를 화면에 맞추기:', scheduleTitle);
        
        const bounds = new google.maps.LatLngBounds();
        let hasItems = false;
        
        // 1. 해당 일정의 저장된 경로들 찾기
        const scheduleRoutes = savedUserRoutes.filter(route => route.location === scheduleTitle);
        console.log('찾은 경로:', scheduleRoutes.length, '개');
        
        scheduleRoutes.forEach(route => {
          if (route.path && route.path.length > 0) {
            route.path.forEach(point => {
              bounds.extend(new google.maps.LatLng(point.lat, point.lng));
              hasItems = true;
            });
          }
        });
        
        // 2. 해당 일정의 저장된 마커들 찾기
        const scheduleMarkers = (window.savedUserMarkers || []).filter(markerGroup => markerGroup.location === scheduleTitle);
        console.log('찾은 마커 그룹:', scheduleMarkers.length, '개');
        
        scheduleMarkers.forEach(markerGroup => {
          if (markerGroup.markers && markerGroup.markers.length > 0) {
            markerGroup.markers.forEach(marker => {
              bounds.extend(new google.maps.LatLng(marker.lat, marker.lng));
              hasItems = true;
            });
          }
        });
        
        // 3. 마커나 경로가 있으면 화면에 맞추기
        if (hasItems) {
          console.log('마커/경로 발견 - 화면에 맞추기 실행');
          
          // 약간의 여백을 위해 패딩 추가
          const paddingOptions = {
            top: isMobile ? 100 : 80,
            bottom: isMobile ? 100 : 80,
            left: isMobile ? 50 : 250,  // 사이드메뉴 공간 고려
            right: isMobile ? 50 : 80
          };
          
          // 지도 화면에 맞추기
          map.fitBounds(bounds, paddingOptions);
          
          // 너무 많이 확대되는 것을 방지 (최대 줌 레벨 제한)
          setTimeout(() => {
            const currentZoom = map.getZoom();
            if (currentZoom > 16) {
              map.setZoom(16);
            }
          }, 100);
          
          console.log('화면 맞추기 완료');
        } else {
          console.log('해당 일정에 마커나 경로가 없음');
        }
      }
      
      // ============================================================================
      // 💬 UI & INTERACTION MODULE - UI 상호작용 및 다이얼로그
      // ============================================================================
      
      // 일정 정보 표시 함수
      function showScheduleInfo(title) {
        // 기존 정보창이 있으면 제거
        const existingInfo = document.getElementById('preparationInfo');
        if (existingInfo) {
          existingInfo.remove();
        }
        
        // 다른 일정 클릭시 스와이프 상태 해제
        clearAllSwipeStates();
        
        // 현재 활성 섹션 설정
        window.currentActiveSection = title;
        
        // 정보창 생성
        const infoDiv = document.createElement('div');
        infoDiv.id = 'preparationInfo';
        infoDiv.innerHTML = `
          <div style="padding: 28px 24px 8px 24px; text-align: center; position: relative; flex-shrink: 0;">
            <h3 style="color: #000; margin: 0; font-size: 18px; font-weight: 500; letter-spacing: -0.01em;">${title}</h3>
            <button type="button" onclick="closeScheduleInfo()" class="schedule-close-btn" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 20px; color: #666; cursor: pointer; padding: 5px; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;">×</button>
          </div>
          <div class="info-content" style="touch-action: pan-y; -webkit-overflow-scrolling: touch; overscroll-behavior: contain;">
              <div class="info-section">
                <!-- 사용자 추가 항목들이 여기에 표시됩니다 -->
                <div id="userAddedItems"></div>
                
                <!-- 새 항목 추가 버튼 -->
                <div class="add-item-section">
                  <button type="button" onclick="showAddForm()" class="toggle-add-btn" id="toggleAddBtn">+ 새 항목 추가</button>
                </div>
                
                <!-- 새 항목 추가 폼 (처음에는 숨김) -->
                <div class="add-item-form" id="addItemForm" style="display: none;">
                  <div class="edit-form-header">
                    <h4>새 항목 추가</h4>
                    <button type="button" onclick="hideAddForm()" class="close-btn">×</button>
                  </div>
                  <div style="padding: 20px 24px 24px 24px;">
                    <div class="form-group">
                      <input type="text" id="newItemTitle" placeholder="항목 제목을 입력하세요" maxlength="50">
                      <input type="url" id="newItemLink" placeholder="링크를 입력하세요 (선택사항)" maxlength="200">
                    </div>
                    <div class="form-buttons">
                      <button type="button" onclick="addNewItem()" class="add-btn">추가</button>
                    </div>
                  </div>
                </div>
              </div>
            
            <!-- 저장된 경로/마커 제거 버튼 섹션 -->
            <div class="info-section">
              <div id="${title.replace(/[^a-zA-Z0-9가-힣]/g, '')}RemoveButtons" style="display: none;">
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                  <button class="route-remove-btn" onclick="removeRoutesByLocation('${title}')" style="flex: 1;">경로제거</button>
                  <button class="route-remove-btn" onclick="removeMarkersByLocation('${title}')" style="flex: 1;">마커제거</button>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // 정보창을 지도 위에 표시
        document.body.appendChild(infoDiv);
        
        // 모바일에서 스크롤 최적화를 위한 추가 설정
        if (isMobile) {
          const infoContent = infoDiv.querySelector('.info-content');
          if (infoContent) {
            // 터치 이벤트 최적화 - 즉시 스크롤 활성화
            infoContent.addEventListener('touchstart', function(e) {
              // 터치 시작 시 즉시 스크롤 활성화
              this.style.touchAction = 'pan-y';
              this.style.webkitOverflowScrolling = 'touch';
              this.scrollTop = this.scrollTop;
            }, { passive: true });
            
            infoContent.addEventListener('touchmove', function(e) {
              // 스크롤 중 부드러운 애니메이션 비활성화
              this.style.scrollBehavior = 'auto';
            }, { passive: true });
            
            infoContent.addEventListener('touchend', function(e) {
              // 터치 종료 시 부드러운 스크롤 복원
              setTimeout(() => {
                this.style.scrollBehavior = 'smooth';
              }, 100);
            }, { passive: true });
          }
        }
        
        // 클릭 가능한 텍스트 끝에 ❗ 표시 추가
        if (typeof appendExclamationToLinks === 'function') {
          appendExclamationToLinks(infoDiv);
        }
        
        // 저장된 체크박스 상태 복원
        setTimeout(() => {
          restoreCheckboxStates();
          // 스와이프 기능 초기화
          initializeSwipeDelete();
          if (typeof applyOverridesAndHides === 'function') {
            applyOverridesAndHides();
          }
        }, 50);
        
        // 경로제거 버튼 상태 업데이트
        updateRouteRemoveButtons();
        // 마커제거 버튼 상태 업데이트
        updateMarkerRemoveButtons();
        
        // 해당 일정의 마커와 경로를 화면에 맞추기 (정보창 표시 후 지연)
        setTimeout(() => {
          fitScheduleItemsToScreen(title);
        }, 300);
        
        // 정보창 위치 조정 - 모바일 최적화
        setTimeout(() => {
          const menu = document.getElementById('customMapMenu');
          const menuRect = menu.getBoundingClientRect();
          const mapElement = document.getElementById('map');
          const mapRect = mapElement.getBoundingClientRect();
          
          if (isMobile) {
            // 모바일: 화면 중앙에 표시
            infoDiv.style.left = '50%';
            infoDiv.style.transform = 'translateX(-50%)';
            infoDiv.style.top = '80px';
          } else {
            // 데스크톱: 사이드메뉴 오른쪽에 표시
            infoDiv.style.left = (menuRect.right + 10) + 'px';
            infoDiv.style.top = menuRect.top + 'px';
            infoDiv.style.transform = 'none';
          }
        }, 100);
      }
      // 저장된 사용자 정의 일정들 복원 함수
      async function restoreCustomSchedules() {
        try {
          if (!window.db || !window.firestore) return;
          
          const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
          if (docSnap.exists() && docSnap.data().customSchedules) {
            const customSchedules = docSnap.data().customSchedules;
            
            const additionalDaysContainer = document.getElementById('additionalDays');
            if (additionalDaysContainer) {
              let html = '';
              
              customSchedules.forEach(schedule => {
                html += `
                  <div class="user-added-item" data-item-id="${schedule.id}" data-item-type="schedule" data-schedule-id="${schedule.id}" data-schedule-title="${schedule.title}">
                    <div class="item-content">
                      <button class="toggle-btn" onclick="showScheduleInfo('${schedule.title}', '${schedule.description || ''}')" data-schedule-id="${schedule.id}" data-schedule-title="${schedule.title}">${schedule.title}</button>
                    </div>
                  </div>
                `;
              });
              
              additionalDaysContainer.innerHTML = html;
              
              // 스와이프 기능 활성화
              setTimeout(() => {
                addSwipeToScheduleItems();
              }, 100);
            }
          }
        } catch (error) {
          console.error('사용자 정의 일정 복원 실패:', error);
        }
      }
      // 일정 컨텍스트 메뉴 표시 함수
      function showScheduleContextMenu(e, scheduleBtn) {
        // 기존 컨텍스트 메뉴가 있으면 제거
        const existingMenu = document.getElementById('scheduleContextMenu');
        if (existingMenu) {
          existingMenu.remove();
        }
        
        // 컨텍스트 메뉴 생성
        const contextMenu = document.createElement('div');
        contextMenu.id = 'scheduleContextMenu';
        contextMenu.style.cssText = `
          position: fixed;
          z-index: 1000;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 12px;
          box-shadow: 0 8px 25px rgba(0,0,0,0.15);
          backdrop-filter: blur(20px);
          -webkit-backdrop-filter: blur(20px);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          overflow: hidden;
          animation: slideIn 0.2s ease-out;
          min-width: 150px;
        `;
        
        const scheduleId = scheduleBtn.getAttribute('data-schedule-id');
        const scheduleTitle = scheduleBtn.getAttribute('data-schedule-title');
        
        contextMenu.innerHTML = `
          <div style="padding: 8px 0;">
            <button onclick="editSchedule('${scheduleId}', '${scheduleTitle}')" 
                    style="width: 100%; padding: 12px 16px; background: none; border: none; text-align: left; cursor: pointer; font-size: 14px; color: #1f2937; transition: background-color 0.2s ease;">
              ✏️ 수정
            </button>
            <button onclick="deleteSchedule('${scheduleId}', '${scheduleTitle}')" 
                    style="width: 100%; padding: 12px 16px; background: none; border: none; text-align: left; cursor: pointer; font-size: 14px; color: #ef4444; transition: background-color 0.2s ease;">
              🗑️ 삭제
            </button>
          </div>
        `;
        
        // 메뉴 위치 설정
        contextMenu.style.left = e.clientX + 'px';
        contextMenu.style.top = e.clientY + 'px';
        
        document.body.appendChild(contextMenu);
        
        // 메뉴 외부 클릭/터치 시 닫기
        setTimeout(() => {
          const closeMenu = () => {
            contextMenu.remove();
            document.removeEventListener('click', closeMenu);
            document.removeEventListener('touchend', closeMenu);
          };
          
          document.addEventListener('click', closeMenu);
          document.addEventListener('touchend', closeMenu);
        }, 100);
      }
      
      // 일정 수정 함수
      function editSchedule(scheduleId, currentTitle) {
        // 컨텍스트 메뉴 닫기
        const contextMenu = document.getElementById('scheduleContextMenu');
        if (contextMenu) {
          contextMenu.remove();
        }
        
        // 모든 스와이프 상태 해제
        clearAllSwipeStates();
        
        // 일정 수정 다이얼로그 표시
        showEditScheduleDialog(scheduleId, currentTitle);
      }
      
      // 일정 수정 다이얼로그 표시 함수
      function showEditScheduleDialog(scheduleId, currentTitle) {
        // 기존 다이얼로그가 있으면 제거
        const existingDialog = document.getElementById('editScheduleDialog');
        if (existingDialog) {
          existingDialog.remove();
        }
        
        // 다이얼로그 생성
        const dialog = document.createElement('div');
        dialog.id = 'editScheduleDialog';
        dialog.style.cssText = `
          position: fixed;
          top: 120px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
          width: 400px;
          max-width: 90vw;
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.12);
          border-radius: 20px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.12);
          backdrop-filter: blur(24px);
          -webkit-backdrop-filter: blur(24px);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          overflow: hidden;
        `;
        
        dialog.innerHTML = `
          <div class="edit-form-header">
            <h4>일정 수정</h4>
            <button type="button" onclick="closeEditScheduleDialog()" class="close-btn">×</button>
          </div>
          <div style="padding: 20px 24px 24px 24px;">
            <div style="margin-bottom: 24px;">
              <input type="text" id="editScheduleTitle" placeholder="일정 제목을 입력하세요" 
                     value="${currentTitle}" maxlength="50"
                     style="width: 100%; padding: 16px 18px; border: none; border-radius: 12px; font-size: 15px; background: rgba(255, 255, 255, 0.12); color: #000; box-sizing: border-box; outline: none; transition: all 0.2s ease; backdrop-filter: blur(10px);" 
                     onfocus="this.style.background='rgba(255, 255, 255, 0.18)'"
                     onblur="this.style.background='rgba(255, 255, 255, 0.12)'">
            </div>
            <div style="display: flex; gap: 12px;">
              <button onclick="saveScheduleEdit('${scheduleId}')" style="width: 100%; background: rgba(255, 255, 255, 0.12); color: #000; border: none; border-radius: 12px; padding: 14px 16px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.18)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.12)'">
                저장
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(dialog);
        
        // 제목 입력란에 포커스
        setTimeout(() => {
          document.getElementById('editScheduleTitle').focus();
        }, 100);
      }
      
      // 일정 수정 다이얼로그 닫기 함수
      function closeEditScheduleDialog() {
        removeElement('editScheduleDialog');
      }
      
      // 일정 수정 저장 함수
      async function saveScheduleEdit(scheduleId) {
        const titleInput = document.getElementById('editScheduleTitle');
        
        const newTitle = titleInput.value.trim();
        
        if (!newTitle) {
          alert('일정 제목을 입력해주세요.');
          titleInput.focus();
          return;
        }
        
        try {
          // Firebase에서 해당 일정 찾기 및 업데이트
          if (window.db && window.firestore) {
            const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
            if (docSnap.exists() && docSnap.data().customSchedules) {
              const customSchedules = docSnap.data().customSchedules;
              const scheduleIndex = customSchedules.findIndex(schedule => schedule.id === scheduleId);
              
              if (scheduleIndex !== -1) {
                // 기존 제목 저장 (연관 데이터 업데이트용)
                const oldTitle = customSchedules[scheduleIndex].title;
                
                // 일정 업데이트
                customSchedules[scheduleIndex].title = newTitle;
                customSchedules[scheduleIndex].timestamp = new Date().toISOString();
                
                // Firebase에 저장 (1차: 일정 제목만 우선 저장)
                await window.firestore.updateDoc(
                  window.firestore.doc(window.db, 'users', 'currentUser'),
                  {
                    customSchedules: customSchedules,
                    lastUpdated: window.firestore.serverTimestamp()
                  }
                );
                
                // 연관 데이터(userAddedItems, savedUserRoutes, savedUserMarkers)의 section/location을 새 제목으로 갱신
                try {
                  const userDocRef = window.firestore.doc(window.db, 'users', 'currentUser');
                  const currentDoc = await window.firestore.getDoc(userDocRef);
                  if (currentDoc.exists()) {
                    const data = currentDoc.data();
                    const updates = {};
                    let hasUpdates = false;
                    
                    // 세부항목 섹션명 업데이트
                    if (Array.isArray(data.userAddedItems)) {
                      const updatedUserItems = data.userAddedItems.map(function(item) {
                        if (item && item.section === oldTitle) {
                          return { ...item, section: newTitle };
                        }
                        return item;
                      });
                      updates.userAddedItems = updatedUserItems;
                      window.firebaseUserItems = updatedUserItems;
                      hasUpdates = true;
                    }
                    
                    // 경로 location 업데이트
                    if (Array.isArray(data.savedUserRoutes)) {
                      const updatedRoutes = data.savedUserRoutes.map(function(route) {
                        if (route && route.location === oldTitle) {
                          return { ...route, location: newTitle };
                        }
                        return route;
                      });
                      updates.savedUserRoutes = updatedRoutes;
                      if (typeof savedUserRoutes !== 'undefined') {
                        savedUserRoutes = updatedRoutes;
                      }
                      hasUpdates = true;
                    }
                    
                    // 마커 location 업데이트
                    if (Array.isArray(data.savedUserMarkers)) {
                      const updatedMarkers = data.savedUserMarkers.map(function(marker) {
                        if (marker && marker.location === oldTitle) {
                          return { ...marker, location: newTitle };
                        }
                        return marker;
                      });
                      updates.savedUserMarkers = updatedMarkers;
                      window.savedUserMarkers = updatedMarkers;
                      hasUpdates = true;
                    }
                    
                    if (hasUpdates) {
                      updates.lastUpdated = window.firestore.serverTimestamp();
                      await window.firestore.updateDoc(userDocRef, updates);
                      
                      // UI 갱신
                      try {
                        displayUserAddedItemsFromFirebase(window.firebaseUserItems || []);
                        drawAllSavedRoutes();
                        drawAllSavedMarkers();
                        updateRouteRemoveButtons();
                      } catch (uiErr) {
                        console.warn('일정 제목 변경 후 UI 갱신 경고:', uiErr);
                      }
                    }
                  }
                } catch (relErr) {
                  console.error('연관 데이터 제목/위치 갱신 실패:', relErr);
                }
                
                // UI 업데이트 (해당 컨테이너 텍스트/속성 반영)
                const scheduleBtn = cachedElements[`schedule_${scheduleId}`] || document.querySelector(`[data-schedule-id="${scheduleId}"] .toggle-btn`);
                const scheduleContainer = document.querySelector(`[data-schedule-id="${scheduleId}"]`);
                if (scheduleBtn && scheduleContainer) {
                  scheduleBtn.textContent = newTitle;
                  scheduleBtn.setAttribute('data-schedule-title', newTitle);
                  scheduleContainer.setAttribute('data-schedule-title', newTitle);
                }
                
                onFirebaseUploadSuccess('일정 수정');
              }
            }
          }
          
          // 다이얼로그 닫기
          closeEditScheduleDialog();
          
        } catch (error) {
          console.error('일정 수정 실패:', error);
          alert('일정 수정에 실패했습니다. 다시 시도해주세요.');
        }
      }
      
      // 일정 삭제 함수
      async function deleteSchedule(scheduleId, scheduleTitle) {
        // 컨텍스트 메뉴 닫기
        const contextMenu = document.getElementById('scheduleContextMenu');
        if (contextMenu) {
          contextMenu.remove();
        }
        
        // 스와이프 상태 해제
        const item = document.querySelector(`[data-schedule-id="${scheduleId}"]`);
        if (item) {
          item.classList.remove('swiped');
          const itemContent = item.querySelector('.item-content');
          if (itemContent) {
            itemContent.style.width = '100%';
          }
        }
        
        if (!confirm(`"${scheduleTitle}" 일정을 삭제하시겠습니까?`)) {
          return;
        }
        
        try {
          // Firebase에서 해당 일정과 관련된 체크리스트 항목들도 함께 제거
          if (window.db && window.firestore) {
            const docSnap = await window.firestore.getDoc(window.firestore.doc(window.db, 'users', 'currentUser'));
            if (docSnap.exists()) {
              const data = docSnap.data();
              const customSchedules = data.customSchedules || [];
              const userAddedItems = data.userAddedItems || [];
              const preparationCheckboxes = data.preparationCheckboxes || {};
              const savedUserRoutes = data.savedUserRoutes || [];
              const savedUserMarkers = data.savedUserMarkers || [];
              const markerInfoData = data.markerInfoData || {};
              const routeInfoData = data.routeInfoData || {};
              
              // 해당 일정 제거
              const updatedSchedules = customSchedules.filter(schedule => schedule.id !== scheduleId);
              
              // 해당 일정과 관련된 체크리스트 항목들 제거 (section이 일정 제목과 일치하는 항목들)
              const updatedUserItems = userAddedItems.filter(item => item.section !== scheduleTitle);
              
              // 해당 일정과 관련된 경로들 제거 (location이 일정 제목과 일치하는 경로들)
              const routesToDelete = savedUserRoutes.filter(route => route.location === scheduleTitle);
              const updatedRoutes = savedUserRoutes.filter(route => route.location !== scheduleTitle);
              
              // 해당 일정과 관련된 마커들 제거 (location이 일정 제목과 일치하는 마커들)
              const markersToDelete = savedUserMarkers.filter(marker => marker.location === scheduleTitle);
              const updatedMarkers = savedUserMarkers.filter(marker => marker.location !== scheduleTitle);
              
              // 해당 체크리스트 항목들의 체크박스 상태도 제거
              const updatedCheckboxes = { ...preparationCheckboxes };
              userAddedItems.forEach(item => {
                if (item.section === scheduleTitle) {
                  delete updatedCheckboxes[item.id];
                }
              });
              
              // 해당 마커들의 정보 데이터도 제거
              const updatedMarkerInfoData = { ...markerInfoData };
              markersToDelete.forEach(markerGroup => {
                const count = Array.isArray(markerGroup.markers) ? markerGroup.markers.length : 0;
                for (let i = 0; i < count; i++) {
                  const key = markerGroup.id ? `${markerGroup.id}-${i}` : `${markerGroup.name}-${i}`;
                  if (updatedMarkerInfoData[key]) {
                    delete updatedMarkerInfoData[key];
                  }
                }
              });
              
              // 해당 경로들의 정보 데이터도 제거
              const updatedRouteInfoData = { ...routeInfoData };
              routesToDelete.forEach(route => {
                if (route.id && updatedRouteInfoData[route.id]) {
                  delete updatedRouteInfoData[route.id];
                }
              });
              
              // 지도상에서 해당 마커들 제거
              markersToDelete.forEach(markerGroup => {
                if (markerGroup.markerElements) {
                  markerGroup.markerElements.forEach(marker => {
                    if (marker && marker.setMap) {
                      marker.setMap(null);
                    }
                  });
                }
              });
              
              // 지도상에서 해당 경로들 제거
              routesToDelete.forEach(route => {
                if (route.pathElement) {
                  route.pathElement.setMap(null);
                }
                if (route.dottedPathElement) {
                  route.dottedPathElement.setMap(null);
                }
              });
              
              // Firebase에 저장
              await window.firestore.updateDoc(
                window.firestore.doc(window.db, 'users', 'currentUser'),
                {
                  customSchedules: updatedSchedules,
                  userAddedItems: updatedUserItems,
                  preparationCheckboxes: updatedCheckboxes,
                  savedUserRoutes: updatedRoutes,
                  savedUserMarkers: updatedMarkers,
                  markerInfoData: updatedMarkerInfoData,
                  routeInfoData: updatedRouteInfoData,
                  lastUpdated: window.firestore.serverTimestamp()
                }
              );
              
              // 전역 변수 업데이트
              if (typeof window.savedUserRoutes !== 'undefined') {
                window.savedUserRoutes = updatedRoutes;
              }
              if (typeof window.savedUserMarkers !== 'undefined') {
                window.savedUserMarkers = updatedMarkers;
              }
              if (typeof window.markerInfoData !== 'undefined') {
                window.markerInfoData = updatedMarkerInfoData;
              }
              if (typeof window.routeInfoData !== 'undefined') {
                window.routeInfoData = updatedRouteInfoData;
              }
              
              // UI에서 일정 컨테이너 제거
              const scheduleContainer = cachedElements[`schedule_${scheduleId}`] || document.querySelector(`[data-schedule-id="${scheduleId}"]`);
              if (scheduleContainer) {
                scheduleContainer.remove();
              }
              
              // UI에서 관련된 체크리스트 항목들도 제거
              const relatedItems = document.querySelectorAll(`[data-item-type="user"][data-section="${scheduleTitle}"]`);
              relatedItems.forEach(item => item.remove());
              
              // 마커/경로 제거 버튼 상태 업데이트
              if (typeof updateMarkerRemoveButtons === 'function') {
                updateMarkerRemoveButtons();
              }
              if (typeof updateRouteRemoveButtons === 'function') {
                updateRouteRemoveButtons();
              }
              
              // 삭제된 항목 수 계산
              const deletedCount = {
                markers: markersToDelete.length,
                routes: routesToDelete.length,
                items: userAddedItems.length - updatedUserItems.length
              };
              
              let message = '일정 삭제 완료';
              if (deletedCount.items > 0 || deletedCount.markers > 0 || deletedCount.routes > 0) {
                const parts = [];
                if (deletedCount.items > 0) parts.push(`체크리스트 ${deletedCount.items}개`);
                if (deletedCount.markers > 0) parts.push(`마커 ${deletedCount.markers}개`);
                if (deletedCount.routes > 0) parts.push(`경로 ${deletedCount.routes}개`);
                message += ` (${parts.join(', ')} 함께 제거됨)`;
              }
              
              onFirebaseUploadSuccess(message);
            }
          }
          
        } catch (error) {
          console.error('일정 삭제 실패:', error);
          alert('일정 삭제에 실패했습니다. 다시 시도해주세요.');
        }
      }

    </script>

         <!-- Firebase SDK 스크립트 -->
    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js";
      import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, arrayUnion, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";
      // TODO: Add SDKs for Firebase products that you want to use
      // https://firebase.google.com/docs/web/setup#available-libraries

      // Your web app's Firebase configuration (WMAP)
      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
      const firebaseConfig = {
        apiKey: "AIzaSyCaHU7OusDuiZmqVNEUXmuiWjpq6g1p55E",
        authDomain: "wmpa-3fdb1.firebaseapp.com",
        projectId: "wmpa-3fdb1",
        storageBucket: "wmpa-3fdb1.firebasestorage.app",
        messagingSenderId: "526866934993",
        appId: "1:526866934993:web:7bcb33b218bbaadd9429f0",
        measurementId: "G-ZRYCTJWK5Y"
      };

      // Initialize Firebase (WMAP)
      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);
      
      // Initialize Firestore (WMAP)
      const db = getFirestore(app);
       
       console.log('Firebase Firestore 연결 완료!');
       
       // 전역 변수로 db를 사용할 수 있도록 설정
       window.db = db;
       window.firestore = {
         collection,
         doc,
         setDoc,
         getDoc,
         updateDoc,
         arrayUnion,
         onSnapshot,
         serverTimestamp
       };
      
      // 연결 테스트 후 초기화 완료 이벤트 발생
       try {
         // 간단한 연결 테스트
         const testDoc = doc(db, 'users', 'testConnection');
         await getDoc(testDoc);
         console.log('Firebase 연결 테스트 성공');
         
         // Firebase 초기화 완료 이벤트 발생
         window.dispatchEvent(new CustomEvent('firebaseReady'));
       } catch (error) {
         console.warn('Firebase 연결 테스트 실패:', error);
         // 연결 테스트 실패해도 초기화는 완료로 간주
         window.dispatchEvent(new CustomEvent('firebaseReady'));
       }
     </script>
    
    <!-- 구글 맵 API 스크립트. API 키와 콜백 함수(initMap) 지정 -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDVwJrvIcbqAOX24g9JODhD7DGtTz7z2Pg&libraries=geometry,directions,places&callback=initMap" async defer></script>
</body>
</html>


