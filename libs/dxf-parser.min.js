// ê°œì„ ëœ DXF íŒŒì„œ
(function(global) {
    'use strict';
    
    function DxfParser() {}
    
    DxfParser.prototype.parseSync = function(dxfString) {
        try {
            var lines = dxfString.split(/\r?\n/).map(function(line) {
                return line.trim();
            }).filter(function(line) {
                return line.length > 0;
            });
            
            var entities = [];
            var i = 0;
            var inEntitiesSection = false;
            
            console.log('ğŸ“„ DXF ë¼ì¸ ìˆ˜:', lines.length);
            
            while (i < lines.length) {
                var code = lines[i];
                var value = lines[i + 1] || '';
                
                // SECTION ì‹œì‘
                if (code === '0' && value === 'SECTION') {
                    i += 2;
                    if (lines[i] === '2' && lines[i + 1] === 'ENTITIES') {
                        inEntitiesSection = true;
                        console.log('âœ… ENTITIES ì„¹ì…˜ ì‹œì‘');
                        i += 2;
                        continue;
                    }
                }
                
                // SECTION ë
                if (code === '0' && value === 'ENDSEC') {
                    if (inEntitiesSection) {
                        console.log('âœ… ENTITIES ì„¹ì…˜ ì¢…ë£Œ');
                        inEntitiesSection = false;
                    }
                    i += 2;
                    continue;
                }
                
                // ì—”í‹°í‹° ì‹œì‘
                if (inEntitiesSection && code === '0') {
                    var entityType = value;
                    
                    if (entityType === 'LINE') {
                        var line = parseLineEntity(lines, i);
                        if (line) {
                            entities.push(line.entity);
                            i = line.nextIndex;
                            continue;
                        }
                    } else if (entityType === 'CIRCLE') {
                        var circle = parseCircleEntity(lines, i);
                        if (circle) {
                            entities.push(circle.entity);
                            i = circle.nextIndex;
                            continue;
                        }
                    } else if (entityType === 'ARC') {
                        var arc = parseArcEntity(lines, i);
                        if (arc) {
                            entities.push(arc.entity);
                            i = arc.nextIndex;
                            continue;
                        }
                    } else if (entityType === 'LWPOLYLINE' || entityType === 'POLYLINE') {
                        var poly = parsePolylineEntity(lines, i);
                        if (poly) {
                            entities.push(poly.entity);
                            i = poly.nextIndex;
                            continue;
                        }
                    }
                }
                
                i += 2;
            }
            
            console.log('âœ… DXF íŒŒì‹± ì™„ë£Œ:', entities.length, 'ê°œ ì—”í‹°í‹°');
            entities.forEach(function(e, idx) {
                if (idx < 3) console.log('ì—”í‹°í‹°', idx, ':', e);
            });
            
            return { entities: entities };
            
        } catch (error) {
            console.error('âŒ DXF íŒŒì‹± ì˜¤ë¥˜:', error);
            throw error;
        }
    };
    
    function parseLineEntity(lines, startIndex) {
        var entity = {
            type: 'LINE',
            startPoint: {},
            endPoint: {}
        };
        
        var i = startIndex + 2; // 0, LINE ê±´ë„ˆë›°ê¸°
        
        while (i < lines.length) {
            var code = lines[i];
            var value = lines[i + 1] || '';
            
            if (code === '0') break; // ë‹¤ìŒ ì—”í‹°í‹°
            
            switch (code) {
                case '10': entity.startPoint.x = parseFloat(value); break;
                case '20': entity.startPoint.y = parseFloat(value); break;
                case '30': entity.startPoint.z = parseFloat(value); break;
                case '11': entity.endPoint.x = parseFloat(value); break;
                case '21': entity.endPoint.y = parseFloat(value); break;
                case '31': entity.endPoint.z = parseFloat(value); break;
            }
            
            i += 2;
        }
        
        if (entity.startPoint.x !== undefined && entity.endPoint.x !== undefined) {
            return { entity: entity, nextIndex: i };
        }
        
        return null;
    }
    
    function parseCircleEntity(lines, startIndex) {
        var entity = {
            type: 'CIRCLE',
            center: {},
            radius: 0
        };
        
        var i = startIndex + 2;
        
        while (i < lines.length) {
            var code = lines[i];
            var value = lines[i + 1] || '';
            
            if (code === '0') break;
            
            switch (code) {
                case '10': entity.center.x = parseFloat(value); break;
                case '20': entity.center.y = parseFloat(value); break;
                case '30': entity.center.z = parseFloat(value); break;
                case '40': entity.radius = parseFloat(value); break;
            }
            
            i += 2;
        }
        
        if (entity.center.x !== undefined && entity.radius > 0) {
            return { entity: entity, nextIndex: i };
        }
        
        return null;
    }
    
    function parseArcEntity(lines, startIndex) {
        var entity = {
            type: 'ARC',
            center: {},
            radius: 0,
            startAngle: 0,
            endAngle: 360
        };
        
        var i = startIndex + 2;
        
        while (i < lines.length) {
            var code = lines[i];
            var value = lines[i + 1] || '';
            
            if (code === '0') break;
            
            switch (code) {
                case '10': entity.center.x = parseFloat(value); break;
                case '20': entity.center.y = parseFloat(value); break;
                case '30': entity.center.z = parseFloat(value); break;
                case '40': entity.radius = parseFloat(value); break;
                case '50': entity.startAngle = parseFloat(value); break;
                case '51': entity.endAngle = parseFloat(value); break;
            }
            
            i += 2;
        }
        
        if (entity.center.x !== undefined && entity.radius > 0) {
            return { entity: entity, nextIndex: i };
        }
        
        return null;
    }
    
    function parsePolylineEntity(lines, startIndex) {
        var entity = {
            type: 'LWPOLYLINE',
            vertices: []
        };
        
        var i = startIndex + 2;
        var currentVertex = {};
        
        while (i < lines.length) {
            var code = lines[i];
            var value = lines[i + 1] || '';
            
            if (code === '0') break;
            
            if (code === '10') {
                if (currentVertex.x !== undefined) {
                    entity.vertices.push(currentVertex);
                    currentVertex = {};
                }
                currentVertex.x = parseFloat(value);
            } else if (code === '20') {
                currentVertex.y = parseFloat(value);
            }
            
            i += 2;
        }
        
        if (currentVertex.x !== undefined) {
            entity.vertices.push(currentVertex);
        }
        
        if (entity.vertices.length > 0) {
            return { entity: entity, nextIndex: i };
        }
        
        return null;
    }
    
    // Export
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = DxfParser;
    } else {
        global.DxfParser = DxfParser;
    }
    
})(typeof window !== 'undefined' ? window : this);

console.log('âœ… DxfParser ë¡œë“œë¨ (ê°œì„  ë²„ì „)');
